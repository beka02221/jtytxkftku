<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Прототип Карточной TD-игры</title>
  <style>
    /* Стили общего контейнера */
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #f2f2f2;
      user-select: none; /* чтобы не выделялся текст при кликах */
    }
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 auto;
      width: 800px;
      border: 1px solid #ccc;
      background: #fff;
    }
    header {
      width: 100%;
      background: #333;
      color: #fff;
      text-align: center;
      padding: 10px;
    }
    .status-bar {
      display: flex;
      justify-content: space-around;
      background: #eee;
      width: 100%;
      padding: 10px 0;
      box-sizing: border-box;
    }
    .status-item {
      font-weight: bold;
    }
    /* Игровое поле (сетка) */
    #grid {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(4, 60px);
      gap: 5px;
      background: #ccc;
      padding: 10px;
      box-sizing: border-box;
    }
    .cell {
      width: 60px;
      height: 60px;
      background: #fff;
      border: 1px solid #999;
      position: relative; /* чтобы можно было позиционировать юнит */
      cursor: pointer;
    }
    /* Замок справа (условно) */
    #castle {
      position: absolute;
      right: -10px;
      top: 0;
      width: 10px;
      height: 100%;
      background: #666;
    }
    /* Юнит на поле */
    .unit {
      width: 100%;
      height: 100%;
      background: #4caf50; /* зелёный квадрат */
      opacity: 0.8;
    }
    /* Враг (простой красный квадрат) */
    .enemy {
      width: 30px;
      height: 30px;
      background: #f44336; /* красный */
      position: absolute;
      top: 15px; /* чтобы примерно центрировать в клетке */
      left: 0;
    }
    /* Панель карт внизу */
    #card-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      background: #ddd;
      width: 100%;
      padding: 10px 0;
      box-sizing: border-box;
    }
    .card {
      width: 80px;
      height: 120px;
      background: #fff;
      border: 2px solid #333;
      border-radius: 8px;
      margin: 0 10px;
      text-align: center;
      cursor: pointer;
      position: relative;
    }
    .card.selected {
      border-color: #2196f3; /* подсветка выбранной карты */
    }
    .card-cost {
      position: absolute;
      bottom: 5px;
      right: 5px;
      background: #ffc107;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <header>
      <h1>Прототип: Карточная игра с защитой замка</h1>
    </header>
    <!-- Панель со статусами: ресурсы, здоровье замка, волна и т.д. -->
    <div class="status-bar">
      <div class="status-item">Ресурс: <span id="resource">5</span></div>
      <div class="status-item">Здоровье замка: <span id="castle-health">10</span></div>
      <div class="status-item">Волна: <span id="wave-count">1</span></div>
    </div>
    
    <!-- Игровое поле -->
    <div id="grid-container" style="position: relative;">
      <div id="grid"></div>
      <div id="castle"></div>
    </div>
    
    <!-- Панель карт -->
    <div id="card-panel">
      <!-- Пример 1 карты -->
      <div class="card" data-card-id="archer">
        <div>Лучник</div>
        <div class="card-cost">2</div>
      </div>
      <!-- Можно добавить ещё карты по аналогии -->
      <div class="card" data-card-id="knight">
        <div>Рыцарь</div>
        <div class="card-cost">3</div>
      </div>
    </div>
  </div>

  <script>
    /********************************************************
     * ДАННЫЕ ИГРЫ
     ********************************************************/
    // Параметры карт (можно расширять)
    const cardData = {
      archer: {
        name: "Лучник",
        cost: 2,
        damage: 1,
        range: 2,
        attackSpeed: 60, // период атак (кадры)
      },
      knight: {
        name: "Рыцарь",
        cost: 3,
        damage: 2,
        range: 1,
        attackSpeed: 90,
      }
    };

    // Текущее состояние игры
    let resource = 5;       // Количество «маны»/«энергии»
    let castleHealth = 10;  // Здоровье замка
    let waveCount = 1;      // Номер текущей волны
    let selectedCard = null; // Какая карта выбрана для размещения

    // Хранение юнитов и врагов
    let units = [];  // [{cellIndex: number, type: 'archer'|..., cooldown: number, ...}, ...]
    let enemies = []; // [{xPos: number, row: number, health: number, speed: number, ...}, ...]

    // Настройки врагов (упрощённые)
    let enemySpawnTimer = 0;     // Счётчик до спавна следующего врага
    const enemySpawnInterval = 120; // Каждые 120 кадров спавн врага
    const enemyBaseHealth = 3;
    const enemyBaseSpeed = 0.5;

    // Размеры сетки
    const rows = 4;
    const cols = 8;

    /********************************************************
     * ИНИЦИАЛИЗАЦИЯ
     ********************************************************/
    const grid = document.getElementById("grid");
    const resourceEl = document.getElementById("resource");
    const castleHealthEl = document.getElementById("castle-health");
    const waveCountEl = document.getElementById("wave-count");

    // Создаём клетки на поле
    for (let i = 0; i < rows * cols; i++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.index = i;
      grid.appendChild(cell);
    }

    // Обработка клика на клетке
    grid.addEventListener("click", (e) => {
      if (!selectedCard) return; // если карта не выбрана, ничего не делаем
      if (!e.target.classList.contains("cell")) return;
      const cellIndex = parseInt(e.target.dataset.index);

      // Проверяем, есть ли уже юнит в этой клетке
      const existingUnit = units.find(u => u.cellIndex === cellIndex);
      if (existingUnit) {
        alert("Здесь уже стоит юнит!");
        return;
      }

      // Проверяем, хватает ли ресурсов
      const cardInfo = cardData[selectedCard];
      if (resource < cardInfo.cost) {
        alert("Недостаточно ресурсов!");
        return;
      }

      // Ставим юнита
      placeUnit(cellIndex, selectedCard);
      // Снимаем выбор карты
      deselectCards();
    });

    // Обработка клика по картам
    const cards = document.querySelectorAll(".card");
    cards.forEach(card => {
      card.addEventListener("click", () => {
        deselectCards();
        card.classList.add("selected");
        selectedCard = card.dataset.cardId;
      });
    });

    function deselectCards() {
      cards.forEach(c => c.classList.remove("selected"));
      selectedCard = null;
    }

    // Функция для размещения юнита
    function placeUnit(cellIndex, cardId) {
      const cellElement = grid.children[cellIndex];
      const unitElement = document.createElement("div");
      unitElement.className = "unit";
      cellElement.appendChild(unitElement);

      // Списываем ресурс
      resource -= cardData[cardId].cost;
      updateUI();

      // Добавляем в массив
      units.push({
        cellIndex: cellIndex,
        type: cardId,
        damage: cardData[cardId].damage,
        range: cardData[cardId].range,
        attackSpeed: cardData[cardId].attackSpeed,
        attackCooldown: 0 // счётчик до следующей атаки
      });
    }

    // Обновление UI
    function updateUI() {
      resourceEl.textContent = resource;
      castleHealthEl.textContent = castleHealth;
      waveCountEl.textContent = waveCount;
    }

    /********************************************************
     * ГЛАВНЫЙ ЦИКЛ (GAME LOOP)
     ********************************************************/
    let frame = 0;
    function gameLoop() {
      frame++;

      // Спавн врагов
      spawnEnemies();

      // Движение врагов
      moveEnemies();

      // Атаки юнитов
      handleUnitsAttack();

      // Проверка конца игры
      checkGameOver();

      // Продолжаем цикл
      requestAnimationFrame(gameLoop);
    }

    // Запуск
    updateUI();
    gameLoop();

    /********************************************************
     * СПАВН ВРАГОВ
     ********************************************************/
    function spawnEnemies() {
      if (enemySpawnTimer <= 0) {
        // Создаём врага в одной из строк
        const row = Math.floor(Math.random() * rows);
        enemies.push({
          row: row,
          xPos: -30, // начальная позиция слева (отрицательная, чтобы зашёл на поле)
          health: enemyBaseHealth + waveCount * 0.5, 
          speed: enemyBaseSpeed + waveCount * 0.05,
          element: createEnemyElement(row)
        });
        enemySpawnTimer = enemySpawnInterval;
      } else {
        enemySpawnTimer--;
      }
    }

    // Создаём DOM-элемент для врага
    function createEnemyElement(row) {
      const enemyEl = document.createElement("div");
      enemyEl.className = "enemy";
      // Ищем соответствующую строку на сетке
      const cellElement = grid.children[row * cols]; 
      cellElement.appendChild(enemyEl);
      return enemyEl;
    }

    /********************************************************
     * ДВИЖЕНИЕ ВРАГОВ
     ********************************************************/
    function moveEnemies() {
      enemies.forEach((enemy, index) => {
        // Двигаем врага вправо
        enemy.xPos += enemy.speed;
        if (enemy.element) {
          enemy.element.style.left = enemy.xPos + "px";
        }

        // Если враг достиг правого края (замка)
        if (enemy.xPos >= (cols * 60)) {
          // Наносит урон замку
          castleHealth -= 1;
          updateUI();

          // Удаляем врага
          removeEnemy(index);
        } else {
          // Обновляем DOM-позицию, перемещая в нужную клетку
          // Найдём индекс клетки, где он примерно находится
          // Приблизительно: (enemy.xPos / ширина клетки) даёт сдвиг по колонкам
          // Но для упрощения пока оставляем только left-стиль
        }
      });
      // Убираем "дыры" после удаления
      enemies = enemies.filter(e => e.health > 0 && e.xPos < cols * 60);
    }

    function removeEnemy(i) {
      if (enemies[i].element && enemies[i].element.parentNode) {
        enemies[i].element.parentNode.removeChild(enemies[i].element);
      }
      enemies.splice(i, 1);
    }

    /********************************************************
     * АТАКА ЮНИТОВ
     ********************************************************/
    function handleUnitsAttack() {
      units.forEach(unit => {
        // Счётчик перезарядки
        if (unit.attackCooldown > 0) {
          unit.attackCooldown--;
          return;
        }

        // Координаты юнита
        const unitRow = Math.floor(unit.cellIndex / cols);
        const unitCol = unit.cellIndex % cols;

        // Ищем врагов в радиусе атаки (по колоннам)
        // Радиус = unit.range (в клетках вправо, для упрощения)
        // Для точности можно переводить xPos во «внутренние» координаты
        // но сделаем просто: враг в той же строке, и разница в колоннах <= range
        let targetFound = false;
        enemies.forEach(enemy => {
          if (enemy.row === unitRow) {
            // Примерное определение колонки врага
            // enemy.xPos ~ сколько px прошёл, делим на 60 px, получим колонку
            const enemyCol = enemy.xPos / 60;
            if ((enemyCol - unitCol) <= unit.range && (enemyCol - unitCol) >= 0) {
              // Атакуем этого врага
              enemy.health -= unit.damage;
              // Устанавливаем перезарядку
              unit.attackCooldown = unit.attackSpeed;
              targetFound = true;
            }
          }
        });
        // Удаляем врагов с 0 или меньше здоровья
        enemies = enemies.filter((enemy, index) => {
          if (enemy.health <= 0) {
            removeEnemy(index);
            return false;
          }
          return true;
        });
      });
    }

    /********************************************************
     * ПРОВЕРКА КОНЦА ИГРЫ
     ********************************************************/
    function checkGameOver() {
      if (castleHealth <= 0) {
        alert("Замок разрушен! Игра окончена.");
        // Перезагрузка страницы для рестарта (простейший вариант)
        window.location.reload();
      }
    }
  </script>
</body>
</html>
