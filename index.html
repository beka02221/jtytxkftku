<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Игра "Три в ряд" + Магазин + Колесо фортуны</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <!-- Подключаем Telegram Web App JS -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden; 
      overflow-y: auto;
      background: #46257D; 
      font-family: 'Courier Prime', monospace;
      color: #39FF14;
    }

    /* Главное меню */
    #mainMenu {
      min-height: 100vh;
      width: 100%;
      display: none; /* скрываем, пока не загрузим пользователя */
      box-sizing: border-box;
      background: linear-gradient(135deg, #4F308F, #46257D);
      text-align: center;
      padding: 40px 20px;
    }
    #mainMenu h2 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #39FF14;
      text-shadow: 0 0 4px #00FF00;
      font-size: 20px;
    }
    #mainMenu p {
      margin: 8px 0;
      font-size: 14px;
      color: #ADFF2F;
    }
    #mainMenu button {
      display: block;
      margin: 10px auto;
      padding: 12px 24px;
      font-size: 14px;
      cursor: pointer;
      border: 2px solid #39FF14;
      background: #1E3C87; 
      color: #ffffff;
      border-radius: 8px;
      width: 90%;
      max-width: 300px;
      transition: all 0.2s ease-in-out;
      text-transform: uppercase;
    }
    #mainMenu button:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Таблица лидеров, Магазин, Инфо */
    #leaderboardContainer,
    #storeContainer,
    #infoContainer {
      min-height: 100vh;
      width: 100%;
      display: none;
      box-sizing: border-box;
      background: linear-gradient(135deg, #4F308F, #46257D);
      text-align: center;
      padding: 40px 20px;
    }
    #leaderboardContainer h2,
    #storeContainer h2,
    #infoContainer h2 {
      margin-top: 0;
      color: #39FF14;
      text-shadow: 0 0 4px #00FF00;
      font-size: 20px;
    }
    table {
      border-collapse: collapse;
      margin: 20px auto;
      width: 90%;
      max-width: 600px;
    }
    th, td {
      border: 1px solid #39FF14;
      padding: 10px 12px;
      text-align: left;
      font-size: 14px;
      color: #ADFF2F;
      background: #5B3E9E;
    }
    th {
      background: #6F4CBE;
      color: #ffffff;
    }

    /* Игровой экран — центрируем контент */
    #gameContainer {
      min-height: 100vh;
      width: 100%;
      display: none;
      box-sizing: border-box;
      background: #46257D;
      /* Flex-раскладка для центрирования */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 20px;
      padding-bottom: 20px;
    }
    #backToMenuBtn {
      margin-bottom: 10px;
      cursor: pointer;
      background: #1E3C87;
      border: 2px solid #39FF14;
      color: #ffffff;
      font-size: 12px;
      text-transform: uppercase;
      border-radius: 6px;
      transition: all 0.2s ease-in-out;
      padding: 10px 16px;
    }
    #backToMenuBtn:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }
    #gameCanvas {
      /* канвас теперь по центру */
      background-color: #3C266C;
      box-shadow: 0 0 10px rgba(57,255,20,0.4);
      max-width: 100%;
      height: auto;
      margin: 0 auto; /* горизонтальный центр */
    }
    /* Панель внизу для использования предметов */
    #itemPanel {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }
    #itemPanel button {
      background: #FF7F50;
      border: 2px solid #FFD700;
      color: #FFF;
      cursor: pointer;
      padding: 8px 16px;
      border-radius: 6px;
      text-transform: uppercase;
      transition: 0.2s;
    }
    #itemPanel button:hover {
      transform: scale(1.05);
      background: #FFA07A;
    }

    /* Модальные окна */
    .modalOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .modalContent {
      background: #4F308F;
      padding: 20px;
      border: 2px solid #39FF14;
      border-radius: 8px;
      text-align: center;
      position: relative;
      max-width: 400px;
      width: 80%;
      color: #39FF14;
      font-size: 14px;
      box-shadow: 0 0 12px rgba(57,255,20,0.4);
    }
    .modalContent h2 {
      margin-top: 0;
      font-size: 16px;
      text-shadow: 0 0 4px #00FF00;
    }
    .closeBtn {
      position: absolute;
      top: 10px;
      right: 15px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    }
    .modalContent button {
      background: #1E3C87;
      color: #ffffff;
      border: 2px solid #39FF14;
      cursor: pointer;
      padding: 10px 16px;
      font-size: 12px;
      text-transform: uppercase;
      border-radius: 6px;
      transition: all 0.2s ease-in-out;
    }
    .modalContent button:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Окно «Победа» */
    #winModal .modalContent {
      background: linear-gradient(135deg, #6233AE, #5E2B95);
      color: #39FF14;
      animation: flash 1.5s infinite alternate;
    }
    @keyframes flash {
      0% { box-shadow: 0 0 20px rgba(57,255,20,0.6); }
      100% { box-shadow: 0 0 0 rgba(57,255,20,0); }
    }

    /* Окно «Проигрыш» */
    #loseModal .modalContent {
      background: #2F1A4F;
      color: #39FF14;
    }

    /* Окно «Колесо фортуны» */
    #fortuneModal .modalContent {
      background: linear-gradient(135deg, #472874, #46257D);
      color: #39FF14;
      border: 3px dashed #39FF14;
    }
    .wheelContainer {
      position: relative;
      width: 320px;
      height: 320px;
      margin: 0 auto;
    }
    #fortuneWheel {
      width: 320px;
      height: 320px;
      border-radius: 50%;
      border: 4px solid #39FF14;
      position: relative;
      overflow: hidden;
      transform: rotate(0deg);
      transition: transform 4s cubic-bezier(0.33, 1, 0.68, 1);
      box-shadow: 0 0 15px #39FF14, inset 0 0 15px #39FF14;
      background: radial-gradient(circle, #46257D 20%, #2F1A4F 80%);
    }
    .section {
      width: 50%;
      height: 50%;
      position: absolute;
      transform-origin: 100% 100%;
      border: 1px dashed #39FF14;
    }
    .pointer {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-bottom: 30px solid #39FF14;
      z-index: 10;
      filter: drop-shadow(0 0 5px #39FF14);
    }
    #spinResultMsg {
      margin-top: 10px;
      font-weight: bold;
      font-size: 14px;
    }
    #spinWheelBtn {
      margin-top: 15px;
      background: #1E3C87;
      font-size: 12px;
      padding: 10px 20px;
      border-radius: 8px;
      text-transform: uppercase;
      color: #ffffff;
      border: 2px solid #39FF14;
      transition: all 0.2s ease-in-out;
    }
    #spinWheelBtn:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Адаптивность */
    @media (max-width: 480px) {
      #mainMenu h2,
      #leaderboardContainer h2,
      #storeContainer h2,
      #infoContainer h2 {
        font-size: 16px;
      }
      #mainMenu button,
      .modalContent button {
        font-size: 12px;
        padding: 10px 16px;
      }
      #gameCanvas {
        max-width: 90%;
      }
      .wheelContainer {
        width: 260px;
        height: 260px;
      }
      #fortuneWheel {
        width: 260px;
        height: 260px;
      }
      .pointer {
        top: -24px;
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-bottom: 24px solid #39FF14;
      }
    }
  </style>
</head>
<body>
  <!-- Главное меню -->
  <div id="mainMenu">
    <h2>Добро пожаловать в "Три в ряд"!</h2>
    <p id="userDisplay"></p>
    <p id="coinsDisplay"></p>
    <p id="ticketsDisplay"></p>

    <!-- Кнопка или таймер колеса фортуны -->
    <button id="openFortuneModalBtn">Крутить колесо фортуны</button>

    <button id="startGameBtn">Начать игру</button>
    <button id="leaderboardBtn">Таблица лидеров</button>
    <button id="storeBtn">Магазин улучшений</button>
    <button id="infoBtn">Информация</button>
    <button id="logoutBtn">Выйти</button>
  </div>

  <!-- Игровой экран -->
  <div id="gameContainer">
    <button id="backToMenuBtn">Выйти в меню</button>
    <canvas id="gameCanvas"></canvas>

    <!-- Панель предметов внизу (если user их купил) -->
    <div id="itemPanel">
      <!-- Появляются кнопки при наличии предметов -->
      <!-- +20 сек -->
      <button id="useExtraTimeBtn" style="display:none">
        +20 секунд (<span id="extraTimeCount">0</span>)
      </button>
      <!-- Бомба -->
      <button id="useBombBtn" style="display:none">
        Бомба (<span id="bombCount">0</span>)
      </button>
    </div>
  </div>

  <!-- Таблица лидеров -->
  <div id="leaderboardContainer">
    <h2>Таблица лидеров</h2>
    <table>
      <thead>
        <tr>
          <th>Пользователь</th>
          <th>Монет</th>
        </tr>
      </thead>
      <tbody id="leaderboardBody"></tbody>
    </table>
    <br />
    <button id="leaderboardBackBtn">Назад</button>
  </div>

  <!-- Магазин -->
  <div id="storeContainer">
    <h2>Магазин улучшений</h2>
    <p>Здесь можно приобрести различные бонусы за монеты.</p>
    
    <div style="margin-top:20px;">
      <h3>+20 секунд к таймеру</h3>
      <p>Цена: <b>50</b> монет</p>
      <button id="buyExtraTimeBtn">Купить</button>
    </div>

    <div style="margin-top:20px;">
      <h3>Бомба (3×3)</h3>
      <p>Цена: <b>100</b> монет</p>
      <button id="buyBombBtn">Купить</button>
    </div>

    <br/>
    <button id="storeBackBtn">Назад</button>
  </div>

  <!-- Информация -->
  <div id="infoContainer">
    <h2>Информация об игре "Три в ряд"</h2>
    <p>
      Цель игры: составлять ряды из трёх и более одинаковых фигур, набирая как можно больше очков.<br>
      Если ходов нет — поле перетасовывается. Игра длится 2 минуты (можно купить +20 секунд).<br>
      «Бомба» убирает фигуры в радиусе 3×3 от выбранной ячейки.
    </p>
    <button id="infoBackBtn">Назад</button>
  </div>

  <!-- =================== МОДАЛЬНЫЕ ОКНА =================== -->
  <!-- Окно "Победа" (если нужно) -->
  <div id="winModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="winModalClose">&times;</span>
      <h2>Поздравляем, вы выиграли!</h2>
      <p>Здесь может быть фейерверк или другая анимация.</p>
      <button id="takePrizeBtn">Забрать приз</button>
    </div>
  </div>

  <!-- Окно "Проигрыш" -->
  <div id="loseModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="loseModalClose">&times;</span>
      <h2>Время вышло!</h2>
      <p>Игра окончена. Попробуйте ещё раз!</p>
      <button id="tryAgainBtn">Ок</button>
    </div>
  </div>

  <!-- Окно Колеса фортуны -->
  <div id="fortuneModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="fortuneCloseBtn">&times;</span>
      <h2>Колесо Фортуны (1 раз в 24 часа)</h2>
      <div class="wheelContainer">
        <div class="pointer"></div>
        <div id="fortuneWheel">
          <!-- 5 «секторов» (пример) -->
          <div class="section"></div>
          <div class="section"></div>
          <div class="section"></div>
          <div class="section"></div>
          <div class="section"></div>
        </div>
      </div>
      <br>
      <button id="spinWheelBtn">Крутить колесо</button>
      <p id="spinResultMsg"></p>
    </div>
  </div>

  <!-- Подключение Firebase и основная логика -->
  <script type="module">
    // === ИМПОРТ FIREBASE ===
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { 
      getDatabase, 
      ref, 
      get, 
      set, 
      update
    } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

    // === КОНФИГУРАЦИЯ FIREBASE ===
    const firebaseConfig = {
      apiKey: "AIzaSyB...",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    // Инициализация Firebase
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Telegram WebApp
    const tg = window.Telegram.WebApp;
    tg.expand(); // Разворачиваем

    // DOM-элементы
    const mainMenu = document.getElementById("mainMenu");
    const userDisplay = document.getElementById("userDisplay");
    const coinsDisplay = document.getElementById("coinsDisplay");
    const ticketsDisplay = document.getElementById("ticketsDisplay");
    const openFortuneModalBtn = document.getElementById("openFortuneModalBtn");
    const startGameBtn = document.getElementById("startGameBtn");
    const leaderboardBtn = document.getElementById("leaderboardBtn");
    const storeBtn = document.getElementById("storeBtn");
    const infoBtn = document.getElementById("infoBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    // Модалки
    const fortuneModal = document.getElementById("fortuneModal");
    const fortuneCloseBtn = document.getElementById("fortuneCloseBtn");
    const spinWheelBtn = document.getElementById("spinWheelBtn");
    const spinResultMsg = document.getElementById("spinResultMsg");

    const winModal = document.getElementById("winModal");
    const winModalClose = document.getElementById("winModalClose");
    const takePrizeBtn = document.getElementById("takePrizeBtn");
    const loseModal = document.getElementById("loseModal");
    const loseModalClose = document.getElementById("loseModalClose");
    const tryAgainBtn = document.getElementById("tryAgainBtn");

    // Лидерборд
    const leaderboardContainer = document.getElementById("leaderboardContainer");
    const leaderboardBody = document.getElementById("leaderboardBody");
    const leaderboardBackBtn = document.getElementById("leaderboardBackBtn");

    // Магазин
    const storeContainer = document.getElementById("storeContainer");
    const storeBackBtn = document.getElementById("storeBackBtn");
    const buyExtraTimeBtn = document.getElementById("buyExtraTimeBtn");
    const buyBombBtn = document.getElementById("buyBombBtn");

    // Инфо
    const infoContainer = document.getElementById("infoContainer");
    const infoBackBtn = document.getElementById("infoBackBtn");

    // Игра
    const gameContainer = document.getElementById("gameContainer");
    const backToMenuBtn = document.getElementById("backToMenuBtn");
    const gameCanvas = document.getElementById("gameCanvas");
    let ctx;

    // Панель предметов в игре
    const itemPanel = document.getElementById("itemPanel");
    const useExtraTimeBtn = document.getElementById("useExtraTimeBtn");
    const extraTimeCountSpan = document.getElementById("extraTimeCount");
    const useBombBtn = document.getElementById("useBombBtn");
    const bombCountSpan = document.getElementById("bombCount");

    // Глобальные переменные
    let currentUsername = null;
    let currentCoins = 0;
    let currentTickets = 0;
    let lastSpinTime = 0;
    let inventory = {
      extraTime: 0,  // количество "+20 сек"
      bombs: 0       // количество "бомб"
    };

    // Игра "Три в ряд"
    let isGameRunning = false;
    let animationId;
    const boardSize = 8;
    let board = [];
    let cellSize = 80;
    let selectedCell = null;
    let scoreThisSession = 0;
    let comboCount = 0;
    let gameStartTime = 0;
    const BASE_GAME_TIME_LIMIT = 2 * 60 * 1000; // 2 минуты
    let currentGameTimeLimit = BASE_GAME_TIME_LIMIT; // можно увеличить покупкой

    const shapes = [
      { shape: "circle", color: "#FF6B6B" },
      { shape: "square", color: "#4ECDC4" },
      { shape: "triangle", color: "#FFD93D" },
      { shape: "hexagon", color: "#FF9F1C" },
      { shape: "star", color: "#9B5DE5" }
    ];
    let particles = [];
    const POINTS_PER_PIECE = 2;

    // Инициализация
    window.addEventListener("DOMContentLoaded", async () => {
      const initDataUnsafe = tg.initDataUnsafe;
      const user = initDataUnsafe?.user;
      if (!user) {
        alert("Не удалось получить данные пользователя из Telegram WebApp.");
        return;
      }
      let telegramUsername = user.username
        ? "@" + user.username.toLowerCase()
        : "@id" + user.id;

      // Автовход
      autoLogin(telegramUsername);
    });

    async function autoLogin(username) {
      const userRef = ref(db, `users/${username}`);
      const snapshot = await get(userRef);
      if (!snapshot.exists()) {
        // Создадим запись впервые
        await set(userRef, {
          coins: 0,
          tickets: 0,
          lastSpinTime: 0,
          inventory: { extraTime: 0, bombs: 0 }
        });
        currentCoins = 0;
        currentTickets = 0;
        lastSpinTime = 0;
        inventory = { extraTime: 0, bombs: 0 };
      } else {
        const data = snapshot.val();
        currentCoins = data.coins || 0;
        currentTickets = data.tickets || 0;
        lastSpinTime = data.lastSpinTime || 0;
        inventory = data.inventory || { extraTime: 0, bombs: 0 };
      }
      currentUsername = username;
      displayMainMenu();
    }

    // Отображение главного меню
    function displayMainMenu() {
      mainMenu.style.display = "block";
      gameContainer.style.display = "none";
      leaderboardContainer.style.display = "none";
      storeContainer.style.display = "none";
      infoContainer.style.display = "none";

      userDisplay.textContent = `Игрок: ${currentUsername}`;
      coinsDisplay.textContent = `Монет: ${currentCoins}`;
      ticketsDisplay.textContent = `Билетов: ${currentTickets}`;

      // Проверяем, прошло ли 24 часа
      updateFortuneButton();
    }

    // Обновляем надпись/доступ колеса фортуны
    function updateFortuneButton() {
      const now = Date.now();
      const diff = now - lastSpinTime; 
      const hours = diff / (1000 * 60 * 60);
      if (hours >= 24) {
        // Кнопка разблокирована
        openFortuneModalBtn.disabled = false;
        openFortuneModalBtn.style.opacity = "1";
        openFortuneModalBtn.textContent = "Крутить колесо фортуны";
      } else {
        openFortuneModalBtn.disabled = true;
        openFortuneModalBtn.style.opacity = "0.5";
        // Покажем, через сколько часов/минут
        const hoursLeft = 24 - hours;
        const h = Math.floor(hoursLeft);
        const m = Math.floor((hoursLeft - h) * 60);
        openFortuneModalBtn.textContent = `Колесо (через ${h}ч ${m}м)`;
      }
    }

    // Кнопки главного меню
    openFortuneModalBtn.addEventListener("click", () => {
      // Если не заблокировано (disabled = false)
      if (!openFortuneModalBtn.disabled) {
        openModal(fortuneModal);
        spinResultMsg.textContent = "";
      }
    });

    startGameBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      startGame();
    });

    leaderboardBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      leaderboardContainer.style.display = "block";
      loadLeaderboard();
    });

    storeBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      storeContainer.style.display = "block";
    });

    infoBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      infoContainer.style.display = "block";
    });

    logoutBtn.addEventListener("click", () => {
      currentUsername = null;
      currentCoins = 0;
      currentTickets = 0;
      inventory = { extraTime: 0, bombs: 0 };
      mainMenu.style.display = "none";
      alert("Вы вышли из аккаунта (локальные переменные сброшены). Откройте WebApp заново.");
    });

    // Магазин
    storeBackBtn.addEventListener("click", () => {
      storeContainer.style.display = "none";
      displayMainMenu();
    });
    buyExtraTimeBtn.addEventListener("click", async () => {
      const cost = 50;
      if (currentCoins >= cost) {
        currentCoins -= cost;
        inventory.extraTime = (inventory.extraTime || 0) + 1;
        await updateUserInDB();
        alert("Куплено +20 секунд!");
      } else {
        alert("Недостаточно монет!");
      }
    });
    buyBombBtn.addEventListener("click", async () => {
      const cost = 100;
      if (currentCoins >= cost) {
        currentCoins -= cost;
        inventory.bombs = (inventory.bombs || 0) + 1;
        await updateUserInDB();
        alert("Куплена Бомба!");
      } else {
        alert("Недостаточно монет!");
      }
    });

    // Инфо
    infoBackBtn.addEventListener("click", () => {
      infoContainer.style.display = "none";
      displayMainMenu();
    });

    // Лидерборд
    leaderboardBackBtn.addEventListener("click", () => {
      leaderboardContainer.style.display = "none";
      displayMainMenu();
    });
    async function loadLeaderboard() {
      leaderboardBody.innerHTML = "";
      const usersRef = ref(db, "users/");
      const snapshot = await get(usersRef);
      if (snapshot.exists()) {
        const data = snapshot.val();
        const usersArray = Object.keys(data).map(key => {
          return { username: key, coins: data[key].coins || 0 };
        });
        usersArray.sort((a, b) => b.coins - a.coins);
        usersArray.forEach(user => {
          const tr = document.createElement("tr");
          const tdName = document.createElement("td");
          const tdCoins = document.createElement("td");
          tdName.textContent = user.username;
          tdCoins.textContent = user.coins;
          tr.appendChild(tdName);
          tr.appendChild(tdCoins);
          leaderboardBody.appendChild(tr);
        });
      }
    }

    // Игра
    backToMenuBtn.addEventListener("click", () => {
      endGameAndReturn();
    });

    function startGame() {
      gameContainer.style.display = "block";
      ctx = gameCanvas.getContext("2d");
      resizeCanvas();

      initBoard();
      scoreThisSession = 0;
      comboCount = 0;
      selectedCell = null;

      // Сбрасываем время игры к базовому + возможно что-то добавим во время
      currentGameTimeLimit = BASE_GAME_TIME_LIMIT;
      gameStartTime = Date.now();

      removeAllMatches(true);
      isGameRunning = true;

      gameCanvas.addEventListener("mousedown", onCanvasClick);
      gameCanvas.addEventListener("touchstart", onCanvasTouch, { passive: false });

      // Отобразим, сколько у нас товаров
      refreshItemPanel();

      updateGame();
    }

    function refreshItemPanel() {
      // extraTime
      if (inventory.extraTime > 0) {
        useExtraTimeBtn.style.display = "inline-block";
        extraTimeCountSpan.textContent = inventory.extraTime;
      } else {
        useExtraTimeBtn.style.display = "none";
      }
      // bombs
      if (inventory.bombs > 0) {
        useBombBtn.style.display = "inline-block";
        bombCountSpan.textContent = inventory.bombs;
      } else {
        useBombBtn.style.display = "none";
      }
    }

    // Кнопки использования предметов
    useExtraTimeBtn.addEventListener("click", async () => {
      if (!isGameRunning) return;
      if (inventory.extraTime > 0) {
        inventory.extraTime--;
        currentGameTimeLimit += 20_000; // +20 секунд
        await updateUserInDB();
        alert("Добавлено +20 секунд к таймеру!");
        refreshItemPanel();
      }
    });
    useBombBtn.addEventListener("click", async () => {
      if (!isGameRunning) return;
      if (inventory.bombs > 0 && selectedCell) {
        inventory.bombs--;
        await updateUserInDB();
        // Применяем бомбу к окрестности 3x3 вокруг выбранной ячейки
        const { r, c } = selectedCell;
        bombArea(r, c);
        selectedCell = null;
        removeAllMatches(false);
        alert("Бомба активирована!");
        refreshItemPanel();
      } else {
        alert("Для бомбы сначала выберите ячейку на поле!");
      }
    });

    function bombArea(r, c) {
      // Уничтожим все фигуры в области [r-1..r+1][c-1..c+1]
      for (let rr = r-1; rr <= r+1; rr++) {
        for (let cc = c-1; cc <= c+1; cc++) {
          if (rr >= 0 && rr < boardSize && cc >= 0 && cc < boardSize) {
            if (board[rr][cc]) {
              board[rr][cc].removing = true;
              spawnParticles(board[rr][cc], rr, cc);
            }
          }
        }
      }
    }

    function resizeCanvas() {
      const maxWidth = window.innerWidth;
      const maxHeight = window.innerHeight - 200; // небольшой запас для кнопок
      const possibleCellSizeWidth = Math.floor(maxWidth / boardSize);
      const possibleCellSizeHeight = Math.floor(maxHeight / boardSize);
      cellSize = Math.min(80, possibleCellSizeWidth, possibleCellSizeHeight);

      gameCanvas.width = boardSize * cellSize;
      gameCanvas.height = boardSize * cellSize;
    }
    window.addEventListener("resize", () => {
      if (isGameRunning) {
        resizeCanvas();
      }
    });

    function initBoard() {
      board = [];
      for (let r = 0; r < boardSize; r++) {
        const row = [];
        for (let c = 0; c < boardSize; c++) {
          const piece = getRandomPiece();
          piece.x = c;
          piece.y = r;
          piece.scale = 1;
          piece.alpha = 1;
          piece.removing = false;
          piece.falling = false;
          row.push(piece);
        }
        board.push(row);
      }
    }
    function getRandomPiece() {
      const idx = Math.floor(Math.random() * shapes.length);
      const { shape, color } = shapes[idx];
      return { shape, color };
    }

    function updateGame() {
      if (!isGameRunning) return;
      const now = Date.now();
      const elapsed = now - gameStartTime;
      if (elapsed > currentGameTimeLimit) {
        openLoseModal();
        gameOverActions();
        return;
      }
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

      updateAnimations();
      drawBoard();
      drawParticles();
      drawHUD(elapsed);

      animationId = requestAnimationFrame(updateGame);
    }

    function drawHUD(elapsed) {
      ctx.fillStyle = "#000";
      ctx.font = "18px Arial";
      ctx.fillText(`Очки: ${scoreThisSession}`, 10, 20);

      const timeLeft = currentGameTimeLimit - elapsed;
      const secsLeft = Math.floor(timeLeft / 1000);
      const min = Math.floor(secsLeft / 60);
      const sec = secsLeft % 60;
      ctx.fillText(`Время: ${min}:${sec < 10 ? "0"+sec : sec}`, 10, 40);

      if (comboCount > 1) {
        ctx.fillStyle = "red";
        ctx.fillText(`Комбо x${comboCount}`, 10, 60);
      }
    }

    function updateAnimations() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const piece = board[r][c];
          if (!piece) continue;
          if (piece.removing) {
            piece.scale -= 0.1;
            piece.alpha -= 0.1;
            if (piece.scale <= 0 || piece.alpha <= 0) {
              board[r][c] = null;
            }
          }
          if (piece.falling !== false) {
            const targetRow = piece.falling;
            const diff = targetRow - piece.y;
            const speed = 0.2;
            if (Math.abs(diff) < 0.01) {
              piece.y = targetRow;
              piece.falling = false;
            } else {
              piece.y += diff * speed;
            }
          }
        }
      }
    }

    function drawBoard() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          drawCell(r, c);
        }
      }
      // Подсветка выбранной ячейки
      if (selectedCell) {
        const { r, c } = selectedCell;
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 4;
        ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
      }
    }
    function drawCell(r, c) {
      const piece = board[r][c];
      const px = c * cellSize;
      const py = r * cellSize;
      ctx.strokeStyle = "rgba(150, 150, 150, 0.3)";
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, cellSize, cellSize);

      if (!piece) return;

      const drawX = piece.x * cellSize;
      const drawY = piece.y * cellSize;

      ctx.save();
      ctx.translate(drawX + cellSize/2, drawY + cellSize/2);
      ctx.scale(piece.scale, piece.scale);
      ctx.globalAlpha = piece.alpha;
      ctx.translate(-cellSize/2, -cellSize/2);

      ctx.fillStyle = piece.color;
      switch (piece.shape) {
        case "circle":
          ctx.beginPath();
          ctx.arc(cellSize/2, cellSize/2, cellSize*0.35, 0, 2*Math.PI);
          ctx.fill();
          break;
        case "square":
          ctx.fillRect(cellSize*0.15, cellSize*0.15, cellSize*0.7, cellSize*0.7);
          break;
        case "triangle":
          ctx.beginPath();
          ctx.moveTo(cellSize/2, cellSize*0.1);
          ctx.lineTo(cellSize*0.1, cellSize*0.9);
          ctx.lineTo(cellSize*0.9, cellSize*0.9);
          ctx.closePath();
          ctx.fill();
          break;
        case "hexagon":
          drawHexagon(cellSize, cellSize);
          break;
        case "star":
          drawStar(cellSize, cellSize);
          break;
      }
      ctx.restore();
    }
    function drawHexagon(w, h) {
      const radius = w * 0.35;
      const cx = w / 2;
      const cy = h / 2;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = cx + radius * Math.cos(angle);
        const py = cy + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
    }
    function drawStar(w, h) {
      const cx = w / 2;
      const cy = h / 2;
      const spikes = 5;
      const outerRadius = w * 0.35;
      const innerRadius = outerRadius * 0.5;
      let rot = Math.PI / 2 * 3;
      let step = Math.PI / spikes;

      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        let xPos = cx + Math.cos(rot) * outerRadius;
        let yPos = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(xPos, yPos);
        rot += step;

        xPos = cx + Math.cos(rot) * innerRadius;
        yPos = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(xPos, yPos);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
    }

    function onCanvasClick(e) {
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      handleClick(x, y);
    }
    function onCanvasTouch(e) {
      e.preventDefault();
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      handleClick(x, y);
    }

    function handleClick(x, y) {
      if (!isGameRunning) return;
      const c = Math.floor(x / cellSize);
      const r = Math.floor(y / cellSize);
      if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) return;

      if (!selectedCell) {
        selectedCell = { r, c };
      } else {
        const { r: r1, c: c1 } = selectedCell;
        if (isNeighbor(r1, c1, r, c)) {
          swapPieces(r1, c1, r, c);
          const matched = findMatches();
          if (!matched.length) {
            // нет совпадений — отменяем
            swapPieces(r1, c1, r, c);
          } else {
            removeAllMatches(false);
          }
        }
        selectedCell = null;
      }
    }
    function isNeighbor(r1, c1, r2, c2) {
      const dr = Math.abs(r1 - r2);
      const dc = Math.abs(c1 - c2);
      return (dr + dc === 1);
    }
    function swapPieces(r1, c1, r2, c2) {
      const temp = board[r1][c1];
      board[r1][c1] = board[r2][c2];
      board[r2][c2] = temp;
      if (board[r1][c1]) {
        board[r1][c1].x = c1;
        board[r1][c1].y = r1;
      }
      if (board[r2][c2]) {
        board[r2][c2].x = c2;
        board[r2][c2].y = r2;
      }
    }

    function findMatches() {
      const toRemove = [];
      // Горизонталь
      for (let r = 0; r < boardSize; r++) {
        let matchLen = 1;
        for (let c = 1; c < boardSize; c++) {
          const curr = board[r][c];
          const prev = board[r][c-1];
          if (curr && prev && sameType(curr, prev)) {
            matchLen++;
          } else {
            if (matchLen >= 3) {
              for (let k = 0; k < matchLen; k++) {
                toRemove.push({ r, c: c-1-k });
              }
            }
            matchLen = 1;
          }
        }
        if (matchLen >= 3) {
          for (let k = 0; k < matchLen; k++) {
            toRemove.push({ r, c: boardSize-1-k });
          }
        }
      }
      // Вертикаль
      for (let c = 0; c < boardSize; c++) {
        let matchLen = 1;
        for (let r = 1; r < boardSize; r++) {
          const curr = board[r][c];
          const prev = board[r-1][c];
          if (curr && prev && sameType(curr, prev)) {
            matchLen++;
          } else {
            if (matchLen >= 3) {
              for (let k = 0; k < matchLen; k++) {
                toRemove.push({ r: r-1-k, c });
              }
            }
            matchLen = 1;
          }
        }
        if (matchLen >= 3) {
          for (let k = 0; k < matchLen; k++) {
            toRemove.push({ r: boardSize-1-k, c });
          }
        }
      }
      return toRemove;
    }
    function sameType(a, b) {
      return a.shape === b.shape && a.color === b.color;
    }

    function removeAllMatches(forceImmediate) {
      const matches = findMatches();
      if (!matches.length) {
        comboCount = 0;
        // Проверяем, есть ли вообще ходы
        if (!hasAnyMoves()) {
          shuffleBoard();
        }
        return;
      }
      comboCount = comboCount === 0 ? 1 : comboCount + 1;
      const points = matches.length * POINTS_PER_PIECE * comboCount;
      scoreThisSession += points;

      if (forceImmediate) {
        for (let m of matches) {
          board[m.r][m.c] = null;
        }
        makePiecesFall();
        removeAllMatches(true);
        return;
      }

      for (let m of matches) {
        const piece = board[m.r][m.c];
        if (piece) {
          piece.removing = true;
          spawnParticles(piece, m.r, m.c);
        }
      }
      setTimeout(() => {
        makePiecesFall();
        setTimeout(() => {
          removeAllMatches(false);
        }, 300);
      }, 300);
    }

    function hasAnyMoves() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (c+1 < boardSize) {
            swapPieces(r, c, r, c+1);
            if (findMatches().length) {
              swapPieces(r, c, r, c+1);
              return true;
            }
            swapPieces(r, c, r, c+1);
          }
          if (r+1 < boardSize) {
            swapPieces(r, c, r+1, c);
            if (findMatches().length) {
              swapPieces(r, c, r+1, c);
              return true;
            }
            swapPieces(r, c, r+1, c);
          }
        }
      }
      return false;
    }

    function makePiecesFall() {
      for (let c = 0; c < boardSize; c++) {
        let writeRow = boardSize - 1;
        for (let r = boardSize - 1; r >= 0; r--) {
          if (board[r][c]) {
            if (r !== writeRow) {
              board[r][c].falling = writeRow;
            }
            board[writeRow][c] = board[r][c];
            writeRow--;
          }
        }
        for (let r = writeRow; r >= 0; r--) {
          const newPiece = getRandomPiece();
          newPiece.x = c;
          newPiece.y = r - boardSize;
          newPiece.falling = r;
          newPiece.scale = 1;
          newPiece.alpha = 1;
          board[r][c] = newPiece;
        }
      }
    }

    function shuffleBoard() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c]) {
            board[r][c].removing = true;
          }
        }
      }
      setTimeout(() => {
        let allPieces = [];
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (board[r][c]) {
              allPieces.push(board[r][c]);
            }
            board[r][c] = null;
          }
        }
        // Перемешиваем
        for (let i = allPieces.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allPieces[i], allPieces[j]] = [allPieces[j], allPieces[i]];
        }
        let idx = 0;
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (idx < allPieces.length) {
              let p = allPieces[idx++];
              p.removing = false;
              p.scale = 0.1;
              p.alpha = 0.1;
              p.x = c;
              p.y = r;
              board[r][c] = p;
            } else {
              const np = getRandomPiece();
              np.x = c;
              np.y = r;
              np.scale = 0.1;
              np.alpha = 0.1;
              board[r][c] = np;
            }
          }
        }
        setTimeout(() => {
          for (let r = 0; r < boardSize; r++) {
            for (let c = 0; c < boardSize; c++) {
              const p = board[r][c];
              if (p) {
                p.removing = false;
              }
            }
          }
        }, 200);
      }, 300);
    }

    // Частицы
    function spawnParticles(piece, r, c) {
      const px = c * cellSize + cellSize/2;
      const py = r * cellSize + cellSize/2;
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: px, y: py,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          alpha: 1,
          color: piece.color
        });
      }
    }
    function drawParticles() {
      for (let p of particles) {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, 2*Math.PI);
        ctx.fill();
        ctx.restore();

        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.03;
      }
      particles = particles.filter(p => p.alpha > 0);
    }

    // Конец игры
    function gameOverActions() {
      isGameRunning = false;
      cancelAnimationFrame(animationId);
      gameCanvas.removeEventListener("mousedown", onCanvasClick);
      gameCanvas.removeEventListener("touchstart", onCanvasTouch);

      // Начислим монеты
      currentCoins += scoreThisSession;
      updateUserInDB();
    }
    function endGameAndReturn() {
      if (isGameRunning) {
        isGameRunning = false;
        cancelAnimationFrame(animationId);
        gameCanvas.removeEventListener("mousedown", onCanvasClick);
        gameCanvas.removeEventListener("touchstart", onCanvasTouch);
        currentCoins += scoreThisSession;
        updateUserInDB();
      }
      gameContainer.style.display = "none";
      displayMainMenu();
    }

    // Модальные окна
    function openModal(modal) {
      modal.style.display = "flex";
    }
    function closeModal(modal) {
      modal.style.display = "none";
    }
    function openLoseModal() {
      openModal(loseModal);
    }

    if (winModalClose) {
      winModalClose.addEventListener("click", () => closeModal(winModal));
    }
    if (takePrizeBtn) {
      takePrizeBtn.addEventListener("click", () => {
        closeModal(winModal);
        endGameAndReturn();
      });
    }
    loseModalClose.addEventListener("click", () => closeModal(loseModal));
    tryAgainBtn.addEventListener("click", () => {
      closeModal(loseModal);
      endGameAndReturn();
    });
    fortuneCloseBtn.addEventListener("click", () => {
      closeModal(fortuneModal);
    });

    // Колесо Фортуны
    const ticketsMap = [1, 2, 3, 4, 5]; // пример
    let isSpinning = false;
    spinWheelBtn.addEventListener("click", spinWheel);

    async function spinWheel() {
      if (isSpinning) return;
      isSpinning = true;
      spinResultMsg.textContent = "";

      // Фиксируем время
      lastSpinTime = Date.now();
      await updateUserInDB(); // сразу блокируем повтор

      const wheel = document.getElementById("fortuneWheel");
      const randomAngle = 360 * 5 + Math.floor(Math.random() * 360); 
      wheel.style.transition = "transform 4s cubic-bezier(0.33, 1, 0.68, 1)";
      wheel.style.transform = `rotate(${randomAngle}deg)`;

      setTimeout(() => {
        const normalizedAngle = randomAngle % 360;
        const sectorCount = 5;
        const sectorAngle = 360 / sectorCount;
        const sector = Math.floor(normalizedAngle / sectorAngle);
        const wonTickets = ticketsMap[(sectorCount - sector) % sectorCount];

        spinResultMsg.textContent = `Вы выиграли ${wonTickets} билет(ов)!`;
        currentTickets += wonTickets;
        updateUserInDB();

        setTimeout(() => {
          wheel.style.transition = "none";
          wheel.style.transform = "rotate(0deg)";
          isSpinning = false;
          closeModal(fortuneModal);
          // Обновим главную кнопку (чтобы показал таймер)
          updateFortuneButton();
        }, 600);
      }, 4200);
    }

    // Сохранение в БД
    async function updateUserInDB() {
      if (!currentUsername) return;
      const userRef = ref(db, `users/${currentUsername}`);
      await update(userRef, {
        coins: currentCoins,
        tickets: currentTickets,
        lastSpinTime,
        inventory
      });
      // Обновим текст
      coinsDisplay.textContent = `Монет: ${currentCoins}`;
      ticketsDisplay.textContent = `Билетов: ${currentTickets}`;
    }
  </script>
</body>
</html>


