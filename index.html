<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <!-- Viewport для мобильных устройств -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Minimal Online Fighter</title>
  <style>
    /* Общие стили */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      overflow-x: hidden;
    }
    /* Верхний бар – виден только в лобби */
    #topBar {
      background: #222;
      padding: 10px;
      text-align: center;
    }
    #topBar span { margin: 0 10px; font-size: 16px; }
    /* Страницы лобби, списка комнат и ожидания */
    main {
      text-align: center;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .game-card {
      display: inline-block;
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      margin: 10px;
      width: 200px;
    }
    .game-card img {
      width: 100%;
      height: auto;
      border-radius: 4px;
    }
    #roomListSection table {
      margin: 0 auto;
      border-collapse: collapse;
      width: 80%;
    }
    #roomListSection th, #roomListSection td {
      border: 1px solid #444;
      padding: 8px;
      text-align: center;
    }
    #waitingRoomSection { display: none; }
    #waitingRoomSection p { font-size: 24px; margin-top: 20px; }
    /* Игровой экран: канвас в центре */
    #gameSection {
      display: none;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000;
    }
    canvas {
      background: #000;
      border: 2px solid #444;
      width: 360px;
      height: 240px;
    }
    /* Модальное окно для ориентации */
    #orientationModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #orientationModal > div {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      font-size: 16px;
    }
    /* Кастомное модальное окно для уведомлений и обратного отсчёта */
    #customModalBackdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #customModal {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 80%;
    }
    #customModal h2 { margin-bottom: 10px; font-size: 20px; }
    #customModal p { font-size: 16px; margin-bottom: 10px; }
    #customModal button {
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      background: #444;
      color: #fff;
      border-radius: 5px;
    }
    /* Mobile Controls */
    /* Левый блок – только кнопка Jump, так как движение влево/вправо отключено */
    #leftControls {
      position: fixed;
      bottom: 40px;
      left: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 2000;
    }
    /* Правый блок – кнопка Shoot */
    #rightControls {
      position: fixed;
      bottom: 40px;
      right: 10px;
      z-index: 2000;
    }
    #leftControls button, #rightControls button {
      padding: 12px 18px;
      font-size: 20px;
      border-radius: 8px;
      background: #444;
      border: none;
      color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
  </style>
  
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <!-- Верхний бар (виден только в лобби) -->
  <header id="topBar">
    <span id="usernameDisplay">User</span>
    <span id="coinDisplay">Coins: 100</span>
    <span id="pointDisplay">Points: 0</span>
  </header>
  
  <!-- Модальное окно для ориентации -->
  <div id="orientationModal">
    <div>
      <p>Для лучшего опыта рекомендуется горизонтальное расположение, но вы можете играть в вертикальном режиме. Нажмите OK для продолжения.</p>
      <button id="orientationOkBtn">OK</button>
    </div>
  </div>
  
  <!-- Кастомное модальное окно -->
  <div id="customModalBackdrop">
    <div id="customModal">
      <h2 id="customModalTitle"></h2>
      <p id="customModalMessage"></p>
      <button id="customModalBtn">OK</button>
    </div>
  </div>
  
  <!-- Лобби -->
  <main id="lobbySection">
    <h1>Список игр</h1>
    <div class="game-card">
      <img src="https://via.placeholder.com/200x150?text=Simple+Shooter" alt="Simple Shooter">
      <p>Simple Shooter</p>
      <button onclick="createRoom()">Создать комнату</button>
      <button onclick="showRoomList()">Присоединиться к комнате</button>
    </div>
  </main>
  
  <!-- Секция списка комнат -->
  <main id="roomListSection">
    <h1>Доступные комнаты</h1>
    <table id="roomsTable">
      <tr>
        <th>ID комнаты</th>
        <th>Создатель</th>
        <th>Статус</th>
        <th>Действие</th>
      </tr>
    </table>
  </main>
  
  <!-- Окно ожидания для хоста -->
  <main id="waitingRoomSection">
    <h1>Ожидание соперника...</h1>
    <p>Пожалуйста, подождите, пока второй игрок подключится.</p>
  </main>
  
  <!-- Игровой экран -->
  <section id="gameSection">
    <canvas id="gameCanvas" width="360" height="240"></canvas>
  </section>
  
  <!-- Mobile Controls: в левом блоке только кнопка Jump, в правом – кнопка Shoot -->
  <div id="leftControls">
    <button id="btnJump">Jump</button>
  </div>
  <div id="rightControls">
    <button id="btnShoot">Shoot</button>
  </div>
  
  <script>
    /********************************************************************
     * 1. Инициализация Firebase, Telegram и определение пользователя
     ********************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyApxp0dHh0TK4nZVfOqloJ92dekjvjey3I",
      authDomain: "meta-glitch.firebaseapp.com",
      projectId: "meta-glitch",
      storageBucket: "meta-glitch.firebasestorage.app",
      messagingSenderId: "186162879710",
      appId: "1:186162879710:web:87975bd09681505be7364f",
      measurementId: "G-1TXVH8MESD"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    // Если запускается через Telegram – используем его данные и полноэкранный режим, иначе создаём тестового пользователя
    let currentUser = {};
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      currentUser = Telegram.WebApp.initDataUnsafe.user;
      if (typeof Telegram.WebApp.requestFullscreen === 'function') {
        Telegram.WebApp.requestFullscreen();
      } else {
        Telegram.WebApp.expand();
      }
    } else {
      let testCount = localStorage.getItem('testUserCount');
      testCount = testCount ? parseInt(testCount) + 1 : 1;
      localStorage.setItem('testUserCount', testCount);
      currentUser = { username: "TestUser" + testCount };
    }
    // Отображаем имя без символа '@'
    document.getElementById('usernameDisplay').textContent = currentUser.username;
    
    // Локальные данные пользователя
    let localUserData = { coins: 100, points: 0 };
    function updateTopBar() {
      document.getElementById('coinDisplay').textContent = "Coins: " + localUserData.coins;
      document.getElementById('pointDisplay').textContent = "Points: " + localUserData.points;
    }
    updateTopBar();
    
    /********************************************************************
     * 2. Логика комнат: создание, список и присоединение
     ********************************************************************/
    let roomID = null;
    let isHost = false;
    let remoteUsername = null;
    
    // Устанавливаем onDisconnect – удаление данных игрока при разрыве соединения
    function setOnDisconnect() {
      db.ref("rooms/" + roomID + "/players/" + currentUser.username)
        .onDisconnect()
        .remove();
    }
    
    function createRoom() {
      const roomRef = db.ref("rooms").push();
      roomID = roomRef.key;
      const roomData = {
        game: "Simple Shooter",
        host: currentUser.username,
        status: "waiting",
        players: {}
      };
      // Хост (local player) управляет fighter1 (левая сторона) – имя выводится как currentUser.username
      roomData.players[currentUser.username] = {
        x: 50,
        y: 320,
        hp: 100, // XP
        bullets: 3,
        onGround: true,
        vy: 0,
        reloadTime: 3000,
        timestamp: Date.now()
      };
      isHost = true;
      roomRef.set(roomData).then(() => {
        setOnDisconnect();
        document.getElementById('lobbySection').style.display = 'none';
        document.getElementById('waitingRoomSection').style.display = 'block';
        roomRef.on("value", snapshot => {
          const data = snapshot.val();
          if (data && data.status === "started") {
            roomRef.off();
            startShooterGame();
          }
        });
      });
    }
    
    function showRoomList() {
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'block';
      const roomsRef = db.ref("rooms").orderByChild("status").equalTo("waiting");
      roomsRef.on("value", snapshot => {
        const roomsData = snapshot.val();
        const table = document.getElementById('roomsTable');
        table.innerHTML = `<tr>
          <th>ID комнаты</th>
          <th>Создатель</th>
          <th>Статус</th>
          <th>Действие</th>
        </tr>`;
        if(roomsData) {
          for(let rID in roomsData) {
            const room = roomsData[rID];
            if(room.host === currentUser.username) continue;
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${rID}</td>
                            <td>${room.host}</td>
                            <td>${room.status}</td>
                            <td><button onclick="joinExistingRoom('${rID}')">Присоединиться</button></td>`;
            table.appendChild(tr);
          }
        } else {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td colspan="4">Нет доступных комнат</td>`;
          table.appendChild(tr);
        }
      });
    }
    
    function joinExistingRoom(rID) {
      roomID = rID;
      const roomRef = db.ref("rooms/" + roomID);
      roomRef.once("value").then(snapshot => {
        const room = snapshot.val();
        if(room && room.status === "waiting") {
          roomRef.child("players").child(currentUser.username).set({
            x: 700,  // присоединяющийся игрок управляет fighter2 (правая сторона)
            y: 320,
            hp: 100,
            bullets: 3,
            onGround: true,
            vy: 0,
            reloadTime: 3000,
            timestamp: Date.now()
          }).then(() => {
            setOnDisconnect();
            roomRef.update({ status: "started" }).then(() => {
              roomRef.off();
              isHost = false;
              startShooterGame();
            });
          });
        } else {
          showCustomModal("Ошибка", "Комната недоступна", () => {});
        }
      });
    }
    
    /********************************************************************
     * 3. Проверка ориентации устройства
     ********************************************************************/
    function checkOrientation(callback) {
      if(window.innerWidth < window.innerHeight) {
        document.getElementById('orientationModal').style.display = 'flex';
        document.getElementById('orientationOkBtn').onclick = function() {
          document.getElementById('orientationModal').style.display = 'none';
          callback();
        }
      } else {
        callback();
      }
    }
    
    /********************************************************************
     * 4. Механика игры "Simple Shooter" с онлайн-синхронизацией
     ********************************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // Используем фиксированное положение по Y для бойцов (горизонтальное поле)
    const groundLevel = canvas.height - 100;
    const gravity = 0.5;
    
    // Загружаем изображения бойцов (левый и правый)
    const leftFighterImg = new Image();
    leftFighterImg.src = "https://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/6683c11ff148f10.png";
    const rightFighterImg = new Image();
    rightFighterImg.src = "https://i.pinimg.com/originals/b9/f5/3d/b9f53d6343a55a761968c4f3fb477a17.png";
    
    // Структуры бойцов – игроки не могут двигаться влево/вправо; только прыжок и стрельба
    const fighter1 = {
      x: 50,
      y: groundLevel,
      width: 50,
      height: 80,
      hp: 100,  // XP
      color: 'blue',
      bullets: 3,
      reloadStart: null,
      reloadTime: 3000,
      vy: 0,
      onGround: true
    };
    const fighter2 = {
      x: canvas.width - 100,
      y: groundLevel,
      width: 50,
      height: 80,
      hp: 100,
      color: 'red',
      bullets: 3,
      reloadStart: null,
      reloadTime: 3000,
      vy: 0,
      onGround: true
    };
    
    // Пули: объект, где ключ – id пули, а значение – данные пули
    let bullets = {};
    
    // Обработчики клавиатуры (при необходимости для ПК)
    let keys = {};
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });
    
    // Mobile controls: Отслеживаем состояние кнопок – теперь только Jump и Shoot
    let mobileKeys = { jump: false, shoot: false };
    // Удаляем слушатели для left/right
    document.getElementById("btnJump").addEventListener("touchstart", e => { mobileKeys.jump = true; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("touchend", e => { mobileKeys.jump = false; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("mousedown", () => { mobileKeys.jump = true; });
    document.getElementById("btnJump").addEventListener("mouseup", () => { mobileKeys.jump = false; });
    
    document.getElementById("btnShoot").addEventListener("touchstart", e => { mobileKeys.shoot = true; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("touchend", e => { mobileKeys.shoot = false; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("mousedown", () => { mobileKeys.shoot = true; });
    document.getElementById("btnShoot").addEventListener("mouseup", () => { mobileKeys.shoot = false; });
    
    // Функции для определения локального и удалённого бойца
    function getLocalFighter() {
      return isHost ? fighter1 : fighter2;
    }
    function getRemoteFighter() {
      return isHost ? fighter2 : fighter1;
    }
    
    // Добавляем базовую интерполяцию для удалённого бойца
    let remoteTargetX = null, remoteTargetY = null;
    
    // Обновление локального бойца: горизонтальное положение фиксировано, только прыжок и стрельба
    function updateLocalFighter() {
      const localFighter = getLocalFighter();
      // Игрок не может менять x – он фиксирован (50 для host, canvas.width - 100 для не-хоста)
      // Прыжок
      if ((keys['ArrowUp'] || mobileKeys.jump) && localFighter.onGround) {
        localFighter.vy = -12;
        localFighter.onGround = false;
        jumpSound.play();
      }
      if (!localFighter.onGround) {
        localFighter.vy += gravity;
        localFighter.y += localFighter.vy;
        if (localFighter.y >= groundLevel) {
          localFighter.y = groundLevel;
          localFighter.vy = 0;
          localFighter.onGround = true;
        }
      }
      // Стрельба: пробел или кнопка Shoot
      if ((keys[' '] || mobileKeys.shoot) && localFighter.bullets > 0) {
        const bulletData = {
          owner: currentUser.username,
          x: (isHost ? localFighter.x + localFighter.width : localFighter.x - 10),
          y: localFighter.y + localFighter.height / 2 - 2,
          vx: (isHost ? 4 : -4),
          width: 10,
          height: 4,
          timestamp: Date.now()
        };
        db.ref("rooms/" + roomID + "/bullets").push(bulletData);
        localFighter.bullets--;
        playShotSound();
        if(localFighter.bullets === 0) {
          localFighter.reloadStart = Date.now();
        }
        mobileKeys.shoot = false;
        keys[' '] = false;
      }
      if(localFighter.bullets === 0 && localFighter.reloadStart) {
        if(Date.now() - localFighter.reloadStart >= localFighter.reloadTime) {
          localFighter.bullets = 3;
          localFighter.reloadStart = null;
        }
      }
    }
    
    // Обновление пуль: пуля двигается до самого края, удаляется при выходе, и если попала – исчезает
    function updateBullets() {
      for (let id in bullets) {
        const b = bullets[id];
        b.x += b.vx;
        if(b.x + b.width < 0 || b.x > canvas.width) {
          deleteBullet(id);
          continue;
        }
        if(b.owner !== currentUser.username && isColliding(b, getLocalFighter())) {
          getLocalFighter().hp = Math.max(0, getLocalFighter().hp - 10);
          playHitSound();
          deleteBullet(id);
        }
      }
    }
    
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    
    function deleteBullet(id) {
      db.ref("rooms/" + roomID + "/bullets/" + id).remove();
      delete bullets[id];
    }
    
    // Слушаем пули из Firebase
    function listenToBullets() {
      const bulletsRef = db.ref("rooms/" + roomID + "/bullets");
      bulletsRef.on("child_added", snapshot => {
        const bullet = snapshot.val();
        bullet.id = snapshot.key;
        bullets[bullet.id] = bullet;
      });
      bulletsRef.on("child_removed", snapshot => {
        const bid = snapshot.key;
        if(bullets[bid]) delete bullets[bid];
      });
    }
    
    // Синхронизация локального состояния бойца в Firebase
    function syncLocalState() {
      const localFighter = getLocalFighter();
      db.ref("rooms/" + roomID + "/players/" + currentUser.username).update({
        x: localFighter.x,
        y: localFighter.y,
        hp: localFighter.hp,
        bullets: localFighter.bullets,
        onGround: localFighter.onGround,
        timestamp: Date.now()
      });
    }
    
    // Слушаем состояние игроков в комнате, и обновляем удалённое положение с интерполяцией
    function listenToPlayers() {
      db.ref("rooms/" + roomID + "/players").on("value", snapshot => {
        const players = snapshot.val();
        for(let uname in players) {
          if(uname !== currentUser.username) {
            remoteUsername = uname;
            const remoteData = players[uname];
            if(isHost) {
              fighter2.hp = remoteData.hp;
              fighter2.bullets = remoteData.bullets;
              fighter2.onGround = remoteData.onGround;
              // Интерполяция: сохраняем целевые координаты
              remoteTargetX = remoteData.x;
              remoteTargetY = remoteData.y;
            } else {
              fighter1.hp = remoteData.hp;
              fighter1.bullets = remoteData.bullets;
              fighter1.onGround = remoteData.onGround;
              remoteTargetX = remoteData.x;
              remoteTargetY = remoteData.y;
            }
          }
        }
      });
    }
    
    // Обновляем удалённого игрока (например, при попадании)
    function updateRemotePlayer(username, fighterState) {
      if(username) {
        db.ref("rooms/" + roomID + "/players/" + username).update({
          hp: fighterState.hp
        });
      }
    }
    
    // Рендер игрового поля: отрисовка бойцов, пуль, отображение юзернеймов, XP и пуль
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Рисуем левого бойца (fighter1) с изображением
      if(leftFighterImg.complete) {
        ctx.drawImage(leftFighterImg, fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      } else {
        ctx.fillStyle = fighter1.color;
        ctx.fillRect(fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      }
      // Рисуем правого бойца (fighter2)
      if(rightFighterImg.complete) {
        ctx.drawImage(rightFighterImg, fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      } else {
        ctx.fillStyle = fighter2.color;
        ctx.fillRect(fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      }
      // Рисуем пули
      ctx.fillStyle = "#fff";
      for (let id in bullets) {
        const b = bullets[id];
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      // Отрисовка юзернеймов и XP над бойцами и количества пуль под ними
      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      if(isHost) {
        ctx.fillText(currentUser.username, fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
        
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
      } else {
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
        
        ctx.fillText(currentUser.username, fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
      }
      // Если местный игрок перезаряжается, показываем текст "Reloading..."
      const localFighter = getLocalFighter();
      if(localFighter.bullets === 0) {
        ctx.fillStyle = "#ff0";
        ctx.fillText("Reloading...", localFighter.x, localFighter.y - 40);
      }
    }
    
    // Перемещение удалённого бойца с базовой интерполяцией
    function interpolateRemote() {
      if(remoteTargetX !== null) {
        let remoteFighter = getRemoteFighter();
        remoteFighter.x += (remoteTargetX - remoteFighter.x) * 0.1;
        remoteFighter.y += (remoteTargetY - remoteFighter.y) * 0.1;
      }
    }
    
    // Игровой цикл
    let gameLoopId;
    function gameLoop() {
      updateLocalFighter();
      syncLocalState();
      updateBullets();
      interpolateRemote();
      renderGame();
      
      // Завершаем игру, если у любого игрока XP (hp) ≤ 0
      const localHP = getLocalFighter().hp;
      const remoteHP = getRemoteFighter().hp;
      if(localHP <= 0 || remoteHP <= 0) {
        let result = (localHP > 0) ? "Вы выиграли!" : "Вы проиграли!";
        // Если у удалённого игрока осталось >0, но на нашем клиенте его уже 0, принудительно устанавливаем 0
        if(remoteHP <= 0) {
          getRemoteFighter().hp = 0;
        }
        updateStats(result);
        playGameOverSound();
        showGameOverCountdown(result);
        if(isHost) {
          db.ref("rooms/" + roomID).remove();
        }
        cancelAnimationFrame(gameLoopId);
        return;
      }
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Запуск игры: скрываем лобби, список, ожидание; отображаем игровое поле и блокируем прокрутку
    function startShooterGame() {
      document.getElementById('waitingRoomSection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'none';
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('gameSection').style.display = 'flex';
      document.getElementById('topBar').style.display = 'none';
      document.body.style.overflow = 'hidden';
      listenToPlayers();
      listenToBullets();
      checkOrientation(initShooterGame);
      document.getElementById('gameSection').addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
    }
    
    function initShooterGame() {
      const localFighter = getLocalFighter();
      if(isHost) {
        fighter1.x = 50; fighter1.y = groundLevel; fighter1.hp = 100;
        fighter1.bullets = 3; fighter1.vy = 0; fighter1.onGround = true;
      } else {
        fighter2.x = canvas.width - 100; fighter2.y = groundLevel; fighter2.hp = 100;
        fighter2.bullets = 3; fighter2.vy = 0; fighter2.onGround = true;
      }
      bullets = {};
      gameLoop();
    }
    
    /********************************************************************
     * 5. Кастомное глобальное модальное окно для уведомлений
     ********************************************************************/
    function showCustomModal(title, message, callback) {
      document.getElementById('customModalTitle').innerText = title;
      document.getElementById('customModalMessage').innerText = message;
      document.getElementById('customModalBackdrop').style.display = 'flex';
      document.getElementById('customModalBtn').onclick = function() {
        document.getElementById('customModalBackdrop').style.display = 'none';
        if(callback) callback();
      };
    }
    
    function showGameOverCountdown(result) {
      let countdown = 5;
      showCustomModal("Game Over", "Результат: " + result + "\nВозвращение в лобби через " + countdown + " секунд", () => {});
      const intervalId = setInterval(() => {
        countdown--;
        document.getElementById('customModalMessage').innerText = "Результат: " + result + "\nВозвращение в лобби через " + countdown + " секунд";
        if (countdown <= 0) {
          clearInterval(intervalId);
          document.getElementById('gameSection').style.display = 'none';
          document.getElementById('lobbySection').style.display = 'block';
          document.getElementById('topBar').style.display = 'block';
          document.body.style.overflow = 'auto';
        }
      }, 1000);
    }
    
    /********************************************************************
     * 6. Статистика игр: сохранение результатов дуэлей в Firebase
     ********************************************************************/
    function updateStats(result) {
      const statsRef = db.ref("stats/" + currentUser.username);
      statsRef.once("value").then(snapshot => {
        let stats = snapshot.val() || { wins: 0, losses: 0, points: 0 };
        if(result === "Вы выиграли!") {
          stats.wins++;
        } else {
          stats.losses++;
        }
        stats.points += localUserData.points;
        statsRef.set(stats);
      });
    }
    
    /********************************************************************
     * 7. Дополнительные улучшения:
     *    1. Звуковые эффекты: добавлены звуки прыжка, выстрела, попадания и окончания игры.
     *    2. Визуальное сообщение о перезарядке: "Reloading..." отображается над игроком, если пуль нет.
     *    3. Hit flash: при попадании на игрока накладывается красный полупрозрачный слой (можно расширить, здесь базовая реализация через звук).
     *    4. Интерполяция удалённого состояния: удалённый игрок плавно перемещается к целевым координатам.
     *    5. Полноэкранный режим: запрашивается автоматически при запуске через Telegram.
     ********************************************************************/
    // Звуковые эффекты
    const jumpSound = new Audio("https://actions.google.com/sounds/v1/cartoon/boing.ogg");
    const shotSound = new Audio("https://actions.google.com/sounds/v1/weapons/laser_short.ogg");
    const hitSound = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    const gameOverSound = new Audio("https://actions.google.com/sounds/v1/alarms/medium_bell_ringing.ogg");
    
    function playShotSound() {
      shotSound.currentTime = 0;
      shotSound.play();
    }
    function playJumpSound() {
      jumpSound.currentTime = 0;
      jumpSound.play();
    }
    function playHitSound() {
      hitSound.currentTime = 0;
      hitSound.play();
    }
    function playGameOverSound() {
      gameOverSound.currentTime = 0;
      gameOverSound.play();
    }
    
    /********************************************************************
     * 8. Блокировка жестов: запрещаем touchmove, чтобы исключить масштабирование
     ********************************************************************/
    document.addEventListener('touchmove', function(event) {
      if(document.getElementById('gameSection').style.display === 'flex') {
        event.preventDefault();
      }
    }, { passive: false });
  </script>
</body>
</html>
