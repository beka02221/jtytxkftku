<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Игра "Три в ряд" + Магазин + Колесо фортуны</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <!-- Подключаем Telegram Web App JS -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden; 
      overflow-y: auto;
      background: #46257D; 
      font-family: 'Courier Prime', monospace;
      color: #39FF14;
    }

    /* Главное меню */
    #mainMenu {
      min-height: 100vh;
      width: 100%;
      display: none; /* скрываем, пока не загрузим пользователя */
      box-sizing: border-box;
      background: linear-gradient(135deg, #4F308F, #46257D);
      text-align: center;
      padding: 40px 20px;
    }
    #mainMenu h2 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #39FF14;
      text-shadow: 0 0 4px #00FF00;
      font-size: 20px;
    }
    #mainMenu p {
      margin: 8px 0;
      font-size: 14px;
      color: #ADFF2F;
    }
    #mainMenu button {
      display: block;
      margin: 10px auto;
      padding: 12px 24px;
      font-size: 14px;
      cursor: pointer;
      border: 2px solid #39FF14;
      background: #1E3C87; 
      color: #ffffff;
      border-radius: 8px;
      width: 90%;
      max-width: 300px;
      transition: all 0.2s ease-in-out;
      text-transform: uppercase;
    }
    #mainMenu button:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Таблица лидеров, Магазин, Инфо */
    #leaderboardContainer,
    #storeContainer,
    #infoContainer {
      min-height: 100vh;
      width: 100%;
      display: none;
      box-sizing: border-box;
      background: linear-gradient(135deg, #4F308F, #46257D);
      text-align: center;
      padding: 40px 20px;
    }
    #leaderboardContainer h2,
    #storeContainer h2,
    #infoContainer h2 {
      margin-top: 0;
      color: #39FF14;
      text-shadow: 0 0 4px #00FF00;
      font-size: 20px;
    }
    table {
      border-collapse: collapse;
      margin: 20px auto;
      width: 90%;
      max-width: 600px;
    }
    th, td {
      border: 1px solid #39FF14;
      padding: 10px 12px;
      text-align: left;
      font-size: 14px;
      color: #ADFF2F;
      background: #5B3E9E;
    }
    th {
      background: #6F4CBE;
      color: #ffffff;
    }

    /* Игровой экран */
    #gameContainer {
      min-height: 100vh;
      width: 100%;
      display: none;
      box-sizing: border-box;
      background: #46257D;

      /* Flex-раскладка для удобного центрирования */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 20px;
      padding-bottom: 20px;
    }

    /* Кнопка назад из игры */
    #backToMenuBtn {
      margin-bottom: 10px;
      cursor: pointer;
      background: #1E3C87;
      border: 2px solid #39FF14;
      color: #ffffff;
      font-size: 12px;
      text-transform: uppercase;
      border-radius: 6px;
      transition: all 0.2s ease-in-out;
      padding: 10px 16px;
    }
    #backToMenuBtn:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Верхняя панель (очки и время) */
    #topPanel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 50px;
      margin-bottom: 10px;
    }
    #scoreDisplay, #timeDisplay {
      font-size: 16px;
      text-shadow: 0 0 4px #00FF00;
    }

    /* Сам canvas */
    #gameCanvas {
      background-color: #3C266C;
      box-shadow: 0 0 10px rgba(57,255,20,0.4);

      /* Чтобы по центру на мобильном */
      display: block;
      margin: 0 auto;
      max-width: 100%;
      height: auto;
    }

    /* Панель внизу для использования предметов */
    #itemPanel {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center; 
    }
    #itemPanel button {
      background: #FF7F50;
      border: 2px solid #FFD700;
      color: #FFF;
      cursor: pointer;
      padding: 8px 16px;
      border-radius: 6px;
      text-transform: uppercase;
      transition: 0.2s;
    }
    #itemPanel button:hover {
      transform: scale(1.05);
      background: #FFA07A;
    }

    /* "Призраки" для Drag&Drop бомб */
    .drag-ghost {
      position: fixed;
      z-index: 9999;
      width: 40px;
      height: 40px;
      pointer-events: none;
      display: none;
      border-radius: 50%;
      text-align: center;
      line-height: 40px;
      font-weight: bold;
      font-size: 16px;
      background-color: rgba(255,0,0,0.8);
      color: #FFF;
    }
    #lineBombGhost {
      background-color: rgba(255,165,0,0.8);
    }

    /* Модальные окна общего вида (для сообщений) */
    .modalOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      padding: 20px;
      box-sizing: border-box;
    }
    .modalContent {
      background: #4F308F;
      padding: 20px;
      border: 2px solid #39FF14;
      border-radius: 8px;
      text-align: center;
      position: relative;
      max-width: 400px;
      width: 100%;
      color: #39FF14;
      font-size: 14px;
      box-shadow: 0 0 12px rgba(57,255,20,0.4);
    }
    .modalContent h2 {
      margin-top: 0;
      font-size: 16px;
      text-shadow: 0 0 4px #00FF00;
    }
    .closeBtn {
      position: absolute;
      top: 10px;
      right: 15px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    }
    .modalContent button {
      background: #1E3C87;
      color: #ffffff;
      border: 2px solid #39FF14;
      cursor: pointer;
      padding: 10px 16px;
      font-size: 12px;
      text-transform: uppercase;
      border-radius: 6px;
      transition: all 0.2s ease-in-out;
    }
    .modalContent button:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Отдельные модалки Победа / Проигрыш / Колесо */
    #winModal .modalContent {
      background: linear-gradient(135deg, #6233AE, #5E2B95);
      color: #39FF14;
      animation: flash 1.5s infinite alternate;
    }
    @keyframes flash {
      0% { box-shadow: 0 0 20px rgba(57,255,20,0.6); }
      100% { box-shadow: 0 0 0 rgba(57,255,20,0); }
    }
    #loseModal .modalContent {
      background: #2F1A4F;
      color: #39FF14;
    }

    /* Окно «Колесо фортуны» */
    #fortuneModal .modalContent {
      background: linear-gradient(135deg, #472874, #46257D);
      color: #39FF14;
      border: 3px dashed #39FF14;
    }
    .wheelContainer {
      position: relative;
      width: 320px;
      height: 320px;
      margin: 0 auto;
    }
    #fortuneWheel {
      width: 320px;
      height: 320px;
      border-radius: 50%;
      border: 4px solid #39FF14;
      position: relative;
      overflow: hidden;
      transform: rotate(0deg);
      transition: transform 4s cubic-bezier(0.33, 1, 0.68, 1);
      box-shadow: 0 0 15px #39FF14, inset 0 0 15px #39FF14;
      background: radial-gradient(circle, #46257D 20%, #2F1A4F 80%);
    }
    .section {
      width: 50%;
      height: 50%;
      position: absolute;
      transform-origin: 100% 100%;
      border: 1px dashed #39FF14;
    }
    .pointer {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-bottom: 30px solid #39FF14;
      z-index: 10;
      filter: drop-shadow(0 0 5px #39FF14);
    }
    #spinResultMsg {
      margin-top: 10px;
      font-weight: bold;
      font-size: 14px;
    }
    #spinWheelBtn {
      margin-top: 15px;
      background: #1E3C87;
      font-size: 12px;
      padding: 10px 20px;
      border-radius: 8px;
      text-transform: uppercase;
      color: #ffffff;
      border: 2px solid #39FF14;
      transition: all 0.2s ease-in-out;
    }
    #spinWheelBtn:hover {
      background: #2F53B2;
      transform: scale(1.05);
    }

    /* Модальное окно для сообщений (замена alert) */
    #messageModal .modalContent {
      background: #3E1F66;
      color: #ADFF2F;
      border: 2px solid #39FF14;
    }

    /* Адаптивность */
    @media (max-width: 480px) {
      #mainMenu h2,
      #leaderboardContainer h2,
      #storeContainer h2,
      #infoContainer h2 {
        font-size: 16px;
      }
      #mainMenu button,
      .modalContent button {
        font-size: 12px;
        padding: 10px 16px;
      }
      .wheelContainer {
        width: 260px;
        height: 260px;
      }
      #fortuneWheel {
        width: 260px;
        height: 260px;
      }
      .pointer {
        top: -24px;
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-bottom: 24px solid #39FF14;
      }
      #topPanel {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Главное меню -->
  <div id="mainMenu">
    <h2>Добро пожаловать в "Три в ряд"!</h2>
    <p id="userDisplay"></p>
    <p id="coinsDisplay"></p>
    <p id="ticketsDisplay"></p>

    <!-- Кнопка или таймер колеса фортуны -->
    <button id="openFortuneModalBtn">Крутить колесо фортуны</button>

    <button id="startGameBtn">Начать игру</button>
    <button id="leaderboardBtn">Таблица лидеров</button>
    <button id="storeBtn">Магазин улучшений</button>
    <button id="infoBtn">Информация</button>
    <button id="logoutBtn">Выйти</button>
  </div>

  <!-- Игровой экран -->
  <div id="gameContainer">
    <button id="backToMenuBtn">Выйти в меню</button>

    <!-- Верхняя панель с очками и временем -->
    <div id="topPanel">
      <div id="scoreDisplay">Очки: 0</div>
      <div id="timeDisplay">Время: 2:00</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Панель предметов внизу (если user их купил) -->
    <div id="itemPanel">
      <!-- +20 сек -->
      <button id="useExtraTimeBtn" style="display:none">
        +20 секунд (<span id="extraTimeCount">0</span>)
      </button>
      <!-- Бомба (3x3) - теперь drag&drop -->
      <button id="bombDragBtn" style="display:none">
        Бомба (<span id="bombCount">0</span>)
      </button>
      <!-- «Линейная бомба» -->
      <button id="lineBombDragBtn" style="display:none">
        Лин. бомба (<span id="lineBombCount">0</span>)
      </button>
      <!-- Подсказка -->
      <button id="useHintBtn" style="display:none">
        Подсказка (<span id="hintCount">0</span>)
      </button>
    </div>
  </div>

  <!-- "Призрак" для бомбы и линейной бомбы -->
  <div id="bombGhost" class="drag-ghost">B</div>
  <div id="lineBombGhost" class="drag-ghost">L</div>

  <!-- Таблица лидеров -->
  <div id="leaderboardContainer">
    <h2>Таблица лидеров</h2>
    <table>
      <thead>
        <tr>
          <th>Пользователь</th>
          <th>Монет</th>
        </tr>
      </thead>
      <tbody id="leaderboardBody"></tbody>
    </table>
    <br />
    <button id="leaderboardBackBtn">Назад</button>
  </div>

  <!-- Магазин -->
  <div id="storeContainer">
    <h2>Магазин улучшений</h2>
    <p>Здесь можно приобрести различные бонусы за монеты.</p>
    
    <div style="margin-top:20px;">
      <h3>+20 секунд к таймеру</h3>
      <p>Цена: <b>50</b> монет</p>
      <button id="buyExtraTimeBtn">Купить</button>
    </div>

    <div style="margin-top:20px;">
      <h3>Бомба (3×3)</h3>
      <p>Цена: <b>100</b> монет</p>
      <button id="buyBombBtn">Купить</button>
    </div>

    <div style="margin-top:20px;">
      <h3>Линейная бомба</h3>
      <p>Цена: <b>120</b> монет</p>
      <button id="buyLineBombBtn">Купить</button>
    </div>

    <div style="margin-top:20px;">
      <h3>Подсказка (разовый бонус)</h3>
      <p>Цена: <b>60</b> монет</p>
      <button id="buyHintBtn">Купить</button>
    </div>

    <br/>
    <button id="storeBackBtn">Назад</button>
  </div>

  <!-- Информация -->
  <div id="infoContainer">
    <h2>Информация об игре "Три в ряд"</h2>
    <p>
      Цель игры: составлять ряды из трёх и более одинаковых фигур, набирая как можно больше очков.<br>
      Если ходов нет — поле перетасовывается. Игра длится 2 минуты (можно купить +20 секунд).<br>
      «Бомба» убирает фигуры в радиусе 3×3 от выбранной ячейки.<br>
      «Линейная бомба» убирает целый ряд.<br>
      «Подсказка» подсвечивает один возможный ход.
    </p>
    <button id="infoBackBtn">Назад</button>
  </div>

  <!-- =================== МОДАЛЬНЫЕ ОКНА =================== -->
  <!-- Окно для кратких сообщений (замена alert) -->
  <div id="messageModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="messageModalClose">&times;</span>
      <h2 id="messageModalTitle">Сообщение</h2>
      <p id="messageModalText"></p>
      <button id="messageModalOkBtn">OK</button>
    </div>
  </div>

  <!-- Окно "Победа" (если нужно) -->
  <div id="winModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="winModalClose">&times;</span>
      <h2>Поздравляем, вы выиграли!</h2>
      <p>Здесь может быть фейерверк или другая анимация.</p>
      <button id="takePrizeBtn">Забрать приз</button>
    </div>
  </div>

  <!-- Окно "Проигрыш" -->
  <div id="loseModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="loseModalClose">&times;</span>
      <h2>Время вышло!</h2>
      <p>Игра окончена. Попробуйте ещё раз!</p>
      <button id="tryAgainBtn">Ок</button>
    </div>
  </div>

  <!-- Окно Колеса фортуны -->
  <div id="fortuneModal" class="modalOverlay">
    <div class="modalContent">
      <span class="closeBtn" id="fortuneCloseBtn">&times;</span>
      <h2>Колесо Фортуны (1 раз в 24 часа)</h2>
      <div class="wheelContainer">
        <div class="pointer"></div>
        <div id="fortuneWheel">
          <!-- 5 «секторов» (пример) -->
          <div class="section"></div>
          <div class="section"></div>
          <div class="section"></div>
          <div class="section"></div>
          <div class="section"></div>
        </div>
      </div>
      <br>
      <button id="spinWheelBtn">Крутить колесо</button>
      <p id="spinResultMsg"></p>
    </div>
  </div>

  <!-- Подключение Firebase и основная логика -->
  <script type="module">
    // === ИМПОРТ FIREBASE ===
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { 
      getDatabase, 
      ref, 
      get, 
      set, 
      update
    } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";

    // === КОНФИГУРАЦИЯ FIREBASE ===
    const firebaseConfig = {
      apiKey: "AIzaSyB...",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    // Инициализация Firebase
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Telegram WebApp
    const tg = window.Telegram.WebApp;
    tg.expand(); // Разворачиваем

    // DOM-элементы
    const mainMenu = document.getElementById("mainMenu");
    const userDisplay = document.getElementById("userDisplay");
    const coinsDisplay = document.getElementById("coinsDisplay");
    const ticketsDisplay = document.getElementById("ticketsDisplay");
    const openFortuneModalBtn = document.getElementById("openFortuneModalBtn");
    const startGameBtn = document.getElementById("startGameBtn");
    const leaderboardBtn = document.getElementById("leaderboardBtn");
    const storeBtn = document.getElementById("storeBtn");
    const infoBtn = document.getElementById("infoBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    // Модалки
    const fortuneModal = document.getElementById("fortuneModal");
    const fortuneCloseBtn = document.getElementById("fortuneCloseBtn");
    const spinWheelBtn = document.getElementById("spinWheelBtn");
    const spinResultMsg = document.getElementById("spinResultMsg");

    const winModal = document.getElementById("winModal");
    const winModalClose = document.getElementById("winModalClose");
    const takePrizeBtn = document.getElementById("takePrizeBtn");
    const loseModal = document.getElementById("loseModal");
    const loseModalClose = document.getElementById("loseModalClose");
    const tryAgainBtn = document.getElementById("tryAgainBtn");

    // Лидерборд
    const leaderboardContainer = document.getElementById("leaderboardContainer");
    const leaderboardBody = document.getElementById("leaderboardBody");
    const leaderboardBackBtn = document.getElementById("leaderboardBackBtn");

    // Магазин
    const storeContainer = document.getElementById("storeContainer");
    const storeBackBtn = document.getElementById("storeBackBtn");
    const buyExtraTimeBtn = document.getElementById("buyExtraTimeBtn");
    const buyBombBtn = document.getElementById("buyBombBtn");
    const buyLineBombBtn = document.getElementById("buyLineBombBtn");
    const buyHintBtn = document.getElementById("buyHintBtn");

    // Инфо
    const infoContainer = document.getElementById("infoContainer");
    const infoBackBtn = document.getElementById("infoBackBtn");

    // Игра
    const gameContainer = document.getElementById("gameContainer");
    const backToMenuBtn = document.getElementById("backToMenuBtn");
    const gameCanvas = document.getElementById("gameCanvas");
    let ctx;

    // Верхняя панель
    const scoreDisplay = document.getElementById("scoreDisplay");
    const timeDisplay = document.getElementById("timeDisplay");

    // Панель предметов
    const itemPanel = document.getElementById("itemPanel");
    const useExtraTimeBtn = document.getElementById("useExtraTimeBtn");
    const extraTimeCountSpan = document.getElementById("extraTimeCount");
    const bombDragBtn = document.getElementById("bombDragBtn");
    const bombCountSpan = document.getElementById("bombCount");
    const lineBombDragBtn = document.getElementById("lineBombDragBtn");
    const lineBombCountSpan = document.getElementById("lineBombCount");
    const useHintBtn = document.getElementById("useHintBtn");
    const hintCountSpan = document.getElementById("hintCount");

    // "Призраки" для Drag&Drop
    const bombGhost = document.getElementById("bombGhost");
    const lineBombGhost = document.getElementById("lineBombGhost");

    // Модальное окно для сообщений
    const messageModal = document.getElementById("messageModal");
    const messageModalClose = document.getElementById("messageModalClose");
    const messageModalOkBtn = document.getElementById("messageModalOkBtn");
    const messageModalTitle = document.getElementById("messageModalTitle");
    const messageModalText = document.getElementById("messageModalText");

    // Глобальные переменные
    let currentUsername = null;
    let currentCoins = 0;
    let currentTickets = 0;
    let lastSpinTime = 0;
    let inventory = {
      extraTime: 0,
      bombs: 0,
      lineBombs: 0,
      hints: 0
    };

    // Игра "Три в ряд"
    let isGameRunning = false;
    let animationId;
    const boardSize = 8;
    let board = [];
    let cellSize = 80;
    let selectedCell = null;
    let scoreThisSession = 0;
    let comboCount = 0;
    let gameStartTime = 0;
    const BASE_GAME_TIME_LIMIT = 2 * 60 * 1000; // 2 минуты
    let currentGameTimeLimit = BASE_GAME_TIME_LIMIT;

    const shapes = [
      { shape: "circle", color: "#FF6B6B" },
      { shape: "square", color: "#4ECDC4" },
      { shape: "triangle", color: "#FFD93D" },
      { shape: "hexagon", color: "#FF9F1C" },
      { shape: "star", color: "#9B5DE5" }
    ];
    let particles = [];
    const POINTS_PER_PIECE = 2;

    // Drag&Drop состояния
    let draggingBomb = false;
    let draggingLineBomb = false;

    // Подсветка подсказки
    let hintCells = null;
    let hintTimer = null;

    // Инициализация
    window.addEventListener("DOMContentLoaded", async () => {
      const initDataUnsafe = tg.initDataUnsafe;
      const user = initDataUnsafe?.user;
      if (!user) {
        showMessageModal("Ошибка", "Не удалось получить данные пользователя из Telegram WebApp.");
        return;
      }
      let telegramUsername = user.username
        ? "@" + user.username.toLowerCase()
        : "@id" + user.id;

      // Автовход
      await autoLogin(telegramUsername);
    });

    async function autoLogin(username) {
      const userRef = ref(db, `users/${username}`);
      const snapshot = await get(userRef);
      if (!snapshot.exists()) {
        // Создадим запись впервые
        await set(userRef, {
          coins: 0,
          tickets: 0,
          lastSpinTime: 0,
          inventory: { extraTime: 0, bombs: 0, lineBombs: 0, hints: 0 }
        });
        currentCoins = 0;
        currentTickets = 0;
        lastSpinTime = 0;
        inventory = { extraTime: 0, bombs: 0, lineBombs: 0, hints: 0 };
      } else {
        const data = snapshot.val();
        currentCoins = data.coins || 0;
        currentTickets = data.tickets || 0;
        lastSpinTime = data.lastSpinTime || 0;
        inventory = data.inventory || { extraTime: 0, bombs: 0, lineBombs: 0, hints: 0 };
      }
      currentUsername = username;
      displayMainMenu();
    }

    // Универсальное модальное сообщение (замена alert)
    function showMessageModal(title, text) {
      messageModalTitle.textContent = title;
      messageModalText.textContent = text;
      messageModal.style.display = "flex";
    }
    function closeMessageModal() {
      messageModal.style.display = "none";
    }
    messageModalClose.addEventListener("click", closeMessageModal);
    messageModalOkBtn.addEventListener("click", closeMessageModal);

    // Отображение главного меню
    function displayMainMenu() {
      mainMenu.style.display = "block";
      gameContainer.style.display = "none";
      leaderboardContainer.style.display = "none";
      storeContainer.style.display = "none";
      infoContainer.style.display = "none";

      userDisplay.textContent = `Игрок: ${currentUsername}`;
      coinsDisplay.textContent = `Монет: ${currentCoins}`;
      ticketsDisplay.textContent = `Билетов: ${currentTickets}`;

      // Проверяем, прошло ли 24 часа
      updateFortuneButton();
    }

    // Обновляем надпись/доступ колеса фортуны
    function updateFortuneButton() {
      const now = Date.now();
      const diff = now - lastSpinTime; 
      const hours = diff / (1000 * 60 * 60);
      if (hours >= 24) {
        // Кнопка разблокирована
        openFortuneModalBtn.disabled = false;
        openFortuneModalBtn.style.opacity = "1";
        openFortuneModalBtn.textContent = "Крутить колесо фортуны";
      } else {
        openFortuneModalBtn.disabled = true;
        openFortuneModalBtn.style.opacity = "0.5";
        // Покажем, через сколько часов/минут
        const hoursLeft = 24 - hours;
        const h = Math.floor(hoursLeft);
        const m = Math.floor((hoursLeft - h) * 60);
        openFortuneModalBtn.textContent = `Колесо (через ${h}ч ${m}м)`;
      }
    }

    // Кнопки главного меню
    openFortuneModalBtn.addEventListener("click", () => {
      if (!openFortuneModalBtn.disabled) {
        openModal(fortuneModal);
        spinResultMsg.textContent = "";
      }
    });

    startGameBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      startGame();
    });

    leaderboardBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      leaderboardContainer.style.display = "block";
      loadLeaderboard();
    });

    storeBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      storeContainer.style.display = "block";
    });

    infoBtn.addEventListener("click", () => {
      mainMenu.style.display = "none";
      infoContainer.style.display = "block";
    });

    logoutBtn.addEventListener("click", () => {
      currentUsername = null;
      currentCoins = 0;
      currentTickets = 0;
      inventory = { extraTime: 0, bombs: 0, lineBombs: 0, hints: 0 };
      mainMenu.style.display = "none";
      showMessageModal("Выход", "Вы вышли из аккаунта. Перезапустите WebApp для повторного входа.");
    });

    // Магазин
    storeBackBtn.addEventListener("click", () => {
      storeContainer.style.display = "none";
      displayMainMenu();
    });
    buyExtraTimeBtn.addEventListener("click", async () => {
      const cost = 50;
      if (currentCoins >= cost) {
        currentCoins -= cost;
        inventory.extraTime = (inventory.extraTime || 0) + 1;
        await updateUserInDB();
        showMessageModal("Покупка", "Куплено +20 секунд!");
      } else {
        showMessageModal("Ошибка", "Недостаточно монет!");
      }
    });
    buyBombBtn.addEventListener("click", async () => {
      const cost = 100;
      if (currentCoins >= cost) {
        currentCoins -= cost;
        inventory.bombs = (inventory.bombs || 0) + 1;
        await updateUserInDB();
        showMessageModal("Покупка", "Куплена Бомба (3x3)!");
      } else {
        showMessageModal("Ошибка", "Недостаточно монет!");
      }
    });
    buyLineBombBtn.addEventListener("click", async () => {
      const cost = 120;
      if (currentCoins >= cost) {
        currentCoins -= cost;
        inventory.lineBombs = (inventory.lineBombs || 0) + 1;
        await updateUserInDB();
        showMessageModal("Покупка", "Куплена Линейная бомба!");
      } else {
        showMessageModal("Ошибка", "Недостаточно монет!");
      }
    });
    buyHintBtn.addEventListener("click", async () => {
      const cost = 60;
      if (currentCoins >= cost) {
        currentCoins -= cost;
        inventory.hints = (inventory.hints || 0) + 1;
        await updateUserInDB();
        showMessageModal("Покупка", "Куплена Подсказка!");
      } else {
        showMessageModal("Ошибка", "Недостаточно монет!");
      }
    });

    // Инфо
    infoBackBtn.addEventListener("click", () => {
      infoContainer.style.display = "none";
      displayMainMenu();
    });

    // Лидерборд
    leaderboardBackBtn.addEventListener("click", () => {
      leaderboardContainer.style.display = "none";
      displayMainMenu();
    });
    async function loadLeaderboard() {
      leaderboardBody.innerHTML = "";
      const usersRef = ref(db, "users/");
      const snapshot = await get(usersRef);
      if (snapshot.exists()) {
        const data = snapshot.val();
        const usersArray = Object.keys(data).map(key => {
          return { username: key, coins: data[key].coins || 0 };
        });
        usersArray.sort((a, b) => b.coins - a.coins);
        usersArray.forEach(user => {
          const tr = document.createElement("tr");
          const tdName = document.createElement("td");
          const tdCoins = document.createElement("td");
          tdName.textContent = user.username;
          tdCoins.textContent = user.coins;
          tr.appendChild(tdName);
          tr.appendChild(tdCoins);
          leaderboardBody.appendChild(tr);
        });
      }
    }

    // Игра
    backToMenuBtn.addEventListener("click", () => {
      endGameAndReturn();
    });

    function startGame() {
      gameContainer.style.display = "block";
      ctx = gameCanvas.getContext("2d");
      resizeCanvas();

      initBoard();
      scoreThisSession = 0;
      comboCount = 0;
      selectedCell = null;

      currentGameTimeLimit = BASE_GAME_TIME_LIMIT; 
      gameStartTime = Date.now();

      removeAllMatches(true);
      isGameRunning = true;

      gameCanvas.addEventListener("mousedown", onCanvasClick);
      gameCanvas.addEventListener("mouseup", onCanvasMouseUp);

      // Для тач-устройств
      gameCanvas.addEventListener("touchstart", onCanvasTouchStart, {passive: true});
      gameCanvas.addEventListener("touchend", onCanvasTouchEnd);

      // События Drag&Drop по бомбам
      bombDragBtn.addEventListener("mousedown", startDraggingBomb);
      bombDragBtn.addEventListener("touchstart", startDraggingBombTouch, {passive: true});

      lineBombDragBtn.addEventListener("mousedown", startDraggingLineBomb);
      lineBombDragBtn.addEventListener("touchstart", startDraggingLineBombTouch, {passive: true});

      // Кнопки использования
      refreshItemPanel();

      // Начинаем отрисовку
      animationLoop();
      updateTopPanel();
    }

    function refreshItemPanel() {
      // extraTime
      if (inventory.extraTime > 0) {
        useExtraTimeBtn.style.display = "inline-block";
        extraTimeCountSpan.textContent = inventory.extraTime;
      } else {
        useExtraTimeBtn.style.display = "none";
      }
      // бомбы
      if (inventory.bombs > 0) {
        bombDragBtn.style.display = "inline-block";
        bombCountSpan.textContent = inventory.bombs;
      } else {
        bombDragBtn.style.display = "none";
      }
      // линейная бомба
      if (inventory.lineBombs > 0) {
        lineBombDragBtn.style.display = "inline-block";
        lineBombCountSpan.textContent = inventory.lineBombs;
      } else {
        lineBombDragBtn.style.display = "none";
      }
      // подсказка
      if (inventory.hints > 0) {
        useHintBtn.style.display = "inline-block";
        hintCountSpan.textContent = inventory.hints;
      } else {
        useHintBtn.style.display = "none";
      }
    }

    useExtraTimeBtn.addEventListener("click", async () => {
      if (!isGameRunning) return;
      if (inventory.extraTime > 0) {
        inventory.extraTime--;
        currentGameTimeLimit += 20000; // +20 секунд
        await updateUserInDB();
        showMessageModal("Бонус", "Добавлено +20 секунд к таймеру!");
        refreshItemPanel();
      }
    });

    // Подсказка
    useHintBtn.addEventListener("click", async () => {
      if (!isGameRunning) return;
      if (inventory.hints > 0) {
        inventory.hints--;
        await updateUserInDB();
        refreshItemPanel();
        showHintMove();
      }
    });

    function showHintMove() {
      // Ищем любой ход
      const move = findAnyMove();
      if (!move) {
        showMessageModal("Подсказка", "Нет доступных ходов (поле будет перетасовано).");
        return;
      }
      // Подсветим эти клетки (два соседних)
      hintCells = move; // [{r,c}, {r,c}]
      if (hintTimer) clearTimeout(hintTimer);
      hintTimer = setTimeout(() => {
        hintCells = null;
      }, 2000);
    }

    function findAnyMove() {
      // Перебираем все клетки, пробуем swaps, ищем совпадения
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          // swap справа
          if (c+1 < boardSize) {
            swapPieces(r, c, r, c+1);
            if (findMatches().length) {
              swapPieces(r, c, r, c+1);
              return [{r, c}, {r, c:c+1}];
            }
            swapPieces(r, c, r, c+1);
          }
          // swap вниз
          if (r+1 < boardSize) {
            swapPieces(r, c, r+1, c);
            if (findMatches().length) {
              swapPieces(r, c, r+1, c);
              return [{r, c}, {r:r+1, c}];
            }
            swapPieces(r, c, r+1, c);
          }
        }
      }
      return null;
    }

    // Drag бомбы
    function startDraggingBomb(e) {
      if (!isGameRunning) return;
      if (inventory.bombs <= 0) return;
      draggingBomb = true;
      bombGhost.style.display = "block";
      moveGhost(bombGhost, e.clientX, e.clientY);
      document.addEventListener("mousemove", onBombDragging);
      document.addEventListener("mouseup", stopBombDragging);
    }
    function onBombDragging(e) {
      moveGhost(bombGhost, e.clientX, e.clientY);
    }
    function stopBombDragging(e) {
      draggingBomb = false;
      bombGhost.style.display = "none";
      document.removeEventListener("mousemove", onBombDragging);
      document.removeEventListener("mouseup", stopBombDragging);

      // Проверим, не бросили ли мы на canvas
      const rect = gameCanvas.getBoundingClientRect();
      if (
        e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top && e.clientY <= rect.bottom
      ) {
        // коорды на холсте
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        let c = Math.floor(x / cellSize);
        let r = Math.floor(y / cellSize);
        if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
          useBomb(r, c);
        }
      }
    }
    // Touch
    function startDraggingBombTouch(e) {
      if (!isGameRunning) return;
      if (inventory.bombs <= 0) return;
      draggingBomb = true;
      bombGhost.style.display = "block";
      const touch = e.touches[0];
      moveGhost(bombGhost, touch.clientX, touch.clientY);
      document.addEventListener("touchmove", onBombDraggingTouch, {passive: false});
      document.addEventListener("touchend", stopBombDraggingTouch);
    }
    function onBombDraggingTouch(e) {
      const touch = e.touches[0];
      moveGhost(bombGhost, touch.clientX, touch.clientY);
    }
    function stopBombDraggingTouch(e) {
      draggingBomb = false;
      bombGhost.style.display = "none";
      document.removeEventListener("touchmove", onBombDraggingTouch);
      document.removeEventListener("touchend", stopBombDraggingTouch);

      // touchend обычно последний палец оторвался
      // берем последний touch для коорд - на touchend он пуст
      // поэтому добавим проверку changedTouches
      if (e.changedTouches && e.changedTouches.length > 0) {
        const touch = e.changedTouches[0];
        const rect = gameCanvas.getBoundingClientRect();
        if (
          touch.clientX >= rect.left && touch.clientX <= rect.right &&
          touch.clientY >= rect.top && touch.clientY <= rect.bottom
        ) {
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          let c = Math.floor(x / cellSize);
          let r = Math.floor(y / cellSize);
          if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
            useBomb(r, c);
          }
        }
      }
    }

    function useBomb(r, c) {
      if (!isGameRunning) return;
      if (inventory.bombs <= 0) return;
      inventory.bombs--;
      updateUserInDB();
      refreshItemPanel();

      bombArea(r, c);
      // Заполнение пустых ячеек без падения
      refillEmptyCells();
    }

    function bombArea(r, c) {
      for (let rr = r-1; rr <= r+1; rr++) {
        for (let cc = c-1; cc <= c+1; cc++) {
          if (rr >= 0 && rr < boardSize && cc >= 0 && cc < boardSize) {
            if (board[rr][cc]) {
              board[rr][cc].removing = true;
              spawnParticles(board[rr][cc], rr, cc);
            }
          }
        }
      }
      setTimeout(() => {
        for (let rr = r-1; rr <= r+1; rr++) {
          for (let cc = c-1; cc <= c+1; cc++) {
            if (rr >= 0 && rr < boardSize && cc >= 0 && cc < boardSize) {
              if (board[rr][cc] && board[rr][cc].removing) {
                board[rr][cc] = null;
                scoreThisSession += POINTS_PER_PIECE; 
              }
            }
          }
        }
      }, 200);
    }

    // Drag линейная бомба
    function startDraggingLineBomb(e) {
      if (!isGameRunning) return;
      if (inventory.lineBombs <= 0) return;
      draggingLineBomb = true;
      lineBombGhost.style.display = "block";
      moveGhost(lineBombGhost, e.clientX, e.clientY);
      document.addEventListener("mousemove", onLineBombDragging);
      document.addEventListener("mouseup", stopLineBombDragging);
    }
    function onLineBombDragging(e) {
      moveGhost(lineBombGhost, e.clientX, e.clientY);
    }
    function stopLineBombDragging(e) {
      draggingLineBomb = false;
      lineBombGhost.style.display = "none";
      document.removeEventListener("mousemove", onLineBombDragging);
      document.removeEventListener("mouseup", stopLineBombDragging);

      // Проверка на canvas
      const rect = gameCanvas.getBoundingClientRect();
      if (
        e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top && e.clientY <= rect.bottom
      ) {
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        let c = Math.floor(x / cellSize);
        let r = Math.floor(y / cellSize);
        if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
          useLineBomb(r);
        }
      }
    }
    // Touch
    function startDraggingLineBombTouch(e) {
      if (!isGameRunning) return;
      if (inventory.lineBombs <= 0) return;
      draggingLineBomb = true;
      lineBombGhost.style.display = "block";
      const touch = e.touches[0];
      moveGhost(lineBombGhost, touch.clientX, touch.clientY);
      document.addEventListener("touchmove", onLineBombDraggingTouch, {passive: false});
      document.addEventListener("touchend", stopLineBombDraggingTouch);
    }
    function onLineBombDraggingTouch(e) {
      const touch = e.touches[0];
      moveGhost(lineBombGhost, touch.clientX, touch.clientY);
    }
    function stopLineBombDraggingTouch(e) {
      draggingLineBomb = false;
      lineBombGhost.style.display = "none";
      document.removeEventListener("touchmove", onLineBombDraggingTouch);
      document.removeEventListener("touchend", stopLineBombDraggingTouch);

      if (e.changedTouches && e.changedTouches.length > 0) {
        const touch = e.changedTouches[0];
        const rect = gameCanvas.getBoundingClientRect();
        if (
          touch.clientX >= rect.left && touch.clientX <= rect.right &&
          touch.clientY >= rect.top && touch.clientY <= rect.bottom
        ) {
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          let c = Math.floor(x / cellSize);
          let r = Math.floor(y / cellSize);
          if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
            useLineBomb(r);
          }
        }
      }
    }

    function useLineBomb(r) {
      if (!isGameRunning) return;
      if (inventory.lineBombs <= 0) return;
      inventory.lineBombs--;
      updateUserInDB();
      refreshItemPanel();

      // Убираем весь ряд r
      for (let cc = 0; cc < boardSize; cc++) {
        if (board[r][cc]) {
          board[r][cc].removing = true;
          spawnParticles(board[r][cc], r, cc);
        }
      }
      setTimeout(() => {
        for (let cc = 0; cc < boardSize; cc++) {
          if (board[r][cc] && board[r][cc].removing) {
            board[r][cc] = null;
            scoreThisSession += POINTS_PER_PIECE;
          }
        }
        refillEmptyCells();
      }, 300);
    }

    function moveGhost(ghostEl, x, y) {
      ghostEl.style.left = (x - 20) + "px";
      ghostEl.style.top = (y - 20) + "px";
    }

    // Заполняем пустые ячейки без падения (просто сразу генерируем новые)
    function refillEmptyCells() {
      // Ждём чуть (0.3с) после анимации удаления
      setTimeout(() => {
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (!board[r][c]) {
              const newPiece = getRandomPiece();
              newPiece.x = c;
              newPiece.y = r;
              newPiece.scale = 1;
              newPiece.alpha = 1;
              newPiece.removing = false;
              board[r][c] = newPiece;
            }
          }
        }
      }, 300);
    }

    function onCanvasClick(e) {
      if (!isGameRunning) return;
      // Если мы в режиме перетаскивания бомбы — ничего не делать
      if (draggingBomb || draggingLineBomb) return;

      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      handleClickOnBoard(x, y);
    }
    function onCanvasMouseUp(e) {
      // если нужно — ничего, пока не используется
    }

    function onCanvasTouchStart(e) {
      // Не делаем preventDefault, чтобы не ломать клики
      if (!isGameRunning) return;
      if (draggingBomb || draggingLineBomb) return;
      const rect = gameCanvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      handleClickOnBoard(x, y);
    }
    function onCanvasTouchEnd(e) {
      // ничего
    }

    function handleClickOnBoard(x, y) {
      const c = Math.floor(x / cellSize);
      const r = Math.floor(y / cellSize);
      if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) return;

      if (!selectedCell) {
        selectedCell = { r, c };
      } else {
        const { r: r1, c: c1 } = selectedCell;
        if (isNeighbor(r1, c1, r, c)) {
          swapPieces(r1, c1, r, c);
          const matched = findMatches();
          if (!matched.length) {
            swapPieces(r1, c1, r, c); // отмена
          } else {
            removeAllMatches(false);
          }
        }
        selectedCell = null;
      }
    }
    function isNeighbor(r1, c1, r2, c2) {
      const dr = Math.abs(r1 - r2);
      const dc = Math.abs(c1 - c2);
      return (dr + dc === 1);
    }
    function swapPieces(r1, c1, r2, c2) {
      const temp = board[r1][c1];
      board[r1][c1] = board[r2][c2];
      board[r2][c2] = temp;
      if (board[r1][c1]) {
        board[r1][c1].x = c1;
        board[r1][c1].y = r1;
      }
      if (board[r2][c2]) {
        board[r2][c2].x = c2;
        board[r2][c2].y = r2;
      }
    }

    function findMatches() {
      const toRemove = [];
      // Горизонталь
      for (let r = 0; r < boardSize; r++) {
        let matchLen = 1;
        for (let c = 1; c < boardSize; c++) {
          const curr = board[r][c];
          const prev = board[r][c-1];
          if (curr && prev && sameType(curr, prev)) {
            matchLen++;
          } else {
            if (matchLen >= 3) {
              for (let k = 0; k < matchLen; k++) {
                toRemove.push({ r, c: c-1-k });
              }
            }
            matchLen = 1;
          }
        }
        if (matchLen >= 3) {
          for (let k = 0; k < matchLen; k++) {
            toRemove.push({ r, c: boardSize-1-k });
          }
        }
      }
      // Вертикаль
      for (let c = 0; c < boardSize; c++) {
        let matchLen = 1;
        for (let r = 1; r < boardSize; r++) {
          const curr = board[r][c];
          const prev = board[r-1][c];
          if (curr && prev && sameType(curr, prev)) {
            matchLen++;
          } else {
            if (matchLen >= 3) {
              for (let k = 0; k < matchLen; k++) {
                toRemove.push({ r: r-1-k, c });
              }
            }
            matchLen = 1;
          }
        }
        if (matchLen >= 3) {
          for (let k = 0; k < matchLen; k++) {
            toRemove.push({ r: boardSize-1-k, c });
          }
        }
      }
      return toRemove;
    }
    function sameType(a, b) {
      return a.shape === b.shape && a.color === b.color;
    }

    function removeAllMatches(forceImmediate) {
      const matches = findMatches();
      if (!matches.length) {
        comboCount = 0;
        if (!hasAnyMoves()) {
          shuffleBoard();
        }
        return;
      }
      comboCount = comboCount === 0 ? 1 : comboCount + 1;
      const points = matches.length * POINTS_PER_PIECE * comboCount;
      scoreThisSession += points;

      if (forceImmediate) {
        for (let m of matches) {
          board[m.r][m.c] = null;
        }
        refillEmptyCells();
        removeAllMatches(true);
        return;
      }
      for (let m of matches) {
        const piece = board[m.r][m.c];
        if (piece) {
          piece.removing = true;
          spawnParticles(piece, m.r, m.c);
        }
      }
      setTimeout(() => {
        for (let m of matches) {
          if (board[m.r][m.c] && board[m.r][m.c].removing) {
            board[m.r][m.c] = null;
          }
        }
        refillEmptyCells();
        setTimeout(() => {
          removeAllMatches(false);
        }, 300);
      }, 300);
    }

    function hasAnyMoves() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (c+1 < boardSize) {
            swapPieces(r, c, r, c+1);
            if (findMatches().length) {
              swapPieces(r, c, r, c+1);
              return true;
            }
            swapPieces(r, c, r, c+1);
          }
          if (r+1 < boardSize) {
            swapPieces(r, c, r+1, c);
            if (findMatches().length) {
              swapPieces(r, c, r+1, c);
              return true;
            }
            swapPieces(r, c, r+1, c);
          }
        }
      }
      return false;
    }

    function shuffleBoard() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          if (board[r][c]) {
            board[r][c].removing = true;
          }
        }
      }
      setTimeout(() => {
        let allPieces = [];
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (board[r][c]) {
              allPieces.push(board[r][c]);
            }
            board[r][c] = null;
          }
        }
        // Перемешиваем
        for (let i = allPieces.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allPieces[i], allPieces[j]] = [allPieces[j], allPieces[i]];
        }
        let idx = 0;
        for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
            if (idx < allPieces.length) {
              let p = allPieces[idx++];
              p.removing = false;
              p.scale = 1;
              p.alpha = 1;
              p.x = c;
              p.y = r;
              board[r][c] = p;
            } else {
              const np = getRandomPiece();
              np.x = c;
              np.y = r;
              board[r][c] = np;
            }
          }
        }
      }, 300);
    }

    function resizeCanvas() {
      const maxWidth = window.innerWidth * 0.95;
      const maxHeight = (window.innerHeight - 200); // запас под кнопки/панели
      const possibleCellSizeWidth = Math.floor(maxWidth / boardSize);
      const possibleCellSizeHeight = Math.floor(maxHeight / boardSize);
      cellSize = Math.min(80, possibleCellSizeWidth, possibleCellSizeHeight);
      if (cellSize < 30) cellSize = 30; // минимальный размер

      gameCanvas.width = boardSize * cellSize;
      gameCanvas.height = boardSize * cellSize;
    }
    window.addEventListener("resize", () => {
      if (isGameRunning) {
        resizeCanvas();
      }
    });

    function initBoard() {
      board = [];
      for (let r = 0; r < boardSize; r++) {
        const row = [];
        for (let c = 0; c < boardSize; c++) {
          const piece = getRandomPiece();
          piece.x = c;
          piece.y = r;
          piece.scale = 1;
          piece.alpha = 1;
          piece.removing = false;
          row.push(piece);
        }
        board.push(row);
      }
    }
    function getRandomPiece() {
      const idx = Math.floor(Math.random() * shapes.length);
      const { shape, color } = shapes[idx];
      return { shape, color };
    }

    // Анимация
    function animationLoop() {
      if (!isGameRunning) return;
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

      updateAnimations();
      drawBoard();
      drawParticles();

      animationId = requestAnimationFrame(animationLoop);
      updateTopPanel();
    }
    function updateAnimations() {
      // здесь можно было бы делать анимации "падения" и т.п.
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          const piece = board[r][c];
          if (!piece) continue;
          if (piece.removing) {
            piece.scale -= 0.1;
            piece.alpha -= 0.1;
            if (piece.scale <= 0 || piece.alpha <= 0) {
              board[r][c] = null;
            }
          }
        }
      }
    }
    function drawBoard() {
      for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
          drawCell(r, c);
        }
      }
      // Подсветка выбранной ячейки
      if (selectedCell) {
        const { r, c } = selectedCell;
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 4;
        ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
      }
      // Подсветка подсказки (двух ячеек)
      if (hintCells) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 3;
        hintCells.forEach(cell => {
          ctx.strokeRect(cell.c * cellSize, cell.r * cellSize, cellSize, cellSize);
        });
      }
    }
    function drawCell(r, c) {
      const piece = board[r][c];
      const px = c * cellSize;
      const py = r * cellSize;
      // фоновая сетка
      ctx.strokeStyle = "rgba(150, 150, 150, 0.3)";
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, cellSize, cellSize);

      if (!piece) return;

      ctx.save();
      ctx.translate(px + cellSize/2, py + cellSize/2);
      ctx.scale(piece.scale, piece.scale);
      ctx.globalAlpha = piece.alpha;
      ctx.translate(-cellSize/2, -cellSize/2);

      ctx.fillStyle = piece.color;
      switch (piece.shape) {
        case "circle":
          ctx.beginPath();
          ctx.arc(cellSize/2, cellSize/2, cellSize*0.35, 0, 2*Math.PI);
          ctx.fill();
          break;
        case "square":
          ctx.fillRect(cellSize*0.15, cellSize*0.15, cellSize*0.7, cellSize*0.7);
          break;
        case "triangle":
          ctx.beginPath();
          ctx.moveTo(cellSize/2, cellSize*0.1);
          ctx.lineTo(cellSize*0.1, cellSize*0.9);
          ctx.lineTo(cellSize*0.9, cellSize*0.9);
          ctx.closePath();
          ctx.fill();
          break;
        case "hexagon":
          drawHexagon(cellSize, cellSize, ctx);
          break;
        case "star":
          drawStar(cellSize, cellSize, ctx);
          break;
      }
      ctx.restore();
    }

    function drawHexagon(w, h, ctx) {
      const radius = w * 0.35;
      const cx = w / 2;
      const cy = h / 2;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = cx + radius * Math.cos(angle);
        const py = cy + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
    }
    function drawStar(w, h, ctx) {
      const cx = w / 2;
      const cy = h / 2;
      const spikes = 5;
      const outerRadius = w * 0.35;
      const innerRadius = outerRadius * 0.5;
      let rot = Math.PI / 2 * 3;
      let step = Math.PI / spikes;

      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        let xPos = cx + Math.cos(rot) * outerRadius;
        let yPos = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(xPos, yPos);
        rot += step;

        xPos = cx + Math.cos(rot) * innerRadius;
        yPos = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(xPos, yPos);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
    }

    // Частицы
    function spawnParticles(piece, r, c) {
      const px = c * cellSize + cellSize/2;
      const py = r * cellSize + cellSize/2;
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: px, y: py,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          alpha: 1,
          color: piece.color
        });
      }
    }
    function drawParticles() {
      for (let p of particles) {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, 2*Math.PI);
        ctx.fill();
        ctx.restore();

        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.03;
      }
      particles = particles.filter(p => p.alpha > 0);
    }

    // Обновляем верхнюю панель (очки/время)
    function updateTopPanel() {
      // время
      if (!isGameRunning) return;
      const now = Date.now();
      const elapsed = now - gameStartTime;
      const timeLeft = currentGameTimeLimit - elapsed;
      if (timeLeft <= 0) {
        openLoseModal();
        gameOverActions();
        return;
      }
      const secsLeft = Math.floor(timeLeft / 1000);
      const min = Math.floor(secsLeft / 60);
      const sec = secsLeft % 60;
      timeDisplay.textContent = `Время: ${min}:${sec < 10 ? "0"+sec : sec}`;
      // очки
      scoreDisplay.textContent = `Очки: ${scoreThisSession}`;
    }

    // Конец игры
    function gameOverActions() {
      isGameRunning = false;
      cancelAnimationFrame(animationId);
      gameCanvas.removeEventListener("mousedown", onCanvasClick);
      gameCanvas.removeEventListener("mouseup", onCanvasMouseUp);
      gameCanvas.removeEventListener("touchstart", onCanvasTouchStart);
      gameCanvas.removeEventListener("touchend", onCanvasTouchEnd);

      bombDragBtn.removeEventListener("mousedown", startDraggingBomb);
      bombDragBtn.removeEventListener("touchstart", startDraggingBombTouch);
      lineBombDragBtn.removeEventListener("mousedown", startDraggingLineBomb);
      lineBombDragBtn.removeEventListener("touchstart", startDraggingLineBombTouch);

      // Начислим монеты
      currentCoins += scoreThisSession;
      updateUserInDB();
    }
    function endGameAndReturn() {
      if (isGameRunning) {
        gameOverActions();
      }
      gameContainer.style.display = "none";
      displayMainMenu();
    }

    // Окна Победы / Проигрыша / ...
    function openModal(modal) {
      modal.style.display = "flex";
    }
    function closeModal(modal) {
      modal.style.display = "none";
    }
    function openLoseModal() {
      openModal(loseModal);
    }

    if (winModalClose) {
      winModalClose.addEventListener("click", () => closeModal(winModal));
    }
    if (takePrizeBtn) {
      takePrizeBtn.addEventListener("click", () => {
        closeModal(winModal);
        endGameAndReturn();
      });
    }
    loseModalClose.addEventListener("click", () => closeModal(loseModal));
    tryAgainBtn.addEventListener("click", () => {
      closeModal(loseModal);
      endGameAndReturn();
    });
    fortuneCloseBtn.addEventListener("click", () => {
      closeModal(fortuneModal);
    });

    // Колесо Фортуны
    const ticketsMap = [1, 2, 3, 4, 5];
    let isSpinning = false;
    spinWheelBtn.addEventListener("click", spinWheel);

    async function spinWheel() {
      if (isSpinning) return;
      isSpinning = true;
      spinResultMsg.textContent = "";

      // Фиксируем время
      lastSpinTime = Date.now();
      await updateUserInDB(); // сразу блокируем повтор

      const wheel = document.getElementById("fortuneWheel");
      const randomAngle = 360 * 5 + Math.floor(Math.random() * 360); 
      wheel.style.transition = "transform 4s cubic-bezier(0.33, 1, 0.68, 1)";
      wheel.style.transform = `rotate(${randomAngle}deg)`;

      setTimeout(() => {
        const normalizedAngle = randomAngle % 360;
        const sectorCount = 5;
        const sectorAngle = 360 / sectorCount;
        const sector = Math.floor(normalizedAngle / sectorAngle);
        const wonTickets = ticketsMap[(sectorCount - sector) % sectorCount];

        spinResultMsg.textContent = `Вы выиграли ${wonTickets} билет(ов)!`;
        currentTickets += wonTickets;
        updateUserInDB();

        setTimeout(() => {
          wheel.style.transition = "none";
          wheel.style.transform = "rotate(0deg)";
          isSpinning = false;
          closeModal(fortuneModal);
          // Обновим главную кнопку (чтобы показал таймер)
          updateFortuneButton();
        }, 600);
      }, 4200);
    }

    // Сохранение в БД
    async function updateUserInDB() {
      if (!currentUsername) return;
      const userRef = ref(db, `users/${currentUsername}`);
      await update(userRef, {
        coins: currentCoins,
        tickets: currentTickets,
        lastSpinTime,
        inventory
      });
      // Обновим текст
      coinsDisplay.textContent = `Монет: ${currentCoins}`;
      ticketsDisplay.textContent = `Билетов: ${currentTickets}`;
    }
  </script>
</body>
</html>
