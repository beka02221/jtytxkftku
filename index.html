<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <!-- Viewport для мобильных устройств -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Minimal Online Fighter</title>
  <style>
    /* Основные стили для мобильного режима */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      overflow-x: hidden;
    }
    /* Верхний бар (будет скрываться в режиме игры) */
    #topBar {
      background: #222;
      padding: 10px;
      text-align: center;
    }
    #topBar span { margin: 0 10px; font-size: 16px; }
    /* Лобби и список игр */
    #lobbySection, #roomListSection, #waitingRoomSection {
      text-align: center;
      margin-top: 20px;
    }
    .game-card {
      display: inline-block;
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      margin: 10px;
      width: 200px;
    }
    .game-card img { width: 100%; height: auto; border-radius: 4px; }
    #roomListSection table {
      margin: 0 auto;
      border-collapse: collapse;
      width: 80%;
    }
    #roomListSection th, #roomListSection td {
      border: 1px solid #444;
      padding: 8px;
      text-align: center;
    }
    /* Игровой экран */
    #gameSection {
      display: none;
      /* Центрированный канвас меньшего размера для мобильных устройств */
    }
    canvas {
      background: #000;
      display: block;
      margin: 10px auto;
      border: 2px solid #444;
    }
    /* Модальное окно для проверки ориентации */
    #orientationModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #orientationModal > div {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }
    /* Custom global modal для уведомлений и обратного отсчёта */
    #customModalBackdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #customModal {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 80%;
    }
    #customModal h2 {
      margin-bottom: 10px;
      font-size: 20px;
    }
    #customModal p {
      font-size: 16px;
      margin-bottom: 10px;
    }
    #customModal button {
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      background: #444;
      color: #fff;
      border-radius: 5px;
    }
    /* Mobile controls: левый блок (джойстик) и правый блок (стрельба) */
    #leftControls {
      position: fixed;
      bottom: 20px;
      left: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 2000;
    }
    #leftControls .dpad {
      display: flex;
      gap: 10px;
    }
    #rightControls {
      position: fixed;
      bottom: 20px;
      right: 10px;
      z-index: 2000;
    }
    #leftControls button, #rightControls button {
      padding: 10px 15px;
      font-size: 18px;
      border-radius: 5px;
      background: #444;
      border: none;
      color: #fff;
    }
  </style>
  
  <!-- Firebase v8 -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <!-- Верхняя панель (будет скрыта в режиме игры) -->
  <header id="topBar">
    <span id="usernameDisplay">@User</span>
    <span id="coinDisplay">Coins: 100</span>
    <span id="pointDisplay">Points: 0</span>
  </header>
  
  <!-- Модальное окно для ориентации -->
  <div id="orientationModal">
    <div>
      <p>Пожалуйста, поверните устройство в горизонтальное положение.</p>
      <button id="orientationOkBtn">OK</button>
    </div>
  </div>
  
  <!-- Custom глобальное модальное окно -->
  <div id="customModalBackdrop">
    <div id="customModal">
      <h2 id="customModalTitle"></h2>
      <p id="customModalMessage"></p>
      <button id="customModalBtn">OK</button>
    </div>
  </div>
  
  <!-- Лобби: список игр -->
  <main id="lobbySection">
    <h1>Список игр</h1>
    <div class="game-card">
      <img src="https://via.placeholder.com/200x150?text=Simple+Shooter" alt="Simple Shooter">
      <p>Simple Shooter</p>
      <button onclick="createRoom()">Создать комнату</button>
      <button onclick="showRoomList()">Присоединиться к комнате</button>
    </div>
  </main>
  
  <!-- Секция списка комнат -->
  <main id="roomListSection">
    <h1>Доступные комнаты</h1>
    <table id="roomsTable">
      <tr>
        <th>ID комнаты</th>
        <th>Создатель</th>
        <th>Статус</th>
        <th>Действие</th>
      </tr>
    </table>
  </main>
  
  <!-- Окно ожидания для хоста -->
  <main id="waitingRoomSection">
    <h1>Ожидание соперника...</h1>
    <p>Пожалуйста, подождите, пока второй игрок подключится.</p>
  </main>
  
  <!-- Игровой экран -->
  <section id="gameSection">
    <canvas id="gameCanvas" width="360" height="240"></canvas>
  </section>
  
  <!-- Mobile Controls -->
  <!-- Левый блок: джойстик с кнопкой Jump сверху и стрелками внизу -->
  <div id="leftControls">
    <button id="btnJump">Jump</button>
    <div class="dpad">
      <button id="btnLeft">←</button>
      <button id="btnRight">→</button>
    </div>
  </div>
  <!-- Правый блок: кнопка Shoot -->
  <div id="rightControls">
    <button id="btnShoot">Shoot</button>
  </div>
  
  <script>
    /********************************************************************
     * 1. Инициализация Firebase, Telegram и определение пользователя
     ********************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyApxp0dHh0TK4nZVfOqloJ92dekjvjey3I",
      authDomain: "meta-glitch.firebaseapp.com",
      projectId: "meta-glitch",
      storageBucket: "meta-glitch.firebasestorage.app",
      messagingSenderId: "186162879710",
      appId: "1:186162879710:web:87975bd09681505be7364f",
      measurementId: "G-1TXVH8MESD"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    // Если запускается через Telegram WebApp, используем его данные и запрашиваем полноэкранный режим; иначе тестовый пользователь.
    let currentUser = {};
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      currentUser = Telegram.WebApp.initDataUnsafe.user;
      if (typeof Telegram.WebApp.requestFullscreen === 'function') {
        Telegram.WebApp.requestFullscreen();
      } else {
        Telegram.WebApp.expand();
      }
    } else {
      let testCount = localStorage.getItem('testUserCount');
      testCount = testCount ? parseInt(testCount) + 1 : 1;
      localStorage.setItem('testUserCount', testCount);
      currentUser = { username: "TestUser" + testCount };
    }
    document.getElementById('usernameDisplay').textContent = "@" + currentUser.username;
    
    // Локальные данные пользователя
    let localUserData = { coins: 100, points: 0 };
    function updateTopBar() {
      document.getElementById('coinDisplay').textContent = "Coins: " + localUserData.coins;
      document.getElementById('pointDisplay').textContent = "Points: " + localUserData.points;
    }
    updateTopBar();
    
    /********************************************************************
     * 2. Логика комнат: создание, список и присоединение
     ********************************************************************/
    let roomID = null;
    let isHost = false;
    let remoteUsername = null;
    
    // Устанавливаем onDisconnect – чтобы при разрыве соединения данные игрока удалялись
    function setOnDisconnect() {
      db.ref("rooms/" + roomID + "/players/" + currentUser.username)
        .onDisconnect()
        .remove();
    }
    
    function createRoom() {
      const roomRef = db.ref("rooms").push();
      roomID = roomRef.key;
      const roomData = {
        game: "Simple Shooter",
        host: currentUser.username,
        status: "waiting",
        players: {}
      };
      // Хост (local player) управляет fighter1 (левая сторона)
      roomData.players[currentUser.username] = {
        x: 50,
        y: 320,
        hp: 100,
        bullets: 3,
        onGround: true,
        vy: 0,
        reloadTime: 3000,
        timestamp: Date.now()
      };
      isHost = true;
      roomRef.set(roomData).then(() => {
        setOnDisconnect();
        document.getElementById('lobbySection').style.display = 'none';
        document.getElementById('waitingRoomSection').style.display = 'block';
        roomRef.on("value", snapshot => {
          const data = snapshot.val();
          if(data && data.status === "started") {
            roomRef.off();
            startShooterGame();
          }
        });
      });
    }
    
    function showRoomList() {
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'block';
      const roomsRef = db.ref("rooms").orderByChild("status").equalTo("waiting");
      roomsRef.on("value", snapshot => {
        const roomsData = snapshot.val();
        const table = document.getElementById('roomsTable');
        table.innerHTML = `<tr>
          <th>ID комнаты</th>
          <th>Создатель</th>
          <th>Статус</th>
          <th>Действие</th>
        </tr>`;
        if(roomsData) {
          for(let rID in roomsData) {
            const room = roomsData[rID];
            if(room.host === currentUser.username) continue;
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${rID}</td>
                            <td>${room.host}</td>
                            <td>${room.status}</td>
                            <td><button onclick="joinExistingRoom('${rID}')">Присоединиться</button></td>`;
            table.appendChild(tr);
          }
        } else {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td colspan="4">Нет доступных комнат</td>`;
          table.appendChild(tr);
        }
      });
    }
    
    function joinExistingRoom(rID) {
      roomID = rID;
      const roomRef = db.ref("rooms/" + roomID);
      roomRef.once("value").then(snapshot => {
        const room = snapshot.val();
        if(room && room.status === "waiting") {
          roomRef.child("players").child(currentUser.username).set({
            x: 700,
            y: 320,
            hp: 100,
            bullets: 3,
            onGround: true,
            vy: 0,
            reloadTime: 3000,
            timestamp: Date.now()
          }).then(() => {
            setOnDisconnect();
            roomRef.update({ status: "started" }).then(() => {
              roomRef.off();
              isHost = false;
              startShooterGame();
            });
          });
        } else {
          showCustomModal("Ошибка", "Комната недоступна", () => {});
        }
      });
    }
    
    /********************************************************************
     * 3. Проверка ориентации устройства
     ********************************************************************/
    function checkOrientation(callback) {
      if(window.innerWidth < window.innerHeight) {
        document.getElementById('orientationModal').style.display = 'flex';
        document.getElementById('orientationOkBtn').onclick = function() {
          if(window.innerWidth >= window.innerHeight) {
            document.getElementById('orientationModal').style.display = 'none';
            callback();
          } else {
            showCustomModal("Внимание", "Пожалуйста, поверните устройство в горизонтальное положение.", () => {});
          }
        }
      } else {
        callback();
      }
    }
    
    /********************************************************************
     * 4. Механика игры "Simple Shooter" с онлайн-синхронизацией
     ********************************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const groundLevel = canvas.height - 100;
    const gravity = 0.5;
    
    // Загружаем изображения бойцов (левый и правый)
    const leftFighterImg = new Image();
    leftFighterImg.src = "https://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/6683c11ff148f10.png";
    const rightFighterImg = new Image();
    rightFighterImg.src = "https://i.pinimg.com/originals/b9/f5/3d/b9f53d6343a55a761968c4f3fb477a17.png";
    
    // Структуры бойцов: fighter1 для левого игрока, fighter2 для правого
    const fighter1 = {
      x: 50, y: groundLevel, width: 50, height: 80, hp: 100,
      color: 'blue', bullets: 3, reloadStart: null, reloadTime: 3000,
      vy: 0, onGround: true
    };
    const fighter2 = {
      x: canvas.width - 100, y: groundLevel, width: 50, height: 80, hp: 100,
      color: 'red', bullets: 3, reloadStart: null, reloadTime: 3000,
      vy: 0, onGround: true
    };
    
    // Объект для хранения пуль (синхронизируются через Firebase)
    let bullets = {};
    
    // Обработчики клавиатуры (если используются на ПК)
    let keys = {};
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });
    
    // Mobile controls: объект для отслеживания нажатых кнопок
    let mobileKeys = { left: false, right: false, jump: false, shoot: false };
    
    // Mobile control слушатели для левых кнопок
    document.getElementById("btnLeft").addEventListener("touchstart", e => { mobileKeys.left = true; e.preventDefault(); });
    document.getElementById("btnLeft").addEventListener("touchend", e => { mobileKeys.left = false; e.preventDefault(); });
    document.getElementById("btnLeft").addEventListener("mousedown", () => { mobileKeys.left = true; });
    document.getElementById("btnLeft").addEventListener("mouseup", () => { mobileKeys.left = false; });
    
    document.getElementById("btnRight").addEventListener("touchstart", e => { mobileKeys.right = true; e.preventDefault(); });
    document.getElementById("btnRight").addEventListener("touchend", e => { mobileKeys.right = false; e.preventDefault(); });
    document.getElementById("btnRight").addEventListener("mousedown", () => { mobileKeys.right = true; });
    document.getElementById("btnRight").addEventListener("mouseup", () => { mobileKeys.right = false; });
    
    document.getElementById("btnJump").addEventListener("touchstart", e => { mobileKeys.jump = true; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("touchend", e => { mobileKeys.jump = false; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("mousedown", () => { mobileKeys.jump = true; });
    document.getElementById("btnJump").addEventListener("mouseup", () => { mobileKeys.jump = false; });
    
    // Mobile control для стрельбы
    document.getElementById("btnShoot").addEventListener("touchstart", e => { mobileKeys.shoot = true; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("touchend", e => { mobileKeys.shoot = false; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("mousedown", () => { mobileKeys.shoot = true; });
    document.getElementById("btnShoot").addEventListener("mouseup", () => { mobileKeys.shoot = false; });
    
    // Функции для определения локального и удалённого бойца
    function getLocalFighter() {
      return isHost ? fighter1 : fighter2;
    }
    function getRemoteFighter() {
      return isHost ? fighter2 : fighter1;
    }
    
    // Обновление состояния локального бойца (только горизонтальное движение и прыжок)
    function updateLocalFighter() {
      const localFighter = getLocalFighter();
      // Горизонтальное движение
      if(keys['ArrowLeft'] || mobileKeys.left) localFighter.x -= 5;
      if(keys['ArrowRight'] || mobileKeys.right) localFighter.x += 5;
      localFighter.x = Math.max(0, Math.min(canvas.width - localFighter.width, localFighter.x));
      // Прыжок (вертикальное движение допускается только через гравитацию)
      if((keys['ArrowUp'] || mobileKeys.jump) && localFighter.onGround) {
        localFighter.vy = -12;
        localFighter.onGround = false;
      }
      if(!localFighter.onGround) {
        localFighter.vy += gravity;
        localFighter.y += localFighter.vy;
        if(localFighter.y >= groundLevel) {
          localFighter.y = groundLevel;
          localFighter.vy = 0;
          localFighter.onGround = true;
        }
      }
      // Стрельба: пробел или mobileKeys.shoot
      if((keys[' '] || mobileKeys.shoot) && localFighter.bullets > 0) {
        const bulletData = {
          owner: currentUser.username,
          x: (isHost ? localFighter.x + localFighter.width : localFighter.x - 10),
          y: localFighter.y + localFighter.height / 2 - 2,
          vx: (isHost ? 4 : -4),
          width: 10,
          height: 4,
          timestamp: Date.now()
        };
        db.ref("rooms/" + roomID + "/bullets").push(bulletData);
        localFighter.bullets--;
        if(localFighter.bullets === 0) {
          localFighter.reloadStart = Date.now();
        }
        mobileKeys.shoot = false;
        keys[' '] = false;
      }
      if(localFighter.bullets === 0 && localFighter.reloadStart) {
        if(Date.now() - localFighter.reloadStart >= localFighter.reloadTime) {
          localFighter.bullets = 3;
          localFighter.reloadStart = null;
        }
      }
    }
    
    // Обновление пуль: двигаем пули, удаляем их при выходе за границу
    function updateBullets() {
      for (let id in bullets) {
        const b = bullets[id];
        b.x += b.vx;
        if(b.x < 0 || b.x > canvas.width) {
          deleteBullet(id);
          continue;
        }
        // Если пуля принадлежит удалённому игроку, проверяем столкновение с локальным бойцом
        if(b.owner !== currentUser.username && isColliding(b, getLocalFighter())) {
          getLocalFighter().hp = Math.max(0, getLocalFighter().hp - 10);
          deleteBullet(id);
        }
      }
    }
    
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    
    function deleteBullet(id) {
      db.ref("rooms/" + roomID + "/bullets/" + id).remove();
      delete bullets[id];
    }
    
    // Слушатель пуль из Firebase
    function listenToBullets() {
      const bulletsRef = db.ref("rooms/" + roomID + "/bullets");
      bulletsRef.on("child_added", snapshot => {
        const bullet = snapshot.val();
        bullet.id = snapshot.key;
        bullets[bullet.id] = bullet;
      });
      bulletsRef.on("child_removed", snapshot => {
        const bid = snapshot.key;
        if(bullets[bid]) delete bullets[bid];
      });
    }
    
    // Синхронизация локального игрока в Firebase
    function syncLocalState() {
      const localFighter = getLocalFighter();
      db.ref("rooms/" + roomID + "/players/" + currentUser.username).update({
        x: localFighter.x,
        y: localFighter.y,
        hp: localFighter.hp,
        bullets: localFighter.bullets,
        onGround: localFighter.onGround,
        timestamp: Date.now()
      });
    }
    
    // Слушаем обновления состояния игроков
    function listenToPlayers() {
      db.ref("rooms/" + roomID + "/players").on("value", snapshot => {
        const players = snapshot.val();
        for(let uname in players) {
          if(uname !== currentUser.username) {
            remoteUsername = uname;
            const remoteData = players[uname];
            if(isHost) {
              fighter2.x = remoteData.x;
              fighter2.y = remoteData.y;
              fighter2.hp = remoteData.hp;
              fighter2.bullets = remoteData.bullets;
              fighter2.onGround = remoteData.onGround;
            } else {
              fighter1.x = remoteData.x;
              fighter1.y = remoteData.y;
              fighter1.hp = remoteData.hp;
              fighter1.bullets = remoteData.bullets;
              fighter1.onGround = remoteData.onGround;
            }
          }
        }
      });
    }
    
    // Обновление удалённого игрока (при попадании)
    function updateRemotePlayer(username, fighterState) {
      if(username) {
        db.ref("rooms/" + roomID + "/players/" + username).update({
          hp: fighterState.hp
        });
      }
    }
    
    // Рендер игрового поля: рисуем изображения бойцов, пули, индикаторы, а также выводим юзернеймы и количество пуль над каждым бойцом
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Рисуем бойца слева (fighter1) с изображением leftFighterImg
      if(leftFighterImg.complete) {
        ctx.drawImage(leftFighterImg, fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      } else {
        ctx.fillStyle = fighter1.color;
        ctx.fillRect(fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      }
      // Рисуем бойца справа (fighter2) с изображением rightFighterImg
      if(rightFighterImg.complete) {
        ctx.drawImage(rightFighterImg, fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      } else {
        ctx.fillStyle = fighter2.color;
        ctx.fillRect(fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      }
      // Рисуем пули
      ctx.fillStyle = "#fff";
      for (let id in bullets) {
        const b = bullets[id];
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      // Рисуем индикаторы здоровья прямо над бойцами
      ctx.fillStyle = "green";
      ctx.font = "14px Arial";
      // Для fighter1
      ctx.fillText("@" + (isHost ? currentUser.username : remoteUsername || "Waiting"), fighter1.x, fighter1.y - 20);
      ctx.fillText("HP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
      ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
      // Для fighter2
      ctx.fillText("@" + (isHost ? remoteUsername || "Waiting" : currentUser.username), fighter2.x, fighter2.y - 20);
      ctx.fillText("HP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
      ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
    }
    
    // Ограничиваем вертикальное перемещение: игрок может только прыгать, не перемещаться произвольно по Y
    // (vertical movement регулируется только силой прыжка и гравитацией)
    
    // Игровой цикл: обновление состояния, синхронизация и рендеринг
    let gameLoopId;
    function gameLoop() {
      updateLocalFighter();
      syncLocalState();
      updateBullets();
      renderGame();
      const localHP = getLocalFighter().hp;
      const remoteHP = getRemoteFighter().hp;
      if(localHP <= 0 || remoteHP <= 0) {
        let result = (localHP > 0) ? "Вы выиграли!" : "Вы проиграли!";
        updateStats(result);
        showGameOverCountdown(result);
        if(isHost) {
          db.ref("rooms/" + roomID).remove();
        }
        cancelAnimationFrame(gameLoopId);
        return;
      }
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Запуск игры: скрываем окна ожидания и лобби, показываем игровой экран, отключаем скроллинг и включаем fullscreen
    function startShooterGame() {
      document.getElementById('waitingRoomSection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'none';
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('gameSection').style.display = 'block';
      // Скрываем топ-бар для максимального использования экрана
      document.getElementById('topBar').style.display = 'none';
      // Отключаем прокрутку
      document.body.style.overflow = 'hidden';
      listenToPlayers();
      listenToBullets();
      checkOrientation(initShooterGame);
      // Блокируем touchmove для игрового экрана
      document.getElementById('gameSection').addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
    }
    
    function initShooterGame() {
      const localFighter = getLocalFighter();
      if(isHost) {
        fighter1.x = 50; fighter1.y = groundLevel; fighter1.hp = 100;
        fighter1.bullets = 3; fighter1.vy = 0; fighter1.onGround = true;
      } else {
        fighter2.x = canvas.width - 100; fighter2.y = groundLevel; fighter2.hp = 100;
        fighter2.bullets = 3; fighter2.vy = 0; fighter2.onGround = true;
      }
      bullets = {};
      gameLoop();
    }
    
    /********************************************************************
     * 5. Кастомное глобальное модальное окно
     ********************************************************************/
    function showCustomModal(title, message, callback) {
      document.getElementById('customModalTitle').innerText = title;
      document.getElementById('customModalMessage').innerText = message;
      document.getElementById('customModalBackdrop').style.display = 'flex';
      document.getElementById('customModalBtn').onclick = function() {
        document.getElementById('customModalBackdrop').style.display = 'none';
        if(callback) callback();
      };
    }
    
    /********************************************************************
     * 6. Отображение Game Over с обратным отсчетом
     ********************************************************************/
    function showGameOverCountdown(result) {
      let countdown = 5;
      const msg = "Game Over: " + result + "\nВозвращение в лобби через " + countdown + " секунд";
      showCustomModal("Game Over", msg, () => {});
      // Обновляем каждую секунду
      const intervalId = setInterval(() => {
        countdown--;
        document.getElementById('customModalMessage').innerText = "Game Over: " + result + "\nВозвращение в лобби через " + countdown + " секунд";
        if (countdown <= 0) {
          clearInterval(intervalId);
          // Возвращаемся в лобби и восстанавливаем топ-бар, а также включаем скролл
          document.getElementById('gameSection').style.display = 'none';
          document.getElementById('lobbySection').style.display = 'block';
          document.getElementById('topBar').style.display = 'block';
          document.body.style.overflow = 'auto';
        }
      }, 1000);
    }
    
    /********************************************************************
     * 7. Статистика игр: сохранение результатов дуэлей в Firebase
     ********************************************************************/
    function updateStats(result) {
      const statsRef = db.ref("stats/" + currentUser.username);
      statsRef.once("value").then(snapshot => {
        let stats = snapshot.val() || { wins: 0, losses: 0, points: 0 };
        if(result === "Вы выиграли!") {
          stats.wins++;
        } else {
          stats.losses++;
        }
        stats.points += localUserData.points;
        statsRef.set(stats);
      });
    }
    
    /********************************************************************
     * 8. Блокировка дополнительных жестов на iOS
     ********************************************************************/
    document.addEventListener('touchmove', function(event) {
      if (document.getElementById('gameSection').style.display === 'block') {
        event.preventDefault();
      }
    }, { passive: false });
    
  </script>
</body>
</html>
