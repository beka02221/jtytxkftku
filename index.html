<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <!-- Настройка viewport для мобильных устройств -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Minimal Online Fighter</title>
  <style>
    /* Общие стили */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      overflow-x: hidden;
    }
    /* Верхний бар (виден только в лобби) */
    #topBar {
      background: #222;
      padding: 10px;
      text-align: center;
    }
    #topBar span { margin: 0 10px; font-size: 16px; }
    /* Страницы (лобби, списки) – стандартное выравнивание */
    main {
      text-align: center;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .game-card {
      display: inline-block;
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      margin: 10px;
      width: 200px;
    }
    .game-card img {
      width: 100%;
      height: auto;
      border-radius: 4px;
    }
    #roomListSection table {
      margin: 0 auto;
      border-collapse: collapse;
      width: 80%;
    }
    #roomListSection th, #roomListSection td {
      border: 1px solid #444;
      padding: 8px;
      text-align: center;
    }
    /* Окно ожидания для хоста */
    #waitingRoomSection { display: none; }
    #waitingRoomSection p { font-size: 24px; margin-top: 20px; }
    /* Игровой экран: центрируем канвас с помощью Flex */
    #gameSection {
      display: none;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000;
    }
    canvas {
      background: #000;
      border: 2px solid #444;
      /* Размер канваса для мобильного поля игры */
      width: 360px;
      height: 240px;
    }
    /* Модальное окно для ориентации */
    #orientationModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #orientationModal > div {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      font-size: 16px;
    }
    /* Кастомное модальное окно для уведомлений и обратного отсчёта */
    #customModalBackdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #customModal {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 80%;
    }
    #customModal h2 { margin-bottom: 10px; font-size: 20px; }
    #customModal p { font-size: 16px; margin-bottom: 10px; }
    #customModal button {
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      background: #444;
      color: #fff;
      border-radius: 5px;
    }
    /* Mobile Controls */
    /* Левый блок – джойстик: кнопка Jump сверху, два направления вниз */
    #leftControls {
      position: fixed;
      bottom: 20px;
      left: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 2000;
    }
    #leftControls .dpad {
      display: flex;
      gap: 10px;
    }
    /* Правый блок – кнопка Shoot */
    #rightControls {
      position: fixed;
      bottom: 20px;
      right: 10px;
      z-index: 2000;
    }
    #leftControls button, #rightControls button {
      padding: 10px 15px;
      font-size: 18px;
      border-radius: 5px;
      background: #444;
      border: none;
      color: #fff;
    }
  </style>
  
  <!-- Firebase v8 -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <!-- Верхняя панель (видна в лобби, скрывается в режиме игры) -->
  <header id="topBar">
    <span id="usernameDisplay">@User</span>
    <span id="coinDisplay">Coins: 100</span>
    <span id="pointDisplay">Points: 0</span>
  </header>
  
  <!-- Модальное окно для ориентации -->
  <div id="orientationModal">
    <div>
      <p>Для лучшего опыта рекомендуется горизонтальное расположение, но вы можете играть и вертикально. Нажмите OK для продолжения.</p>
      <button id="orientationOkBtn">OK</button>
    </div>
  </div>
  
  <!-- Кастомное модальное окно (уведомления, обратный отсчёт) -->
  <div id="customModalBackdrop">
    <div id="customModal">
      <h2 id="customModalTitle"></h2>
      <p id="customModalMessage"></p>
      <button id="customModalBtn">OK</button>
    </div>
  </div>
  
  <!-- Лобби -->
  <main id="lobbySection">
    <h1>Список игр</h1>
    <div class="game-card">
      <img src="https://via.placeholder.com/200x150?text=Simple+Shooter" alt="Simple Shooter">
      <p>Simple Shooter</p>
      <button onclick="createRoom()">Создать комнату</button>
      <button onclick="showRoomList()">Присоединиться к комнате</button>
    </div>
  </main>
  
  <!-- Секция списка комнат -->
  <main id="roomListSection">
    <h1>Доступные комнаты</h1>
    <table id="roomsTable">
      <tr>
        <th>ID комнаты</th>
        <th>Создатель</th>
        <th>Статус</th>
        <th>Действие</th>
      </tr>
    </table>
  </main>
  
  <!-- Окно ожидания для хоста -->
  <main id="waitingRoomSection">
    <h1>Ожидание соперника...</h1>
    <p>Пожалуйста, подождите, пока второй игрок подключится.</p>
  </main>
  
  <!-- Игровой экран – канвас в центре, без верхнего бара и кнопки Exit -->
  <section id="gameSection">
    <canvas id="gameCanvas" width="360" height="240"></canvas>
  </section>
  
  <!-- Mobile Controls: левый блок (джойстик) и правый блок (стрельба) -->
  <div id="leftControls">
    <button id="btnJump">Jump</button>
    <div class="dpad">
      <button id="btnLeft">←</button>
      <button id="btnRight">→</button>
    </div>
  </div>
  <div id="rightControls">
    <button id="btnShoot">Shoot</button>
  </div>
  
  <script>
    /********************************************************************
     * 1. Инициализация Firebase, Telegram и определение пользователя
     ********************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyApxp0dHh0TK4nZVfOqloJ92dekjvjey3I",
      authDomain: "meta-glitch.firebaseapp.com",
      projectId: "meta-glitch",
      storageBucket: "meta-glitch.firebasestorage.app",
      messagingSenderId: "186162879710",
      appId: "1:186162879710:web:87975bd09681505be7364f",
      measurementId: "G-1TXVH8MESD"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    // Если запускается через Telegram – используем его данные; иначе создаём TestUserN.
    let currentUser = {};
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      currentUser = Telegram.WebApp.initDataUnsafe.user;
      if (typeof Telegram.WebApp.requestFullscreen === 'function') {
        Telegram.WebApp.requestFullscreen();
      } else {
        Telegram.WebApp.expand();
      }
    } else {
      let testCount = localStorage.getItem('testUserCount');
      testCount = testCount ? parseInt(testCount) + 1 : 1;
      localStorage.setItem('testUserCount', testCount);
      currentUser = { username: "TestUser" + testCount };
    }
    // Отображаем имя без знака "@"
    document.getElementById('usernameDisplay').textContent = currentUser.username;
    
    // Локальные данные пользователя
    let localUserData = { coins: 100, points: 0 };
    function updateTopBar() {
      document.getElementById('coinDisplay').textContent = "Coins: " + localUserData.coins;
      document.getElementById('pointDisplay').textContent = "Points: " + localUserData.points;
    }
    updateTopBar();
    
    /********************************************************************
     * 2. Логика комнат: создание, список и присоединение
     ********************************************************************/
    let roomID = null;
    let isHost = false;
    let remoteUsername = null;
    
    // Устанавливаем onDisconnect – удаляем данные игрока при разрыве соединения
    function setOnDisconnect() {
      db.ref("rooms/" + roomID + "/players/" + currentUser.username)
        .onDisconnect()
        .remove();
    }
    
    function createRoom() {
      const roomRef = db.ref("rooms").push();
      roomID = roomRef.key;
      const roomData = {
        game: "Simple Shooter",
        host: currentUser.username,
        status: "waiting",
        players: {}
      };
      // Хост – local player управляет fighter1 (левая сторона)
      roomData.players[currentUser.username] = {
        x: 50,
        y: 320,
        hp: 100,  // XP будет равен этому значению
        bullets: 3,
        onGround: true,
        vy: 0,
        reloadTime: 3000,
        timestamp: Date.now()
      };
      isHost = true;
      roomRef.set(roomData).then(() => {
        setOnDisconnect();
        document.getElementById('lobbySection').style.display = 'none';
        document.getElementById('waitingRoomSection').style.display = 'block';
        roomRef.on("value", snapshot => {
          const data = snapshot.val();
          if(data && data.status === "started") {
            roomRef.off();
            startShooterGame();
          }
        });
      });
    }
    
    function showRoomList() {
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'block';
      const roomsRef = db.ref("rooms").orderByChild("status").equalTo("waiting");
      roomsRef.on("value", snapshot => {
        const roomsData = snapshot.val();
        const table = document.getElementById('roomsTable');
        table.innerHTML = `<tr>
          <th>ID комнаты</th>
          <th>Создатель</th>
          <th>Статус</th>
          <th>Действие</th>
        </tr>`;
        if(roomsData) {
          for(let rID in roomsData) {
            const room = roomsData[rID];
            if(room.host === currentUser.username) continue;
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${rID}</td>
                            <td>${room.host}</td>
                            <td>${room.status}</td>
                            <td><button onclick="joinExistingRoom('${rID}')">Присоединиться</button></td>`;
            table.appendChild(tr);
          }
        } else {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td colspan="4">Нет доступных комнат</td>`;
          table.appendChild(tr);
        }
      });
    }
    
    function joinExistingRoom(rID) {
      roomID = rID;
      const roomRef = db.ref("rooms/" + roomID);
      roomRef.once("value").then(snapshot => {
        const room = snapshot.val();
        if(room && room.status === "waiting") {
          roomRef.child("players").child(currentUser.username).set({
            x: 700,  // присоединяющийся игрок управляет fighter2 (правая сторона)
            y: 320,
            hp: 100,
            bullets: 3,
            onGround: true,
            vy: 0,
            reloadTime: 3000,
            timestamp: Date.now()
          }).then(() => {
            setOnDisconnect();
            roomRef.update({ status: "started" }).then(() => {
              roomRef.off();
              isHost = false;
              startShooterGame();
            });
          });
        } else {
          showCustomModal("Ошибка", "Комната недоступна", ()=>{});
        }
      });
    }
    
    /********************************************************************
     * 3. Проверка ориентации устройства
     * Если устройство вертикальное, информируем пользователя, но разрешаем играть и в таком режиме.
     ********************************************************************/
    function checkOrientation(callback) {
      if(window.innerWidth < window.innerHeight) {
        document.getElementById('orientationModal').style.display = 'flex';
        document.getElementById('orientationOkBtn').onclick = function() {
          document.getElementById('orientationModal').style.display = 'none';
          callback();
        }
      } else {
        callback();
      }
    }
    
    /********************************************************************
     * 4. Механика игры "Simple Shooter" с онлайн-синхронизацией
     ********************************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const groundLevel = canvas.height - 100;
    const gravity = 0.5;
    
    // Загружаем изображения бойцов
    const leftFighterImg = new Image();
    leftFighterImg.src = "https://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/6683c11ff148f10.png";
    const rightFighterImg = new Image();
    rightFighterImg.src = "https://i.pinimg.com/originals/b9/f5/3d/b9f53d6343a55a761968c4f3fb477a17.png";
    
    // Структуры бойцов: fighter1 для левого, fighter2 для правого
    const fighter1 = {  
      x: 50,
      y: groundLevel,
      width: 50,
      height: 80,
      hp: 100,  // XP: 100
      color: 'blue',
      bullets: 3,
      reloadStart: null,
      reloadTime: 3000,
      vy: 0,
      onGround: true
    };
    const fighter2 = {  
      x: canvas.width - 100,
      y: groundLevel,
      width: 50,
      height: 80,
      hp: 100,
      color: 'red',
      bullets: 3,
      reloadStart: null,
      reloadTime: 3000,
      vy: 0,
      onGround: true
    };
    
    // Пули синхронизируются через Firebase; храним их в объекте
    let bullets = {};
    
    // Обработчики клавиатуры (если используется)
    let keys = {};
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });
    
    // Mobile Controls: отслеживаем нажатые кнопки
    let mobileKeys = { left: false, right: false, jump: false, shoot: false };
    document.getElementById("btnLeft").addEventListener("touchstart", e => { mobileKeys.left = true; e.preventDefault(); });
    document.getElementById("btnLeft").addEventListener("touchend", e => { mobileKeys.left = false; e.preventDefault(); });
    document.getElementById("btnLeft").addEventListener("mousedown", () => { mobileKeys.left = true; });
    document.getElementById("btnLeft").addEventListener("mouseup", () => { mobileKeys.left = false; });
    
    document.getElementById("btnRight").addEventListener("touchstart", e => { mobileKeys.right = true; e.preventDefault(); });
    document.getElementById("btnRight").addEventListener("touchend", e => { mobileKeys.right = false; e.preventDefault(); });
    document.getElementById("btnRight").addEventListener("mousedown", () => { mobileKeys.right = true; });
    document.getElementById("btnRight").addEventListener("mouseup", () => { mobileKeys.right = false; });
    
    document.getElementById("btnJump").addEventListener("touchstart", e => { mobileKeys.jump = true; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("touchend", e => { mobileKeys.jump = false; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("mousedown", () => { mobileKeys.jump = true; });
    document.getElementById("btnJump").addEventListener("mouseup", () => { mobileKeys.jump = false; });
    
    document.getElementById("btnShoot").addEventListener("touchstart", e => { mobileKeys.shoot = true; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("touchend", e => { mobileKeys.shoot = false; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("mousedown", () => { mobileKeys.shoot = true; });
    document.getElementById("btnShoot").addEventListener("mouseup", () => { mobileKeys.shoot = false; });
    
    // Локальный и удалённый бойцы
    function getLocalFighter() {
      return isHost ? fighter1 : fighter2;
    }
    function getRemoteFighter() {
      return isHost ? fighter2 : fighter1;
    }
    
    // Обновление состояния локального бойца: только горизонтальное движение (ограничено) и прыжок
    function updateLocalFighter() {
      const localFighter = getLocalFighter();
      if(keys['ArrowLeft'] || mobileKeys.left) localFighter.x -= 5;
      if(keys['ArrowRight'] || mobileKeys.right) localFighter.x += 5;
      localFighter.x = Math.max(0, Math.min(canvas.width - localFighter.width, localFighter.x));
      // Прыжок
      if((keys['ArrowUp'] || mobileKeys.jump) && localFighter.onGround) {
        localFighter.vy = -12;
        localFighter.onGround = false;
      }
      if(!localFighter.onGround) {
        localFighter.vy += gravity;
        localFighter.y += localFighter.vy;
        if(localFighter.y >= groundLevel) {
          localFighter.y = groundLevel;
          localFighter.vy = 0;
          localFighter.onGround = true;
        }
      }
      // Стрельба: пробел или mobileKeys.shoot
      if((keys[' '] || mobileKeys.shoot) && localFighter.bullets > 0) {
        const bulletData = {
          owner: currentUser.username,
          x: (isHost ? localFighter.x + localFighter.width : localFighter.x - 10),
          y: localFighter.y + localFighter.height / 2 - 2,
          vx: (isHost ? 4 : -4),
          width: 10,
          height: 4,
          timestamp: Date.now()
        };
        db.ref("rooms/" + roomID + "/bullets").push(bulletData);
        localFighter.bullets--;
        if(localFighter.bullets === 0) {
          localFighter.reloadStart = Date.now();
        }
        mobileKeys.shoot = false;
        keys[' '] = false;
      }
      if(localFighter.bullets === 0 && localFighter.reloadStart) {
        if(Date.now() - localFighter.reloadStart >= localFighter.reloadTime) {
          localFighter.bullets = 3;
          localFighter.reloadStart = null;
        }
      }
    }
    
    // Обновление пуль: двигаем их и удаляем, если они выходят за границы
    function updateBullets() {
      for (let id in bullets) {
        const b = bullets[id];
        b.x += b.vx;
        if(b.x < 0 || b.x > canvas.width) {
          deleteBullet(id);
          continue;
        }
        if(b.owner !== currentUser.username && isColliding(b, getLocalFighter())) {
          getLocalFighter().hp = Math.max(0, getLocalFighter().hp - 10);
          deleteBullet(id);
        }
      }
    }
    
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    
    function deleteBullet(id) {
      db.ref("rooms/" + roomID + "/bullets/" + id).remove();
      delete bullets[id];
    }
    
    // Слушаем пули из Firebase
    function listenToBullets() {
      const bulletsRef = db.ref("rooms/" + roomID + "/bullets");
      bulletsRef.on("child_added", snapshot => {
        const bullet = snapshot.val();
        bullet.id = snapshot.key;
        bullets[bullet.id] = bullet;
      });
      bulletsRef.on("child_removed", snapshot => {
        const bid = snapshot.key;
        if(bullets[bid]) delete bullets[bid];
      });
    }
    
    // Синхронизация локального состояния бойца в Firebase
    function syncLocalState() {
      const localFighter = getLocalFighter();
      db.ref("rooms/" + roomID + "/players/" + currentUser.username).update({
        x: localFighter.x,
        y: localFighter.y,
        hp: localFighter.hp,
        bullets: localFighter.bullets,
        onGround: localFighter.onGround,
        timestamp: Date.now()
      });
    }
    
    // Слушаем обновления состояния игроков из Firebase
    function listenToPlayers() {
      db.ref("rooms/" + roomID + "/players").on("value", snapshot => {
        const players = snapshot.val();
        for(let uname in players) {
          if(uname !== currentUser.username) {
            remoteUsername = uname;
            const remoteData = players[uname];
            if(isHost) {
              fighter2.x = remoteData.x;
              fighter2.y = remoteData.y;
              fighter2.hp = remoteData.hp;
              fighter2.bullets = remoteData.bullets;
              fighter2.onGround = remoteData.onGround;
            } else {
              fighter1.x = remoteData.x;
              fighter1.y = remoteData.y;
              fighter1.hp = remoteData.hp;
              fighter1.bullets = remoteData.bullets;
              fighter1.onGround = remoteData.onGround;
            }
          }
        }
      });
    }
    
    // Обновление удалённого игрока в Firebase (например, при попадании)
    function updateRemotePlayer(username, fighterState) {
      if(username) {
        db.ref("rooms/" + roomID + "/players/" + username).update({
          hp: fighterState.hp
        });
      }
    }
    
    // Рендеринг игрового поля
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Рисуем левого бойца (fighter1) с изображением leftFighterImg
      if(leftFighterImg.complete) {
        ctx.drawImage(leftFighterImg, fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      } else {
        ctx.fillStyle = fighter1.color;
        ctx.fillRect(fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      }
      // Рисуем правого бойца (fighter2) с изображением rightFighterImg
      if(rightFighterImg.complete) {
        ctx.drawImage(rightFighterImg, fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      } else {
        ctx.fillStyle = fighter2.color;
        ctx.fillRect(fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      }
      // Рисуем пули
      ctx.fillStyle = "#fff";
      for (let id in bullets) {
        const b = bullets[id];
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      // Отрисовываем юзернеймы и XP (вместо HP) над бойцами и информацию о пулях под ними
      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      // Для fighter1 (левый)
      ctx.fillText(currentUser.username, fighter1.x, fighter1.y - 20);
      ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
      ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
      // Для fighter2 (правый)
      // Если remoteUsername еще не получен, показываем "Waiting"
      ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter2.x, fighter2.y - 20);
      ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
      ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
    }
    
    // Игровой цикл: обновляем локальный ввод, синхронизируем состояние, двигаем пули, отрисовываем экран
    let gameLoopId;
    function gameLoop() {
      updateLocalFighter();
      syncLocalState();
      updateBullets();
      renderGame();
      const localHP = getLocalFighter().hp;
      const remoteHP = getRemoteFighter().hp;
      if(localHP <= 0 || remoteHP <= 0) {
        let result = (localHP > 0) ? "Вы выиграли!" : "Вы проиграли!";
        updateStats(result);
        showGameOverCountdown(result);
        if(isHost) {
          db.ref("rooms/" + roomID).remove();
        }
        cancelAnimationFrame(gameLoopId);
        return;
      }
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Запуск игры: скрываем лобби/списки, показываем игровой экран, центрируем поле, скрываем топ-бар и блокируем скроллинг
    function startShooterGame() {
      document.getElementById('waitingRoomSection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'none';
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('gameSection').style.display = 'flex';
      document.getElementById('topBar').style.display = 'none';
      document.body.style.overflow = 'hidden';
      listenToPlayers();
      listenToBullets();
      checkOrientation(initShooterGame);
      // Блокируем touchmove для игрового экрана
      document.getElementById('gameSection').addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
    }
    
    function initShooterGame() {
      const localFighter = getLocalFighter();
      if(isHost) {
        fighter1.x = 50; fighter1.y = groundLevel; fighter1.hp = 100;
        fighter1.bullets = 3; fighter1.vy = 0; fighter1.onGround = true;
      } else {
        fighter2.x = canvas.width - 100; fighter2.y = groundLevel; fighter2.hp = 100;
        fighter2.bullets = 3; fighter2.vy = 0; fighter2.onGround = true;
      }
      bullets = {};
      gameLoop();
    }
    
    /********************************************************************
     * 5. Кастомное глобальное модальное окно
     ********************************************************************/
    function showCustomModal(title, message, callback) {
      document.getElementById('customModalTitle').innerText = title;
      document.getElementById('customModalMessage').innerText = message;
      document.getElementById('customModalBackdrop').style.display = 'flex';
      document.getElementById('customModalBtn').onclick = function() {
        document.getElementById('customModalBackdrop').style.display = 'none';
        if(callback) callback();
      };
    }
    
    /********************************************************************
     * 6. Отображение Game Over с обратным отсчётом
     ********************************************************************/
    function showGameOverCountdown(result) {
      let countdown = 5;
      showCustomModal("Game Over", "Результат: " + result + "\nВозвращение в лобби через " + countdown + " секунд", () => {});
      const intervalId = setInterval(() => {
        countdown--;
        document.getElementById('customModalMessage').innerText = "Результат: " + result + "\nВозвращение в лобби через " + countdown + " секунд";
        if (countdown <= 0) {
          clearInterval(intervalId);
          // Возвращаемся в лобби и восстанавливаем топ-бар и прокрутку
          document.getElementById('gameSection').style.display = 'none';
          document.getElementById('lobbySection').style.display = 'block';
          document.getElementById('topBar').style.display = 'block';
          document.body.style.overflow = 'auto';
        }
      }, 1000);
    }
    
    /********************************************************************
     * 7. Статистика игр: сохранение результатов дуэлей
     ********************************************************************/
    function updateStats(result) {
      const statsRef = db.ref("stats/" + currentUser.username);
      statsRef.once("value").then(snapshot => {
        let stats = snapshot.val() || { wins: 0, losses: 0, points: 0 };
        if(result === "Вы выиграли!") {
          stats.wins++;
        } else {
          stats.losses++;
        }
        stats.points += localUserData.points;
        statsRef.set(stats);
      });
    }
    
    /********************************************************************
     * 8. Дополнительная блокировка жестов (iOS) – предотвращаем масштабирование
     ********************************************************************/
    document.addEventListener('touchmove', function(event) {
      if (document.getElementById('gameSection').style.display === 'flex') {
        event.preventDefault();
      }
    }, { passive: false });
  </script>
</body>
</html>
