<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <!-- Viewport для мобильных устройств -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Minimal Online Fighter</title>
  <style>
    /* Общие стили */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      overflow-x: hidden;
    }
    /* Верхний бар (виден только в лобби) */
    #topBar {
      background: #222;
      padding: 10px;
      text-align: center;
    }
    #topBar span { margin: 0 10px; font-size: 16px; }
    /* Лобби и списки – видны только до начала игры */
    #lobbySection, #roomListSection, #waitingRoomSection {
      text-align: center;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .game-card {
      display: inline-block;
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      margin: 10px;
      width: 200px;
    }
    .game-card img {
      width: 100%;
      height: auto;
      border-radius: 4px;
    }
    #roomListSection table {
      margin: 0 auto;
      border-collapse: collapse;
      width: 80%;
    }
    #roomListSection th, #roomListSection td {
      border: 1px solid #444;
      padding: 8px;
      text-align: center;
    }
    /* Игровой экран – центрируем игровое поле */
    #gameSection {
      display: none;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000;
    }
    canvas {
      background: #000;
      border: 2px solid #444;
      width: 360px;  /* фиксированный размер поля для мобильных устройств */
      height: 240px;
    }
    /* Модальное окно для проверки ориентации */
    #orientationModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #orientationModal > div {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      font-size: 16px;
    }
    /* Кастомное модальное окно для уведомлений и обратного отсчёта */
    #customModalBackdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #customModal {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 80%;
    }
    #customModal h2 { margin-bottom: 10px; font-size: 20px; }
    #customModal p { font-size: 16px; margin-bottom: 10px; }
    #customModal button {
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      background: #444;
      color: #fff;
      border-radius: 5px;
    }
    /* Mobile Controls */
    /* Левый блок – джойстик: кнопка Jump сверху, а ниже две кнопки для движения */
    #leftControls {
      position: fixed;
      bottom: 80px;  /* подняли выше */
      left: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 2000;
    }
    #leftControls .dpad {
      display: flex;
      gap: 10px;
    }
    /* Правый блок – кнопка Shoot */
    #rightControls {
      position: fixed;
      bottom: 80px;  /* подняли выше */
      right: 10px;
      z-index: 2000;
    }
    #leftControls button, #rightControls button {
      padding: 12px 18px;
      font-size: 20px;
      border-radius: 8px;
      background: #444;
      border: none;
      color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
  </style>
  
  <!-- Firebase v8 -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <!-- Верхний бар (виден только в лобби) -->
  <header id="topBar">
    <span id="usernameDisplay">User</span>
    <span id="coinDisplay">Coins: 100</span>
    <span id="pointDisplay">Points: 0</span>
  </header>
  
  <!-- Модальное окно для ориентации -->
  <div id="orientationModal">
    <div>
      <p>Для лучшего опыта рекомендуется горизонтальное расположение, но вы можете играть и в вертикальном режиме. Нажмите OK для продолжения.</p>
      <button id="orientationOkBtn">OK</button>
    </div>
  </div>
  
  <!-- Кастомное модальное окно для уведомлений и обратного отсчёта -->
  <div id="customModalBackdrop">
    <div id="customModal">
      <h2 id="customModalTitle"></h2>
      <p id="customModalMessage"></p>
      <button id="customModalBtn">OK</button>
    </div>
  </div>
  
  <!-- Лобби -->
  <main id="lobbySection">
    <h1>Список игр</h1>
    <div class="game-card">
      <img src="https://via.placeholder.com/200x150?text=Simple+Shooter" alt="Simple Shooter">
      <p>Simple Shooter</p>
      <button onclick="createRoom()">Создать комнату</button>
      <button onclick="showRoomList()">Присоединиться к комнате</button>
    </div>
  </main>
  
  <!-- Секция списка комнат -->
  <main id="roomListSection" style="display:none;">
    <h1>Доступные комнаты</h1>
    <table id="roomsTable">
      <tr>
        <th>ID комнаты</th>
        <th>Создатель</th>
        <th>Статус</th>
        <th>Действие</th>
      </tr>
    </table>
  </main>
  
  <!-- Окно ожидания для хоста -->
  <main id="waitingRoomSection" style="display:none;">
    <h1>Ожидание соперника...</h1>
    <p>Пожалуйста, подождите, пока второй игрок подключится.</p>
  </main>
  
  <!-- Игровой экран – центральное игровое поле, верхний бар скрыт -->
  <section id="gameSection">
    <canvas id="gameCanvas" width="360" height="240"></canvas>
  </section>
  
  <!-- Mobile Controls -->
  <div id="leftControls">
    <button id="btnJump">Jump</button>
    <div class="dpad">
      <button id="btnLeft">←</button>
      <button id="btnRight">→</button>
    </div>
  </div>
  <div id="rightControls">
    <button id="btnShoot">Shoot</button>
  </div>
  
  <script>
    /********************************************************************
     * 1. Инициализация Firebase, Telegram и определение пользователя
     ********************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyApxp0dHh0TK4nZVfOqloJ92dekjvjey3I",
      authDomain: "meta-glitch.firebaseapp.com",
      projectId: "meta-glitch",
      storageBucket: "meta-glitch.firebasestorage.app",
      messagingSenderId: "186162879710",
      appId: "1:186162879710:web:87975bd09681505be7364f",
      measurementId: "G-1TXVH8MESD"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    // Если запущено через Telegram, используем его данные; иначе присваиваем TestUserN.
    let currentUser = {};
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      currentUser = Telegram.WebApp.initDataUnsafe.user;
      if (typeof Telegram.WebApp.requestFullscreen === 'function') {
        Telegram.WebApp.requestFullscreen();
      } else {
        Telegram.WebApp.expand();
      }
    } else {
      let testCount = localStorage.getItem('testUserCount');
      testCount = testCount ? parseInt(testCount) + 1 : 1;
      localStorage.setItem('testUserCount', testCount);
      currentUser = { username: "TestUser" + testCount };
    }
    // Отображаем имя без символа '@'
    document.getElementById('usernameDisplay').textContent = currentUser.username;
    
    // Локальные данные пользователя
    let localUserData = { coins: 100, points: 0 };
    function updateTopBar() {
      document.getElementById('coinDisplay').textContent = "Coins: " + localUserData.coins;
      document.getElementById('pointDisplay').textContent = "Points: " + localUserData.points;
    }
    updateTopBar();
    
    /********************************************************************
     * 2. Логика комнат: создание, список и присоединение
     ********************************************************************/
    let roomID = null;
    let isHost = false;
    let remoteUsername = null;
    
    function setOnDisconnect() {
      db.ref("rooms/" + roomID + "/players/" + currentUser.username)
        .onDisconnect()
        .remove();
    }
    
    function createRoom() {
      const roomRef = db.ref("rooms").push();
      roomID = roomRef.key;
      const roomData = {
        game: "Simple Shooter",
        host: currentUser.username,
        status: "waiting",
        players: {}
      };
      // Хост управляет своим персонажем (fighter1, левый)
      roomData.players[currentUser.username] = {
        x: 50,
        y: 320,
        hp: 100,
        bullets: 3,
        onGround: true,
        vy: 0,
        reloadTime: 3000,
        timestamp: Date.now()
      };
      isHost = true;
      roomRef.set(roomData).then(() => {
        setOnDisconnect();
        document.getElementById('lobbySection').style.display = 'none';
        document.getElementById('waitingRoomSection').style.display = 'block';
        roomRef.on("value", snapshot => {
          const data = snapshot.val();
          if(data && data.status === "started") {
            roomRef.off();
            startShooterGame();
          }
        });
      });
    }
    
    function showRoomList() {
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'block';
      const roomsRef = db.ref("rooms").orderByChild("status").equalTo("waiting");
      roomsRef.on("value", snapshot => {
        const roomsData = snapshot.val();
        const table = document.getElementById('roomsTable');
        table.innerHTML = `<tr>
          <th>ID комнаты</th>
          <th>Создатель</th>
          <th>Статус</th>
          <th>Действие</th>
        </tr>`;
        if(roomsData) {
          for(let rID in roomsData) {
            const room = roomsData[rID];
            if(room.host === currentUser.username) continue;
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${rID}</td>
                            <td>${room.host}</td>
                            <td>${room.status}</td>
                            <td><button onclick="joinExistingRoom('${rID}')">Присоединиться</button></td>`;
            table.appendChild(tr);
          }
        } else {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td colspan="4">Нет доступных комнат</td>`;
          table.appendChild(tr);
        }
      });
    }
    
    function joinExistingRoom(rID) {
      roomID = rID;
      const roomRef = db.ref("rooms/" + roomID);
      roomRef.once("value").then(snapshot => {
        const room = snapshot.val();
        if(room && room.status === "waiting") {
          roomRef.child("players").child(currentUser.username).set({
            x: 700,  // Присоединяющийся игрок – fighter2 (правый)
            y: 320,
            hp: 100,
            bullets: 3,
            onGround: true,
            vy: 0,
            reloadTime: 3000,
            timestamp: Date.now()
          }).then(() => {
            setOnDisconnect();
            roomRef.update({ status: "started" }).then(() => {
              roomRef.off();
              isHost = false;
              startShooterGame();
            });
          });
        } else {
          showCustomModal("Ошибка", "Комната недоступна", ()=>{});
        }
      });
    }
    
    /********************************************************************
     * 3. Проверка ориентации
     ********************************************************************/
    function checkOrientation(callback) {
      if(window.innerWidth < window.innerHeight) {
        document.getElementById('orientationModal').style.display = 'flex';
        document.getElementById('orientationOkBtn').onclick = function() {
          document.getElementById('orientationModal').style.display = 'none';
          callback();
        }
      } else {
        callback();
      }
    }
    
    /********************************************************************
     * 4. Механика игры "Simple Shooter" (только прыжок и стрельба)
     ********************************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const groundLevel = canvas.height - 100;
    const gravity = 0.5;
    
    // Загружаем изображения бойцов
    const leftFighterImg = new Image();
    leftFighterImg.src = "https://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/6683c11ff148f10.png";
    const rightFighterImg = new Image();
    rightFighterImg.src = "https://i.pinimg.com/originals/b9/f5/3d/b9f53d6343a55a761968c4f3fb477a17.png";
    
    // Структуры бойцов (fighter1 – левый, fighter2 – правый)
    const fighter1 = {  
      x: 50, 
      y: groundLevel, 
      width: 50, 
      height: 80, 
      hp: 100,
      color: 'blue', 
      bullets: 3, 
      reloadStart: null, 
      reloadTime: 3000,
      vy: 0, 
      onGround: true
    };
    const fighter2 = {  
      x: canvas.width - 100, 
      y: groundLevel, 
      width: 50, 
      height: 80, 
      hp: 100,
      color: 'red', 
      bullets: 3, 
      reloadStart: null, 
      reloadTime: 3000,
      vy: 0, 
      onGround: true
    };
    
    // Объект для хранения пуль (синхронизируются через Firebase)
    let bullets = {};
    
    // Удаляем обработчики горизонтального движения — игроки не могут двигаться влево/вправо.
    let keys = {};
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });
    
    // Mobile Controls: отслеживаем состояние кнопок
    let mobileKeys = { left: false, right: false, jump: false, shoot: false };
    document.getElementById("btnLeft").addEventListener("touchstart", e => { mobileKeys.left = true; e.preventDefault(); });
    document.getElementById("btnLeft").addEventListener("touchend", e => { mobileKeys.left = false; e.preventDefault(); });
    document.getElementById("btnLeft").addEventListener("mousedown", () => { mobileKeys.left = true; });
    document.getElementById("btnLeft").addEventListener("mouseup", () => { mobileKeys.left = false; });
    
    document.getElementById("btnRight").addEventListener("touchstart", e => { mobileKeys.right = true; e.preventDefault(); });
    document.getElementById("btnRight").addEventListener("touchend", e => { mobileKeys.right = false; e.preventDefault(); });
    document.getElementById("btnRight").addEventListener("mousedown", () => { mobileKeys.right = true; });
    document.getElementById("btnRight").addEventListener("mouseup", () => { mobileKeys.right = false; });
    
    document.getElementById("btnJump").addEventListener("touchstart", e => { mobileKeys.jump = true; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("touchend", e => { mobileKeys.jump = false; e.preventDefault(); });
    document.getElementById("btnJump").addEventListener("mousedown", () => { mobileKeys.jump = true; });
    document.getElementById("btnJump").addEventListener("mouseup", () => { mobileKeys.jump = false; });
    
    document.getElementById("btnShoot").addEventListener("touchstart", e => { mobileKeys.shoot = true; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("touchend", e => { mobileKeys.shoot = false; e.preventDefault(); });
    document.getElementById("btnShoot").addEventListener("mousedown", () => { mobileKeys.shoot = true; });
    document.getElementById("btnShoot").addEventListener("mouseup", () => { mobileKeys.shoot = false; });
    
    // Функции для определения локального и удалённого бойца
    function getLocalFighter() {
      return isHost ? fighter1 : fighter2;
    }
    function getRemoteFighter() {
      return isHost ? fighter2 : fighter1;
    }
    
    // Дополнительное улучшение: переменная для счёта (score)
    let score = 0;
    
    // Звуковые эффекты
    const jumpSound = new Audio("https://actions.google.com/sounds/v1/cartoon/boing.ogg");
    const shootSound = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    const hitSound = new Audio("https://actions.google.com/sounds/v1/cartoon/pop.ogg");
    const gameOverSound = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    
    // Обновление состояния локального бойца — разрешаем только прыжок и стрельбу (горизонтальное движение отключено)
    function updateLocalFighter() {
      const localFighter = getLocalFighter();
      // Не обновляем горизонтальное движение – игроки остаются на своих позициях.
      // Только прыжок:
      if ((keys['ArrowUp'] || mobileKeys.jump) && localFighter.onGround) {
        localFighter.vy = -12;
        localFighter.onGround = false;
        jumpSound.currentTime = 0;
        jumpSound.play();
      }
      if (!localFighter.onGround) {
        localFighter.vy += gravity;
        localFighter.y += localFighter.vy;
        if (localFighter.y >= groundLevel) {
          localFighter.y = groundLevel;
          localFighter.vy = 0;
          localFighter.onGround = true;
        }
      }
      // Стрельба: пробел или мобильная кнопка shoot
      if ((keys[' '] || mobileKeys.shoot) && localFighter.bullets > 0) {
        const bulletData = {
          owner: currentUser.username,
          x: (isHost ? localFighter.x + localFighter.width : localFighter.x - 10),
          y: localFighter.y + localFighter.height / 2 - 2,
          vx: (isHost ? 4 : -4),
          width: 10,
          height: 4,
          timestamp: Date.now()
        };
        db.ref("rooms/" + roomID + "/bullets").push(bulletData);
        localFighter.bullets--;
        shootSound.currentTime = 0;
        shootSound.play();
        if(localFighter.bullets === 0) {
          localFighter.reloadStart = Date.now();
        }
        mobileKeys.shoot = false;
        keys[' '] = false;
      }
      if (localFighter.bullets === 0 && localFighter.reloadStart) {
        if (Date.now() - localFighter.reloadStart >= localFighter.reloadTime) {
          localFighter.bullets = 3;
          localFighter.reloadStart = null;
        }
      }
    }
    
    // Обновляем пули: двигаем их, если пуля доходит до края – удаляем её, если попадает – уменьшаем XP противника
    function updateBullets() {
      for (let id in bullets) {
        const b = bullets[id];
        b.x += b.vx;
        if (b.x + b.width < 0 || b.x > canvas.width) {
          deleteBullet(id);
          continue;
        }
        if (b.owner !== currentUser.username && isColliding(b, getLocalFighter())) {
          getLocalFighter().hp = Math.max(0, getLocalFighter().hp - 10);
          hitSound.currentTime = 0;
          hitSound.play();
          // При попадании увеличиваем счёт
          score++;
          deleteBullet(id);
        }
      }
    }
    
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    
    function deleteBullet(id) {
      db.ref("rooms/" + roomID + "/bullets/" + id).remove();
      delete bullets[id];
    }
    
    // Слушаем пули из Firebase
    function listenToBullets() {
      const bulletsRef = db.ref("rooms/" + roomID + "/bullets");
      bulletsRef.on("child_added", snapshot => {
        const bullet = snapshot.val();
        bullet.id = snapshot.key;
        bullets[bullet.id] = bullet;
      });
      bulletsRef.on("child_removed", snapshot => {
        const bid = snapshot.key;
        if (bullets[bid]) delete bullets[bid];
      });
    }
    
    // Синхронизация локального состояния бойца в Firebase
    function syncLocalState() {
      const localFighter = getLocalFighter();
      db.ref("rooms/" + roomID + "/players/" + currentUser.username).update({
        x: localFighter.x,
        y: localFighter.y,
        hp: localFighter.hp,
        bullets: localFighter.bullets,
        onGround: localFighter.onGround,
        timestamp: Date.now()
      });
    }
    
    // Слушаем обновления состояния игроков
    function listenToPlayers() {
      db.ref("rooms/" + roomID + "/players").on("value", snapshot => {
        const players = snapshot.val();
        for (let uname in players) {
          if (uname !== currentUser.username) {
            remoteUsername = uname;
            const remoteData = players[uname];
            if (isHost) {
              fighter2.x = remoteData.x;
              fighter2.y = remoteData.y;
              fighter2.hp = remoteData.hp;
              fighter2.bullets = remoteData.bullets;
              fighter2.onGround = remoteData.onGround;
            } else {
              fighter1.x = remoteData.x;
              fighter1.y = remoteData.y;
              fighter1.hp = remoteData.hp;
              fighter1.bullets = remoteData.bullets;
              fighter1.onGround = remoteData.onGround;
            }
          }
        }
      });
    }
    
    // Обновление удалённого игрока (при попадании)
    function updateRemotePlayer(username, fighterState) {
      if (username) {
        db.ref("rooms/" + roomID + "/players/" + username).update({
          hp: fighterState.hp
        });
      }
    }
    
    // Рендеринг игрового поля
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Рендерим левого бойца с изображением (fighter1)
      if (leftFighterImg.complete) {
        ctx.drawImage(leftFighterImg, fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      } else {
        ctx.fillStyle = fighter1.color;
        ctx.fillRect(fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      }
      // Рендерим правого бойца с изображением (fighter2)
      if (rightFighterImg.complete) {
        ctx.drawImage(rightFighterImg, fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      } else {
        ctx.fillStyle = fighter2.color;
        ctx.fillRect(fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      }
      
      // Рендер пуль
      ctx.fillStyle = "#fff";
      for (let id in bullets) {
        const b = bullets[id];
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      
      // Отрисовка юзернеймов и XP (XP вместо HP) над бойцами и информации о пулях под ними
      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      if (isHost) {
        ctx.fillText(currentUser.username, fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets + (fighter1.bullets === 0 ? " (Reloading…)" : ""), fighter1.x, fighter1.y + fighter1.height + 15);
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
      } else {
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
        ctx.fillText(currentUser.username, fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets + (fighter2.bullets === 0 ? " (Reloading…)" : ""), fighter2.x, fighter2.y + fighter2.height + 15);
      }
      // Дополнительное улучшение: вывод счёта (score)
      ctx.fillStyle = "#ff0";
      ctx.font = "16px Arial";
      ctx.fillText("Score: " + score, 140, 30);
    }
    
    // Игровой цикл
    let gameLoopId;
    function gameLoop() {
      updateLocalFighter();
      syncLocalState();
      updateBullets();
      renderGame();
      
      // Завершаем игру, если у одного из игроков XP <= 0
      const localXP = getLocalFighter().hp;
      const remoteXP = getRemoteFighter().hp;
      if (localXP <= 0 || remoteXP <= 0) {
        let result = (localXP > 0) ? "Вы выиграли!" : "Вы проиграли!";
        updateStats(result);
        playGameOverSound();
        showGameOverCountdown(result);
        if (isHost) {
          db.ref("rooms/" + roomID).remove();
        }
        cancelAnimationFrame(gameLoopId);
        return;
      }
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Запуск игры: скрываем лобби и прочие элементы, показываем игровой экран; блокируем прокрутку
    function startShooterGame() {
      document.getElementById('waitingRoomSection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'none';
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('gameSection').style.display = 'flex';
      document.getElementById('topBar').style.display = 'none';
      document.body.style.overflow = 'hidden';
      listenToPlayers();
      listenToBullets();
      checkOrientation(initShooterGame);
      document.getElementById('gameSection').addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
    }
    
    function initShooterGame() {
      const localFighter = getLocalFighter();
      if (isHost) {
        fighter1.x = 50; fighter1.y = groundLevel; fighter1.hp = 100;
        fighter1.bullets = 3; fighter1.vy = 0; fighter1.onGround = true;
      } else {
        fighter2.x = canvas.width - 100; fighter2.y = groundLevel; fighter2.hp = 100;
        fighter2.bullets = 3; fighter2.vy = 0; fighter2.onGround = true;
      }
      // Обнуляем счёт
      score = 0;
      bullets = {};
      gameLoop();
    }
    
    // Синхронизация локального состояния в Firebase
    function syncLocalState() {
      const localFighter = getLocalFighter();
      db.ref("rooms/" + roomID + "/players/" + currentUser.username).update({
        x: localFighter.x,
        y: localFighter.y,
        hp: localFighter.hp,
        bullets: localFighter.bullets,
        onGround: localFighter.onGround,
        timestamp: Date.now()
      });
    }
    
    // Слушаем обновления состояния игроков
    function listenToPlayers() {
      db.ref("rooms/" + roomID + "/players").on("value", snapshot => {
        const players = snapshot.val();
        for (let uname in players) {
          if (uname !== currentUser.username) {
            remoteUsername = uname;
            const remoteData = players[uname];
            if (isHost) {
              fighter2.x = remoteData.x;
              fighter2.y = remoteData.y;
              fighter2.hp = remoteData.hp;
              fighter2.bullets = remoteData.bullets;
              fighter2.onGround = remoteData.onGround;
            } else {
              fighter1.x = remoteData.x;
              fighter1.y = remoteData.y;
              fighter1.hp = remoteData.hp;
              fighter1.bullets = remoteData.bullets;
              fighter1.onGround = remoteData.onGround;
            }
          }
        }
      });
    }
    
    // Обновляем удалённого игрока (например, при попадании)
    function updateRemotePlayer(username, fighterState) {
      if (username) {
        db.ref("rooms/" + roomID + "/players/" + username).update({
          hp: fighterState.hp
        });
      }
    }
    
    // Дополнительное улучшение: при попадании увеличиваем счёт (score)
    // (Вызов этой логики происходит в updateBullets)
    
    // Рендер игрового поля
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Рисуем бойца слева (fighter1) с изображением
      if (leftFighterImg.complete) {
        ctx.drawImage(leftFighterImg, fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      } else {
        ctx.fillStyle = fighter1.color;
        ctx.fillRect(fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      }
      
      // Рисуем бойца справа (fighter2) с изображением
      if (rightFighterImg.complete) {
        ctx.drawImage(rightFighterImg, fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      } else {
        ctx.fillStyle = fighter2.color;
        ctx.fillRect(fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      }
      
      // Рисуем пули
      ctx.fillStyle = "#fff";
      for (let id in bullets) {
        const b = bullets[id];
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      
      // Рендер информации: имя игрока (без "@"), XP и количество пуль.
      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      if (isHost) {
        ctx.fillText(currentUser.username, fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets + (fighter1.bullets === 0 ? " (Reloading…)" : ""), fighter1.x, fighter1.y + fighter1.height + 15);
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
      } else {
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
        ctx.fillText(currentUser.username, fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets + (fighter2.bullets === 0 ? " (Reloading…)" : ""), fighter2.x, fighter2.y + fighter2.height + 15);
      }
      // Отображение счёта (score) в верхней части поля
      ctx.fillStyle = "#ff0";
      ctx.font = "16px Arial";
      ctx.fillText("Score: " + score, 140, 30);
    }
    
    // Игровой цикл: обновляем состояние, синхронизируем, рендерим
    let gameLoopId;
    function gameLoop() {
      updateLocalFighter();
      syncLocalState();
      updateBullets();
      renderGame();
      const localXP = getLocalFighter().hp;
      const remoteXP = getRemoteFighter().hp;
      if (localXP <= 0 || remoteXP <= 0) {
        let result = (localXP > 0) ? "Вы выиграли!" : "Вы проиграли!";
        updateStats(result);
        playGameOverSound();
        showGameOverCountdown(result);
        if (isHost) {
          db.ref("rooms/" + roomID).remove();
        }
        cancelAnimationFrame(gameLoopId);
        return;
      }
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Запуск игры: скрываем лобби, показываем игровой экран, скрываем топ-бар, блокируем прокрутку
    function startShooterGame() {
      document.getElementById('waitingRoomSection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'none';
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('gameSection').style.display = 'flex';
      document.getElementById('topBar').style.display = 'none';
      document.body.style.overflow = 'hidden';
      listenToPlayers();
      listenToBullets();
      checkOrientation(initShooterGame);
      document.getElementById('gameSection').addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
    }
    
    function initShooterGame() {
      const localFighter = getLocalFighter();
      if (isHost) {
        fighter1.x = 50; fighter1.y = groundLevel; fighter1.hp = 100;
        fighter1.bullets = 3; fighter1.vy = 0; fighter1.onGround = true;
      } else {
        fighter2.x = canvas.width - 100; fighter2.y = groundLevel; fighter2.hp = 100;
        fighter2.bullets = 3; fighter2.vy = 0; fighter2.onGround = true;
      }
      score = 0;
      bullets = {};
      gameLoop();
    }
    
    // Синхронизация локального состояния в Firebase
    function syncLocalState() {
      const localFighter = getLocalFighter();
      db.ref("rooms/" + roomID + "/players/" + currentUser.username).update({
        x: localFighter.x,
        y: localFighter.y,
        hp: localFighter.hp,
        bullets: localFighter.bullets,
        onGround: localFighter.onGround,
        timestamp: Date.now()
      });
    }
    
    // Слушаем обновления состояния игроков
    function listenToPlayers() {
      db.ref("rooms/" + roomID + "/players").on("value", snapshot => {
        const players = snapshot.val();
        for (let uname in players) {
          if (uname !== currentUser.username) {
            remoteUsername = uname;
            const remoteData = players[uname];
            if (isHost) {
              fighter2.x = remoteData.x;
              fighter2.y = remoteData.y;
              fighter2.hp = remoteData.hp;
              fighter2.bullets = remoteData.bullets;
              fighter2.onGround = remoteData.onGround;
            } else {
              fighter1.x = remoteData.x;
              fighter1.y = remoteData.y;
              fighter1.hp = remoteData.hp;
              fighter1.bullets = remoteData.bullets;
              fighter1.onGround = remoteData.onGround;
            }
          }
        }
      });
    }
    
    // Обновление удалённого игрока (при попадании)
    function updateRemotePlayer(username, fighterState) {
      if (username) {
        db.ref("rooms/" + roomID + "/players/" + username).update({
          hp: fighterState.hp
        });
      }
    }
    
    // Дополнительное улучшение: при попадании увеличиваем счёт (score)
    // (вызов происходит в updateBullets)
    
    // Рендер игрового поля: отрисовка изображений, пуль, информации о бойцах и счёта
    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (leftFighterImg.complete) {
        ctx.drawImage(leftFighterImg, fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      } else {
        ctx.fillStyle = fighter1.color;
        ctx.fillRect(fighter1.x, fighter1.y, fighter1.width, fighter1.height);
      }
      if (rightFighterImg.complete) {
        ctx.drawImage(rightFighterImg, fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      } else {
        ctx.fillStyle = fighter2.color;
        ctx.fillRect(fighter2.x, fighter2.y, fighter2.width, fighter2.height);
      }
      ctx.fillStyle = "#fff";
      for (let id in bullets) {
        const b = bullets[id];
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      // Информация о игроках: имя, XP и количество пуль
      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      if (isHost) {
        ctx.fillText(currentUser.username, fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets + (fighter1.bullets === 0 ? " (Reloading…)" : ""), fighter1.x, fighter1.y + fighter1.height + 15);
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets, fighter2.x, fighter2.y + fighter2.height + 15);
      } else {
        ctx.fillText(remoteUsername ? remoteUsername : "Waiting", fighter1.x, fighter1.y - 20);
        ctx.fillText("XP: " + fighter1.hp, fighter1.x, fighter1.y - 5);
        ctx.fillText("Пули: " + fighter1.bullets, fighter1.x, fighter1.y + fighter1.height + 15);
        ctx.fillText(currentUser.username, fighter2.x, fighter2.y - 20);
        ctx.fillText("XP: " + fighter2.hp, fighter2.x, fighter2.y - 5);
        ctx.fillText("Пули: " + fighter2.bullets + (fighter2.bullets === 0 ? " (Reloading…)" : ""), fighter2.x, fighter2.y + fighter2.height + 15);
      }
      // Вывод счёта
      ctx.fillStyle = "#ff0";
      ctx.font = "16px Arial";
      ctx.fillText("Score: " + score, 140, 30);
    }
    
    // Игровой цикл: обновление состояния, синхронизация, рендеринг
    let gameLoopId;
    function gameLoop() {
      updateLocalFighter();
      syncLocalState();
      updateBullets();
      renderGame();
      const localXP = getLocalFighter().hp;
      const remoteXP = getRemoteFighter().hp;
      if (localXP <= 0 || remoteXP <= 0) {
        let result = (localXP > 0) ? "Вы выиграли!" : "Вы проиграли!";
        updateStats(result);
        playGameOverSound();
        showGameOverCountdown(result);
        if (isHost) {
          db.ref("rooms/" + roomID).remove();
        }
        cancelAnimationFrame(gameLoopId);
        return;
      }
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    function startShooterGame() {
      document.getElementById('waitingRoomSection').style.display = 'none';
      document.getElementById('roomListSection').style.display = 'none';
      document.getElementById('lobbySection').style.display = 'none';
      document.getElementById('gameSection').style.display = 'flex';
      // Скрываем верхний бар
      document.getElementById('topBar').style.display = 'none';
      document.body.style.overflow = 'hidden';
      listenToPlayers();
      listenToBullets();
      checkOrientation(initShooterGame);
      document.getElementById('gameSection').addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
    }
    
    function initShooterGame() {
      const localFighter = getLocalFighter();
      if (isHost) {
        fighter1.x = 50; fighter1.y = groundLevel; fighter1.hp = 100;
        fighter1.bullets = 3; fighter1.vy = 0; fighter1.onGround = true;
      } else {
        fighter2.x = canvas.width - 100; fighter2.y = groundLevel; fighter2.hp = 100;
        fighter2.bullets = 3; fighter2.vy = 0; fighter2.onGround = true;
      }
      score = 0;
      bullets = {};
      gameLoop();
    }
    
    /********************************************************************
     * 5. Кастомное модальное окно для уведомлений и обратного отсчёта
     ********************************************************************/
    function showCustomModal(title, message, callback) {
      document.getElementById('customModalTitle').innerText = title;
      document.getElementById('customModalMessage').innerText = message;
      document.getElementById('customModalBackdrop').style.display = 'flex';
      document.getElementById('customModalBtn').onclick = function() {
        document.getElementById('customModalBackdrop').style.display = 'none';
        if (callback) callback();
      };
    }
    
    function showGameOverCountdown(result) {
      let countdown = 5;
      showCustomModal("Game Over", "Результат: " + result + "\nВозвращение в лобби через " + countdown + " секунд", () => {});
      const intervalId = setInterval(() => {
        countdown--;
        document.getElementById('customModalMessage').innerText = "Результат: " + result + "\nВозвращение в лобби через " + countdown + " секунд";
        if (countdown <= 0) {
          clearInterval(intervalId);
          // Возвращаемся в лобби, восстанавливаем верхний бар и прокрутку
          document.getElementById('gameSection').style.display = 'none';
          document.getElementById('lobbySection').style.display = 'block';
          document.getElementById('topBar').style.display = 'block';
          document.body.style.overflow = 'auto';
        }
      }, 1000);
    }
    
    /********************************************************************
     * 6. Статистика игр: сохранение результатов дуэлей
     ********************************************************************/
    function updateStats(result) {
      const statsRef = db.ref("stats/" + currentUser.username);
      statsRef.once("value").then(snapshot => {
        let stats = snapshot.val() || { wins: 0, losses: 0, points: 0 };
        if(result === "Вы выиграли!") {
          stats.wins++;
        } else {
          stats.losses++;
        }
        stats.points += localUserData.points;
        statsRef.set(stats);
      });
    }
    
    /********************************************************************
     * 7. Дополнительные улучшения:
     *    - Звуковые эффекты: прыжок, выстрел, попадание, конец игры.
     *    - Счёт (score): увеличивается при попадании по противнику.
     *    - Визуальный индикатор перезарядки (выводится текст "Reloading…" под пулями).
     *    - Полноэкранный режим: запрос через Telegram.
     *    - Блокировка лишних жестов: масштабирование и скроллинг отключаются в режиме игры.
     ********************************************************************/
    const jumpSound = new Audio("https://actions.google.com/sounds/v1/cartoon/boing.ogg");
    const shootSound = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    const hitSound = new Audio("https://actions.google.com/sounds/v1/cartoon/pop.ogg");
    const gameOverSound = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    
    function playGameOverSound() {
      gameOverSound.currentTime = 0;
      gameOverSound.play();
    }
    
    /********************************************************************
     * 8. Запрос полноэкранного режима (если Telegram не сделал это автоматически)
     ********************************************************************/
    if (window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.requestFullscreen === 'function') {
      Telegram.WebApp.requestFullscreen();
    }
    
    /********************************************************************
     * 9. Блокировка жестов: предотвращаем масштабирование и скроллинг в режиме игры
     ********************************************************************/
    document.addEventListener('touchmove', function(event) {
      if (document.getElementById('gameSection').style.display === 'flex') {
        event.preventDefault();
      }
    }, { passive: false });
    
  </script>
</body>
</html>
