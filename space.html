<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- For mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crossy Road 3D Vertical with Menu and Timer</title>

  <!-- 8-bit style font: Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    /* Overall reset */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #00103c;
      font-family: 'Press Start 2P', monospace;
    }

    /* Header (user info) */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      font-size: 10px;
      color: #fff;
      align-items: center;
    }
    #info span {
      white-space: nowrap;
    }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img {
      width: 16px;
      height: 16px;
    }

    /* "BACK" button */
    #backContainer {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

    /* Main game wrapper */
    #gameWrapper {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* START button in the center */
    #startBtn {
      position: absolute;
      z-index: 1100;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px; /* bigger font */
      padding: 15px 30px; /* bigger button */
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

    /* Time bar - hidden by default, shown after start */
    #timeBarContainer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 5px;
      background: #555;
      z-index: 1100;
      display: none; /* hidden initially */
    }
    #timeBar {
      width: 100%;
      height: 100%;
      background: #ff66cc;
    }

    /* Score counter (lanes crossed) */
    #counter {
      position: absolute;
      top: 40px;
      right: 20px;
      z-index: 1000;
      color: #ffffff;
      font-size: 12px;
    }

    /* Game controls - hidden by default */
    #controlls {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 1100;
    }
    #controlls div {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
      margin-bottom: 20px;
      grid-template-areas:
        ". forward ."
        "left . right"
        ". backward .";
    }
    #forward { grid-area: forward; }
    #left { grid-area: left; }
    #backward { grid-area: backward; }
    #right { grid-area: right; }
    #controlls button {
      background: black;
      border: 1px solid white;
      box-shadow: 3px 5px 0 rgba(0, 0, 0, 0.75);
      cursor: pointer;
    }
    #controlls button svg path {
      fill: white;
    }

    /* End modal (Game Over / No Tickets) */
    #end {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;
      z-index: 1200;
      background: rgba(0,0,0,0.7);
    }
    #end .modal {
      background: #222;
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 400px;
      text-align: center;
      color: #FF00FF;
      font-size: 14px;
    }
    #end .modal button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

    /* Three.js canvas - behind the UI */
    canvas {
      position: absolute;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Header with user info -->
  <div id="header">
    <div id="info">
      <span id="username">@User</span>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Tickets">
        <span id="ticketCount">0</span>
      </div>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
        <span id="pointCount">0</span>
      </div>
    </div>
  </div>

  <!-- Time bar (hidden initially) -->
  <div id="timeBarContainer">
    <div id="timeBar"></div>
  </div>

  <!-- BACK button -->
  <div id="backContainer">
    <button id="backBtn" onclick="goBack()">BACK</button>
  </div>

  <!-- Game wrapper (menu + Three.js) -->
  <div id="gameWrapper">
    <button id="startBtn" onclick="startGame()">START (1 Ticket)</button>
  </div>

  <!-- Score counter -->
  <div id="counter">0</div>

  <!-- Controls (hidden initially) -->
  <div id="controlls">
    <div>
      <button id="forward">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(0,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
      <button id="left">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(-90,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
      <button id="backward">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(180,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
      <button id="right">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(90,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
    </div>
  </div>

  <!-- End modal (Game Over / No Tickets) -->
  <div id="end">
    <div class="modal">
      <h2 id="endTitle"></h2>
      <p id="endMessage"></p>
      <button id="endBtn">OK</button>
    </div>
  </div>

  <!-- Sounds -->
  <audio id="bgSound" src="background.mp3" loop></audio>
  <audio id="moveSound" src="move.mp3"></audio>
  <audio id="deathSound" src="death.mp3"></audio>

  <script>
    /* --------------------------------------------------------
       1. Firebase & Telegram initialization
    -------------------------------------------------------- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let tg = null;
    if (window.Telegram && window.Telegram.WebApp) {
      tg = window.Telegram.WebApp;
      tg.expand();
    }

    let currentUser = null;
    let userRef = null;
    let localUserData = { tickets: 0, points: 0 };
    // Data loaded flag
    let dataLoaded = false;
    setTimeout(() => { dataLoaded = true; }, 3000);

    if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
      currentUser = tg.initDataUnsafe.user;
      document.getElementById('username').textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    } else {
      // Fallback if Telegram not available
      currentUser = { username: 'TestUser' };
      document.getElementById('username').textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    }

    function updateHeader() {
      document.getElementById('ticketCount').textContent = localUserData.tickets;
      document.getElementById('pointCount').textContent = localUserData.points;
    }

    function goBack() {
      window.location.href = 'index.html';
    }

    // End modal button
    let modalType = "gameOver";
    document.getElementById('endBtn').addEventListener('click', function() {
      if (modalType === "gameOver") {
        goToIndex();
      } else if (modalType === "noTickets") {
        document.getElementById('end').style.visibility = 'hidden';
      }
    });
    function goToIndex() {
      window.location.href = 'index.html';
    }

    /* --------------------------------------------------------
       2. Game code (3D Crossy Road style)
    -------------------------------------------------------- */
    let scene, camera, renderer;
    let cameraOffset = { x: 0, y: -400, z: 600 };
    let zoom = 2;
    let chicken, lanes, currentLane, currentColumn;
    let previousTimestamp, startMoving, moves, stepStartTimestamp;
    const stepTime = 200;
    const chickenSize = 15;
    const positionWidth = 42;
    const columns = 17;
    const boardWidth = positionWidth * columns;
    const laneTypes = ['car', 'truck', 'forest'];
    const laneSpeeds = [2, 2.5, 3];
    // Bright colors for vehicles
    const vehicleColors = [0xff5722, 0xffc107, 0x03a9f4, 0x9c27b0, 0x8bc34a, 0xf44336];
    // For random tree heights
    const treeHeights = [20, 45, 60];
    let gameEnded = false;

    // 5-minute timer
    let gameStartTime = null;
    const gameDuration = 300000; // 5 minutes

    // Initialize game
    function initGame() {
      gameEnded = false;
      scene = new THREE.Scene();

      // Perspective camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // Lights
      // Hemisphere (sky) light - very soft
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.25);
      hemiLight.position.set(0, 0, 1000);
      scene.add(hemiLight);

      // Main directional light for shadows
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(cameraOffset.x, cameraOffset.y + 200, cameraOffset.z + 200);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.left = -300;
      dirLight.shadow.camera.right = 300;
      dirLight.shadow.camera.top = 300;
      dirLight.shadow.camera.bottom = -300;
      dirLight.shadow.bias = -0.0003;
      scene.add(dirLight);

      // Additional mild backlight
      const backLight = new THREE.DirectionalLight(0xffffff, 0.15);
      backLight.position.set(200, 200, 300);
      backLight.castShadow = false;
      scene.add(backLight);

      lanes = generateInitialLanes();
      currentLane = 0;
      currentColumn = Math.floor(columns / 2);
      previousTimestamp = null;
      startMoving = false;
      moves = [];
      stepStartTimestamp = null;

      // Create the chicken
      chicken = createChicken();
      chicken.position.set(0, 0, 0);
      scene.add(chicken);
    }

    // Initialize renderer with shadows
    function initRenderer() {
      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x000000, 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('gameWrapper').appendChild(renderer.domElement);
    }

    /* ------------------------------
       2.1. Blocky geometry
    ------------------------------ */

    // Blocky Car
    function createBlockyCar(color = 0xff0000) {
      const group = new THREE.Group();
      // Body
      const bodyGeom = new THREE.BoxGeometry(60 * zoom, 30 * zoom, 15 * zoom);
      const bodyMat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.castShadow = true;
      body.receiveShadow = true;
      body.position.z = 10 * zoom; // raise a bit
      group.add(body);

      // Cabin
      const cabinGeom = new THREE.BoxGeometry(30 * zoom, 25 * zoom, 15 * zoom);
      const cabinMat = new THREE.MeshLambertMaterial({ color: 0xffffff, flatShading: true });
      const cabin = new THREE.Mesh(cabinGeom, cabinMat);
      cabin.castShadow = true;
      cabin.receiveShadow = true;
      cabin.position.z = 25 * zoom;
      group.add(cabin);

      // Wheels (as cubes)
      const wheelGeom = new THREE.BoxGeometry(10 * zoom, 10 * zoom, 10 * zoom);
      const wheelMat = new THREE.MeshLambertMaterial({ color: 0x333333, flatShading: true });
      // 4 wheels
      const positions = [
        [-20, 15, 5],  // front-left
        [ 20, 15, 5],  // front-right
        [-20,-15, 5],  // back-left
        [ 20,-15, 5]   // back-right
      ];
      positions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeom, wheelMat);
        wheel.position.set(pos[0] * zoom, pos[1] * zoom, pos[2] * zoom);
        wheel.castShadow = true;
        group.add(wheel);
      });

      return group;
    }

    // Blocky Truck
    function createBlockyTruck(color = 0xff5722) {
      const group = new THREE.Group();

      // Base
      const baseGeom = new THREE.BoxGeometry(100 * zoom, 30 * zoom, 15 * zoom);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0xb4c6fc, flatShading: true });
      const base = new THREE.Mesh(baseGeom, baseMat);
      base.castShadow = true;
      base.receiveShadow = true;
      base.position.z = 10 * zoom;
      group.add(base);

      // Cargo
      const cargoGeom = new THREE.BoxGeometry(75 * zoom, 40 * zoom, 40 * zoom);
      const cargoMat = new THREE.MeshLambertMaterial({ color: 0xb4c6fc, flatShading: true });
      const cargo = new THREE.Mesh(cargoGeom, cargoMat);
      cargo.castShadow = true;
      cargo.receiveShadow = true;
      cargo.position.x = 10 * zoom;
      cargo.position.z = 35 * zoom;
      group.add(cargo);

      // Cabin
      const cabinGeom = new THREE.BoxGeometry(25 * zoom, 30 * zoom, 30 * zoom);
      const cabinMat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const cabin = new THREE.Mesh(cabinGeom, cabinMat);
      cabin.castShadow = true;
      cabin.receiveShadow = true;
      cabin.position.x = -35 * zoom;
      cabin.position.z = 25 * zoom;
      group.add(cabin);

      // Wheels (cubes)
      const wheelGeom = new THREE.BoxGeometry(10 * zoom, 10 * zoom, 10 * zoom);
      const wheelMat = new THREE.MeshLambertMaterial({ color: 0x333333, flatShading: true });
      const positions = [
        [-30, 15, 5],
        [-30,-15, 5],
        [  0, 15, 5],
        [  0,-15, 5],
        [ 30, 15, 5],
        [ 30,-15, 5],
      ];
      positions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeom, wheelMat);
        wheel.position.set(pos[0] * zoom, pos[1] * zoom, pos[2] * zoom);
        wheel.castShadow = true;
        group.add(wheel);
      });

      return group;
    }

    // Blocky Tree
    function createBlockyTree() {
      const group = new THREE.Group();
      // Trunk
      const trunkGeom = new THREE.BoxGeometry(15 * zoom, 15 * zoom, 20 * zoom);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4d2926, flatShading: true });
      const trunk = new THREE.Mesh(trunkGeom, trunkMat);
      trunk.position.z = 10 * zoom;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      group.add(trunk);

      // Crown (1-2 cubes)
      const height = treeHeights[Math.floor(Math.random() * treeHeights.length)];
      const crownGeom = new THREE.BoxGeometry(30 * zoom, 30 * zoom, height * zoom);
      const crownMat = new THREE.MeshLambertMaterial({ color: 0x7aa21d, flatShading: true });
      const crown = new THREE.Mesh(crownGeom, crownMat);
      crown.position.z = (height / 2 + 20) * zoom;
      crown.castShadow = true;
      group.add(crown);

      return group;
    }

    // Blocky Chicken
    function createChicken() {
      const group = new THREE.Group();

      // Body
      const bodyGeom = new THREE.BoxGeometry(chickenSize * zoom, chickenSize * zoom, 20 * zoom);
      const bodyMat = new THREE.MeshLambertMaterial({ color: 0xffffff, flatShading: true });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.castShadow = true;
      body.receiveShadow = true;
      body.position.z = 10 * zoom;
      group.add(body);

      // Comb (small red cube)
      const combGeom = new THREE.BoxGeometry(5 * zoom, 5 * zoom, 5 * zoom);
      const combMat = new THREE.MeshLambertMaterial({ color: 0xf0619a, flatShading: true });
      const comb = new THREE.Mesh(combGeom, combMat);
      comb.castShadow = true;
      comb.position.z = 20 * zoom;
      group.add(comb);

      return group;
    }

    /* ------------------------------
       2.2. Lane generation
    ------------------------------ */
    function generateInitialLanes() {
      // from -9..9, but only keep >=0 in array
      return [-9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        .map(i => {
          const lane = new Lane(i);
          lane.mesh.position.y = i * positionWidth * zoom;
          scene.add(lane.mesh);
          return lane;
        })
        .filter(lane => lane.index >= 0);
    }

    function addLane() {
      const index = lanes.length;
      const lane = new Lane(index);
      lane.mesh.position.y = index * positionWidth * zoom;
      scene.add(lane.mesh);
      lanes.push(lane);
    }

    // Lane object
    function Lane(index) {
      this.index = index;
      this.type = index <= 0 ? 'field' : laneTypes[Math.floor(Math.random() * laneTypes.length)];

      switch (this.type) {
        case 'field':
          this.type = 'field';
          this.mesh = createGrass();
          break;

        case 'forest':
          this.mesh = createGrass();
          this.occupiedPositions = new Set();
          // place some trees
          for (let i = 0; i < 4; i++) {
            let position;
            do {
              position = Math.floor(Math.random() * columns);
            } while (this.occupiedPositions.has(position));
            this.occupiedPositions.add(position);
            const tree = createBlockyTree();
            tree.position.x = (position * positionWidth + positionWidth / 2) * zoom - boardWidth * zoom / 2;
            this.mesh.add(tree);
          }
          break;

        case 'car':
        case 'truck':
          this.mesh = createRoad();
          this.direction = Math.random() >= 0.5;
          const occupiedPositions = new Set();
          const count = (this.type === 'car') ? 3 : 2;
          this.vehicles = [];
          for (let i = 0; i < count; i++) {
            let pos;
            do {
              // to avoid overlapping, pick from a portion of columns
              pos = Math.floor(Math.random() * (columns / (this.type === 'car' ? 2 : 3)));
            } while (occupiedPositions.has(pos));
            occupiedPositions.add(pos);

            let vehicle;
            if (this.type === 'car') {
              vehicle = createBlockyCar(vehicleColors[Math.floor(Math.random() * vehicleColors.length)]);
            } else {
              vehicle = createBlockyTruck(vehicleColors[Math.floor(Math.random() * vehicleColors.length)]);
            }
            vehicle.position.x = (pos * positionWidth * (this.type === 'car' ? 2 : 3) + positionWidth / 2) * zoom - boardWidth * zoom / 2;
            if (!this.direction) vehicle.rotation.z = Math.PI;
            this.mesh.add(vehicle);
            this.vehicles.push(vehicle);
          }
          this.speed = laneSpeeds[Math.floor(Math.random() * laneSpeeds.length)];
          break;
      }
    }

    // Road (dark gray)
    function createRoad() {
      const group = new THREE.Group();
      const geometry = new THREE.PlaneBufferGeometry(boardWidth * zoom, positionWidth * zoom);
      const material = new THREE.MeshLambertMaterial({ color: 0x454A59, flatShading: true });
      const plane = new THREE.Mesh(geometry, material);
      plane.rotation.x = -Math.PI / 2;
      plane.receiveShadow = true;
      group.add(plane);
      return group;
    }

    // Grass (green)
    function createGrass() {
      const group = new THREE.Group();
      const geometry = new THREE.BoxBufferGeometry(boardWidth * zoom, positionWidth * zoom, 3 * zoom);
      const material = new THREE.MeshLambertMaterial({ color: 0x8bc34a, flatShading: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.receiveShadow = true;
      mesh.position.z = 1.5 * zoom;
      group.add(mesh);
      return group;
    }

    /* ------------------------------
       2.3. Movement & collisions
    ------------------------------ */
    const moveSound = document.getElementById('moveSound');
    document.getElementById('forward').addEventListener("click", () => moveChicken('forward'));
    document.getElementById('backward').addEventListener("click", () => moveChicken('backward'));
    document.getElementById('left').addEventListener("click", () => moveChicken('left'));
    document.getElementById('right').addEventListener("click", () => moveChicken('right'));

    function moveChicken(direction) {
      moveSound.currentTime = 0;
      moveSound.play().catch(err => console.log(err));

      const finalPos = moves.reduce((pos, move) => {
        if (move === 'forward') return { lane: pos.lane + 1, column: pos.column };
        if (move === 'backward') return { lane: pos.lane - 1, column: pos.column };
        if (move === 'left') return { lane: pos.lane, column: pos.column - 1 };
        if (move === 'right') return { lane: pos.lane, column: pos.column + 1 };
      }, { lane: currentLane, column: currentColumn });

      if (direction === 'forward') {
        if (lanes[finalPos.lane + 1] && lanes[finalPos.lane + 1].type === 'forest'
            && lanes[finalPos.lane + 1].occupiedPositions
            && lanes[finalPos.lane + 1].occupiedPositions.has(finalPos.column)) return;
        if (!stepStartTimestamp) startMoving = true;
        addLane();
      } else if (direction === 'backward') {
        if (finalPos.lane === 0) return;
        if (lanes[finalPos.lane - 1] && lanes[finalPos.lane - 1].type === 'forest'
            && lanes[finalPos.lane - 1].occupiedPositions.has(finalPos.column)) return;
        if (!stepStartTimestamp) startMoving = true;
      } else if (direction === 'left') {
        if (finalPos.column === 0) return;
        if (lanes[finalPos.lane].type === 'forest'
            && lanes[finalPos.lane].occupiedPositions.has(finalPos.column - 1)) return;
        if (!stepStartTimestamp) startMoving = true;
      } else if (direction === 'right') {
        if (finalPos.column === columns - 1) return;
        if (lanes[finalPos.lane].type === 'forest'
            && lanes[finalPos.lane].occupiedPositions.has(finalPos.column + 1)) return;
        if (!stepStartTimestamp) startMoving = true;
      }

      moves.push(direction);
    }

    function cameraShake(duration = 500, intensity = 5) {
      const startTime = performance.now();
      const originalPos = camera.position.clone();
      function shake() {
        const elapsed = performance.now() - startTime;
        if (elapsed < duration) {
          camera.position.x = originalPos.x + (Math.random() - 0.5) * intensity;
          camera.position.y = originalPos.y + (Math.random() - 0.5) * intensity;
          requestAnimationFrame(shake);
        } else {
          camera.position.copy(originalPos);
        }
      }
      shake();
    }

    function spawnCollisionParticles() {
      const particleCount = 50;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      for (let i = 0; i < particleCount; i++) {
        positions.push(chicken.position.x, chicken.position.y, chicken.position.z);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xff66cc, size: 2, transparent: true });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      const startTime = performance.now();
      function animateParticles() {
        const elapsed = performance.now() - startTime;
        if (elapsed < 1000) {
          const arr = particles.geometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
            arr[i * 3] += (Math.random() - 0.5) * 2;
            arr[i * 3 + 1] += (Math.random() - 0.5) * 2;
            arr[i * 3 + 2] += (Math.random() - 0.5) * 2;
          }
          particles.geometry.attributes.position.needsUpdate = true;
          requestAnimationFrame(animateParticles);
        } else {
          scene.remove(particles);
          particles.geometry.dispose();
          particles.material.dispose();
        }
      }
      animateParticles();
    }

    function endGame() {
      if (gameEnded) return;
      gameEnded = true;
      document.getElementById('deathSound').play().catch(err => console.log(err));
      cameraShake();
      spawnCollisionParticles();

      setTimeout(() => {
        localUserData.points += currentLane;
        if (userRef) userRef.update({ points: localUserData.points });
        document.getElementById('controlls').style.display = 'none';
        modalType = "gameOver";
        document.getElementById('endTitle').textContent = 'GAME OVER!';
        document.getElementById('endMessage').textContent = 'Your Score: ' + currentLane;
        document.getElementById('end').style.visibility = 'visible';
      }, 600);
    }

    function showNoTicketsModal() {
      modalType = "noTickets";
      document.getElementById('endTitle').textContent = 'NOT ENOUGH TICKETS!';
      document.getElementById('endMessage').textContent = 'Please come back later.';
      document.getElementById('end').style.visibility = 'visible';
    }

    /* --------------------------------------------------------
       3. Main animation loop & timer
    -------------------------------------------------------- */
    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (!previousTimestamp) previousTimestamp = timestamp;
      const delta = timestamp - previousTimestamp;
      previousTimestamp = timestamp;

      // Timer update
      if (gameStartTime) {
        let elapsed = timestamp - gameStartTime;
        let remaining = gameDuration - elapsed;
        let timeBar = document.getElementById('timeBar');
        if (remaining <= 0) {
          timeBar.style.width = "0%";
          if (!gameEnded) {
            endGame();
          }
        } else {
          timeBar.style.width = (remaining / gameDuration * 100) + "%";
        }
      }

      // Move vehicles
      lanes.forEach(lane => {
        if (lane.type === 'car' || lane.type === 'truck') {
          const aBitBefore = -boardWidth * zoom / 2 - positionWidth * 2 * zoom;
          const aBitAfter  = boardWidth * zoom / 2 + positionWidth * 2 * zoom;
          lane.vehicles.forEach(vehicle => {
            if (lane.direction) {
              vehicle.position.x = (vehicle.position.x < aBitBefore)
                ? aBitAfter
                : vehicle.position.x - lane.speed / 16 * delta;
            } else {
              vehicle.position.x = (vehicle.position.x > aBitAfter)
                ? aBitBefore
                : vehicle.position.x + lane.speed / 16 * delta;
            }
          });
        }
      });

      // Chicken step animation
      if (startMoving) {
        stepStartTimestamp = timestamp;
        startMoving = false;
      }
      if (stepStartTimestamp) {
        const moveDeltaTime = timestamp - stepStartTimestamp;
        const progress = Math.min(moveDeltaTime / stepTime, 1);
        const moveDeltaDistance = progress * positionWidth * zoom;
        const jumpDeltaDistance = Math.sin(progress * Math.PI) * 8 * zoom;

        switch (moves[0]) {
          case 'forward': {
            const targetY = currentLane * positionWidth * zoom + moveDeltaDistance;
            chicken.position.y = targetY;
            chicken.position.z = jumpDeltaDistance;
            camera.position.y = chicken.position.y + cameraOffset.y;
            camera.position.x = chicken.position.x + cameraOffset.x;
            break;
          }
          case 'backward': {
            const targetY = currentLane * positionWidth * zoom - moveDeltaDistance;
            chicken.position.y = targetY;
            chicken.position.z = jumpDeltaDistance;
            camera.position.y = chicken.position.y + cameraOffset.y;
            camera.position.x = chicken.position.x + cameraOffset.x;
            break;
          }
          case 'left': {
            const targetX = (currentColumn * positionWidth + positionWidth / 2) * zoom - boardWidth * zoom / 2 - moveDeltaDistance;
            chicken.position.x = targetX;
            chicken.position.z = jumpDeltaDistance;
            camera.position.x = chicken.position.x + cameraOffset.x;
            camera.position.y = chicken.position.y + cameraOffset.y;
            break;
          }
          case 'right': {
            const targetX = (currentColumn * positionWidth + positionWidth / 2) * zoom - boardWidth * zoom / 2 + moveDeltaDistance;
            chicken.position.x = targetX;
            chicken.position.z = jumpDeltaDistance;
            camera.position.x = chicken.position.x + cameraOffset.x;
            camera.position.y = chicken.position.y + cameraOffset.y;
            break;
          }
        }

        if (moveDeltaTime > stepTime) {
          switch (moves[0]) {
            case 'forward': {
              currentLane++;
              document.getElementById('counter').textContent = currentLane;
              break;
            }
            case 'backward': {
              currentLane--;
              document.getElementById('counter').textContent = currentLane;
              break;
            }
            case 'left': {
              currentColumn--;
              break;
            }
            case 'right': {
              currentColumn++;
              break;
            }
          }
          moves.shift();
          stepStartTimestamp = moves.length === 0 ? null : timestamp;
        }
      }

      // Collision check
      if (lanes[currentLane] && (lanes[currentLane].type === 'car' || lanes[currentLane].type === 'truck')) {
        const chickenMinX = chicken.position.x - (chickenSize * zoom / 2);
        const chickenMaxX = chicken.position.x + (chickenSize * zoom / 2);
        const vehicleLength = (lanes[currentLane].type === 'car') ? 60 : 105;
        lanes[currentLane].vehicles.forEach(vehicle => {
          const vehicleMinX = vehicle.position.x - (vehicleLength * zoom / 2);
          const vehicleMaxX = vehicle.position.x + (vehicleLength * zoom / 2);
          if (chickenMaxX > vehicleMinX && chickenMinX < vehicleMaxX) {
            endGame();
          }
        });
      }

      camera.lookAt(chicken.position);
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    /* --------------------------------------------------------
       4. Start game function
    -------------------------------------------------------- */
    document.body.addEventListener('click', () => {
      const bgSound = document.getElementById('bgSound');
      if (bgSound.paused) {
        bgSound.play().catch(err => console.log(err));
      }
    }, { once: true });

    function startGame() {
      // If data not loaded or not enough tickets
      if (!dataLoaded || localUserData.tickets < 1) {
        showNoTicketsModal();
        return;
      }
      localUserData.tickets--;
      if (userRef) userRef.update({ tickets: localUserData.tickets });
      updateHeader();

      // Hide menu elements
      document.getElementById('header').style.display = 'none';
      document.getElementById('backContainer').style.display = 'none';
      document.getElementById('startBtn').style.display = 'none';

      // Show game area and controls
      document.getElementById('gameWrapper').style.display = 'block';
      document.getElementById('controlls').style.display = 'flex';

      // Show time bar
      document.getElementById('timeBarContainer').style.display = 'block';

      // Set game start time
      gameStartTime = performance.now();

      initGame();
      if (!renderer) {
        initRenderer();
      }
    }
  </script>
</body>
</html>

