<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <!-- Для мобильных устройств -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crossy Road 3D Vertical с меню и таймером</title>

  <!-- Font: Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Дополнительные скрипты для постобработки -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/SSAOPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

  <style>
    /* Общие стили */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #00103c;
      font-family: 'Press Start 2P', monospace;
    }
    /* Header с информацией о пользователе */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      font-size: 10px;
      color: #fff;
      align-items: center;
    }
    #info span {
      white-space: nowrap;
    }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img {
      width: 16px;
      height: 16px;
    }
    /* Кнопка Back */
    #backContainer {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Меню игры – изначально видимо */
    #gameWrapper {
      position: relative;
      width: 100%;
      height: 100%;
    }
    /* Кнопка Start – по центру меню */
    #startBtn {
      position: absolute;
      z-index: 1100;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      padding: 10px 20px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Временной индикатор - изначально скрыт, появляется после старта игры */
    #timeBarContainer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 5px;
      background: #555;
      z-index: 1100;
      display: none;
    }
    #timeBar {
      width: 100%;
      height: 100%;
      background: #ff66cc;
    }
    /* Игровой счётчик */
    #counter {
      position: absolute;
      top: 40px;
      right: 20px;
      z-index: 1000;
    }
    /* Контролы игры – изначально скрыты */
    #controlls {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 1100;
    }
    #controlls div {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
      margin-bottom: 20px;
      grid-template-areas:
        ". forward ."
        "left . right"
        ". backward .";
    }
    #forward { grid-area: forward; }
    #left { grid-area: left; }
    #backward { grid-area: backward; }
    #right { grid-area: right; }
    #controlls button {
      background: black;
      border: 1px solid white;
      box-shadow: 3px 5px 0 rgba(0, 0, 0, 0.75);
      cursor: pointer;
    }
    #controlls button svg path {
      fill: white;
    }
    /* Модальное окно для окончания игры/уведомлений */
    #end {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;
      z-index: 1200;
      background: rgba(0,0,0,0.7);
    }
    #end .modal {
      background: #222;
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 400px;
      text-align: center;
      color: #FF00FF;
      font-size: 14px;
    }
    #end .modal button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Canvas занимает весь экран, ниже контролов */
    canvas {
      position: absolute;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Меню с информацией о пользователе -->
  <div id="header">
    <div id="info">
      <span id="username">@User</span>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
        <span id="ticketCount">0</span>
      </div>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
        <span id="pointCount">0</span>
      </div>
    </div>
  </div>

  <!-- Временной индикатор (появится после старта игры) -->
  <div id="timeBarContainer">
    <div id="timeBar"></div>
  </div>

  <!-- Кнопка Back -->
  <div id="backContainer">
    <button id="backBtn" onclick="goBack()">Back</button>
  </div>

  <!-- Меню игры -->
  <div id="gameWrapper">
    <button id="startBtn" onclick="startGame()">Start (1 Ticket)</button>
    <!-- Здесь будет добавлен canvas Three.js после старта игры -->
  </div>

  <!-- Игровой счётчик и контролы (контролы изначально скрыты) -->
  <div id="counter">0</div>
  <div id="controlls">
    <div>
      <button id="forward">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(0,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
      <button id="left">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(-90,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
      <button id="backward">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(180,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
      <button id="right">
        <svg width="30" height="30" viewBox="0 0 10 10">
          <g transform="rotate(90,5,5)">
            <path d="M5,4 L7,6 L3,6 L5,4" />
          </g>
        </svg>
      </button>
    </div>
  </div>

  <!-- Модальное окно для окончания игры/уведомлений -->
  <div id="end">
    <div class="modal">
      <h2 id="endTitle"></h2>
      <p id="endMessage"></p>
      <button id="endBtn">OK</button>
    </div>
  </div>

  <!-- Звуки -->
  <audio id="bgSound" src="background.mp3" loop></audio>
  <audio id="moveSound" src="move.mp3"></audio>
  <audio id="deathSound" src="death.mp3"></audio>

  <script>
    /* ----------------------------------------
       1. Firebase и Telegram инициализация
    ---------------------------------------- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let tg = null;
    if (window.Telegram && window.Telegram.WebApp) {
      tg = window.Telegram.WebApp;
      tg.expand();
    }

    let currentUser = null;
    let userRef = null;
    let localUserData = { tickets: 0, points: 0 };
    // Флаг, что данные загружены
    let dataLoaded = false;
    // Если данные не загрузились в течение 3 секунд, dataLoaded станет true
    setTimeout(() => { dataLoaded = true; }, 3000);

    if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
      currentUser = tg.initDataUnsafe.user;
      document.getElementById('username').textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    } else {
      currentUser = { username: 'TestUser' };
      document.getElementById('username').textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    }

    function updateHeader() {
      document.getElementById('ticketCount').textContent = localUserData.tickets;
      document.getElementById('pointCount').textContent = localUserData.points;
    }

    function goBack() {
      window.location.href = 'index.html';
    }
    // Для случая Game Over, OK отправляет на index.html; для noTickets просто скрывает модал
    let modalType = "gameOver";
    document.getElementById('endBtn').addEventListener('click', function() {
      if (modalType === "gameOver") {
        goToIndex();
      } else if (modalType === "noTickets") {
        document.getElementById('end').style.visibility = 'hidden';
      }
    });
    function goToIndex() {
      window.location.href = 'index.html';
    }

    /* ----------------------------------------
       2. Игровой код (3D Crossy Road)
       Улучшены эффекты теней, материалы, а также добавлена постобработка и эффекты столкновений
    ---------------------------------------- */
    let scene, camera, renderer, composer;
    let cameraOffset = { x: 0, y: -400, z: 600 };
    let zoom = 2;
    let chicken, lanes, currentLane, currentColumn;
    let previousTimestamp, startMoving, moves, stepStartTimestamp;
    const stepTime = 200;
    const chickenSize = 15;
    const positionWidth = 42;
    const columns = 17;
    const boardWidth = positionWidth * columns;
    const laneTypes = ['car', 'truck', 'forest'];
    const laneSpeeds = [2, 2.5, 3];
    const vechicleColors = [0xa52523, 0xbdb638, 0x78b14b];
    const threeHeights = [20, 45, 60];
    let gameEnded = false;

    // Таймер игры (5 минут = 300000 мс)
    let gameStartTime = null;
    const gameDuration = 300000; // 5 минут

    // Для эффекта тряски камеры при столкновении
    let cameraShakeTime = 0;
    const cameraShakeDuration = 300; // мс

    // Массив частиц для эффекта столкновения
    let particles = [];

    function initGame() {
      gameEnded = false;
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemiLight.position.set(0, 0, 1000);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      // Расположение направленного света привязано к позиции курицы
      dirLight.position.set(chicken ? chicken.position.x + cameraOffset.x : cameraOffset.x,
                              chicken ? chicken.position.y + cameraOffset.y : cameraOffset.y,
                              cameraOffset.z);
      dirLight.castShadow = true;
      // Улучшаем качество теней: увеличенное разрешение, смещение и радиус для смягчения краёв
      const d = 500;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.left = -d;
      dirLight.shadow.camera.right = d;
      dirLight.shadow.camera.top = d;
      dirLight.shadow.camera.bottom = -d;
      dirLight.shadow.bias = -0.005;
      dirLight.shadow.radius = 4;
      scene.add(dirLight);

      const backLight = new THREE.DirectionalLight(0x000000, 0.4);
      backLight.position.set(200, 200, 50);
      backLight.castShadow = true;
      scene.add(backLight);

      lanes = generateLanes();
      currentLane = 0;
      currentColumn = Math.floor(columns / 2);
      previousTimestamp = null;
      startMoving = false;
      moves = [];
      stepStartTimestamp = null;

      chicken = new Chicken();
      chicken.position.set(0, 0, 0);
      scene.add(chicken);
    }

    function initRenderer() {
      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x000000, 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('gameWrapper').appendChild(renderer.domElement);

      // Инициализация композитора для постобработки
      composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85);
      composer.addPass(bloomPass);
      const ssaoPass = new THREE.SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
      ssaoPass.kernelRadius = 16;
      composer.addPass(ssaoPass);
    }

    function Texture(width, height, rects) {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const context = canvas.getContext("2d");
      context.fillStyle = "#ffffff";
      context.fillRect(0, 0, width, height);
      context.fillStyle = "rgba(0,0,0,0.6)";
      rects.forEach(rect => {
        context.fillRect(rect.x, rect.y, rect.w, rect.h);
      });
      return new THREE.CanvasTexture(canvas);
    }
    const carFrontTexture = new Texture(40, 80, [{ x: 0, y: 10, w: 30, h: 60 }]);
    const carBackTexture = new Texture(40, 80, [{ x: 10, y: 10, w: 30, h: 60 }]);
    const carRightSideTexture = new Texture(110, 40, [{ x: 10, y: 0, w: 50, h: 30 }, { x: 70, y: 0, w: 30, h: 30 }]);
    const carLeftSideTexture = new Texture(110, 40, [{ x: 10, y: 10, w: 50, h: 30 }, { x: 70, y: 10, w: 30, h: 30 }]);
    const truckFrontTexture = new Texture(30, 30, [{ x: 15, y: 0, w: 10, h: 30 }]);
    const truckRightSideTexture = new Texture(25, 30, [{ x: 0, y: 15, w: 10, h: 10 }]);
    const truckLeftSideTexture = new Texture(25, 30, [{ x: 0, y: 5, w: 10, h: 10 }]);

    function generateLanes() {
      return [-9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(index => {
        const lane = new Lane(index);
        lane.mesh.position.y = index * positionWidth * zoom;
        scene.add(lane.mesh);
        return lane;
      }).filter(lane => lane.index >= 0);
    }
    function addLane() {
      const index = lanes.length;
      const lane = new Lane(index);
      lane.mesh.position.y = index * positionWidth * zoom;
      scene.add(lane.mesh);
      lanes.push(lane);
    }
    function Wheel() {
      const wheel = new THREE.Mesh(
        new THREE.BoxBufferGeometry(12 * zoom, 33 * zoom, 12 * zoom),
        new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true, metalness: 0.2, roughness: 0.8 })
      );
      wheel.position.z = 6 * zoom;
      wheel.castShadow = true;
      return wheel;
    }
    function Car() {
      const car = new THREE.Group();
      const color = vechicleColors[Math.floor(Math.random() * vechicleColors.length)];
      const main = new THREE.Mesh(
        new THREE.BoxBufferGeometry(60 * zoom, 30 * zoom, 15 * zoom),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.6, roughness: 0.4 })
      );
      main.position.z = 12 * zoom;
      main.castShadow = true;
      main.receiveShadow = true;
      car.add(main);
      const cabinMaterials = [
        new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, metalness: 0.5, roughness: 0.3, map: carBackTexture }),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, metalness: 0.5, roughness: 0.3, map: carFrontTexture }),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, metalness: 0.5, roughness: 0.3, map: carRightSideTexture }),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, metalness: 0.5, roughness: 0.3, map: carLeftSideTexture }),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, metalness: 0.5, roughness: 0.3 }),
        new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, metalness: 0.5, roughness: 0.3 })
      ];
      const cabin = new THREE.Mesh(
        new THREE.BoxBufferGeometry(33 * zoom, 24 * zoom, 12 * zoom),
        cabinMaterials
      );
      cabin.position.x = 6 * zoom;
      cabin.position.z = 25.5 * zoom;
      cabin.castShadow = true;
      cabin.receiveShadow = true;
      car.add(cabin);
      const frontWheel = new Wheel();
      frontWheel.position.x = -18 * zoom;
      car.add(frontWheel);
      const backWheel = new Wheel();
      backWheel.position.x = 18 * zoom;
      car.add(backWheel);
      car.castShadow = true;
      return car;
    }
    function Truck() {
      const truck = new THREE.Group();
      const color = vechicleColors[Math.floor(Math.random() * vechicleColors.length)];
      const base = new THREE.Mesh(
        new THREE.BoxBufferGeometry(100 * zoom, 25 * zoom, 5 * zoom),
        new THREE.MeshStandardMaterial({ color: 0xb4c6fc, flatShading: true, metalness: 0.3, roughness: 0.7 })
      );
      base.position.z = 10 * zoom;
      base.castShadow = true;
      truck.add(base);
      const cargo = new THREE.Mesh(
        new THREE.BoxBufferGeometry(75 * zoom, 35 * zoom, 40 * zoom),
        new THREE.MeshStandardMaterial({ color: 0xb4c6fc, flatShading: true, metalness: 0.3, roughness: 0.7 })
      );
      cargo.position.x = 15 * zoom;
      cargo.position.z = 30 * zoom;
      cargo.castShadow = true;
      cargo.receiveShadow = true;
      truck.add(cargo);
      const cabinMaterials = [
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.5, roughness: 0.4 }),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.5, roughness: 0.4, map: truckFrontTexture }),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.5, roughness: 0.4, map: truckRightSideTexture }),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.5, roughness: 0.4, map: truckLeftSideTexture }),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.5, roughness: 0.4 }),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.5, roughness: 0.4 })
      ];
      const cabin = new THREE.Mesh(
        new THREE.BoxBufferGeometry(25 * zoom, 30 * zoom, 30 * zoom),
        cabinMaterials
      );
      cabin.position.x = -40 * zoom;
      cabin.position.z = 20 * zoom;
      cabin.castShadow = true;
      cabin.receiveShadow = true;
      truck.add(cabin);
      const frontWheel = new Wheel();
      frontWheel.position.x = -38 * zoom;
      truck.add(frontWheel);
      const middleWheel = new Wheel();
      middleWheel.position.x = -10 * zoom;
      truck.add(middleWheel);
      const backWheel = new Wheel();
      backWheel.position.x = 30 * zoom;
      truck.add(backWheel);
      return truck;
    }
    function ThreeTree() {
      const tree = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.BoxBufferGeometry(15 * zoom, 15 * zoom, 20 * zoom),
        new THREE.MeshStandardMaterial({ color: 0x4d2926, flatShading: true, metalness: 0.2, roughness: 0.8 })
      );
      trunk.position.z = 10 * zoom;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      tree.add(trunk);
      const height = threeHeights[Math.floor(Math.random() * threeHeights.length)];
      const crown = new THREE.Mesh(
        new THREE.BoxBufferGeometry(30 * zoom, 30 * zoom, height * zoom),
        new THREE.MeshStandardMaterial({ color: 0x7aa21d, flatShading: true, metalness: 0.2, roughness: 0.9 })
      );
      crown.position.z = (height / 2 + 20) * zoom;
      crown.castShadow = true;
      tree.add(crown);
      return tree;
    }
    function Chicken() {
      const chicken = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxBufferGeometry(chickenSize * zoom, chickenSize * zoom, 20 * zoom),
        new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true, metalness: 0.4, roughness: 0.3 })
      );
      body.position.z = 10 * zoom;
      body.castShadow = true;
      body.receiveShadow = true;
      chicken.add(body);
      const rowel = new THREE.Mesh(
        new THREE.BoxBufferGeometry(2 * zoom, 4 * zoom, 2 * zoom),
        new THREE.MeshStandardMaterial({ color: 0xF0619A, flatShading: true, metalness: 0.4, roughness: 0.3 })
      );
      rowel.position.z = 21 * zoom;
      rowel.castShadow = true;
      chicken.add(rowel);
      return chicken;
    }
    function Road() {
      const road = new THREE.Group();
      const createSection = color => new THREE.Mesh(
        new THREE.PlaneBufferGeometry(boardWidth * zoom, positionWidth * zoom),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.2, roughness: 0.8 })
      );
      const middle = createSection(0x454A59);
      middle.receiveShadow = true;
      road.add(middle);
      const left = createSection(0x393D49);
      left.position.x = -boardWidth * zoom;
      road.add(left);
      const right = createSection(0x393D49);
      right.position.x = boardWidth * zoom;
      road.add(right);
      return road;
    }
    function Grass() {
      const grass = new THREE.Group();
      const createSection = color => new THREE.Mesh(
        new THREE.BoxBufferGeometry(boardWidth * zoom, positionWidth * zoom, 3 * zoom),
        new THREE.MeshStandardMaterial({ color, flatShading: true, metalness: 0.2, roughness: 0.8 })
      );
      const middle = createSection(0xbaf455);
      middle.receiveShadow = true;
      grass.add(middle);
      const left = createSection(0x99C846);
      left.position.x = -boardWidth * zoom;
      grass.add(left);
      const right = createSection(0x99C846);
      right.position.x = boardWidth * zoom;
      grass.add(right);
      grass.position.z = 1.5 * zoom;
      return grass;
    }
    function Lane(index) {
      this.index = index;
      this.type = index <= 0 ? 'field' : laneTypes[Math.floor(Math.random() * laneTypes.length)];
      switch (this.type) {
        case 'field': {
          this.type = 'field';
          this.mesh = new Grass();
          break;
        }
        case 'forest': {
          this.mesh = new Grass();
          this.occupiedPositions = new Set();
          this.trees = [1, 2, 3, 4].map(() => {
            const tree = ThreeTree();
            let position;
            do {
              position = Math.floor(Math.random() * columns);
            } while (this.occupiedPositions.has(position));
            this.occupiedPositions.add(position);
            tree.position.x = (position * positionWidth + positionWidth / 2) * zoom - boardWidth * zoom / 2;
            this.mesh.add(tree);
            return tree;
          });
          break;
        }
        case 'car': {
          this.mesh = new Road();
          this.direction = Math.random() >= 0.5;
          const occupiedPositions = new Set();
          this.vechicles = [1, 2, 3].map(() => {
            const vechicle = new Car();
            let position;
            do {
              position = Math.floor(Math.random() * (columns / 2));
            } while (occupiedPositions.has(position));
            occupiedPositions.add(position);
            vechicle.position.x = (position * positionWidth * 2 + positionWidth / 2) * zoom - boardWidth * zoom / 2;
            if (!this.direction) vechicle.rotation.z = Math.PI;
            this.mesh.add(vechicle);
            return vechicle;
          });
          this.speed = laneSpeeds[Math.floor(Math.random() * laneSpeeds.length)];
          break;
        }
        case 'truck': {
          this.mesh = new Road();
          this.direction = Math.random() >= 0.5;
          const occupiedPositions = new Set();
          this.vechicles = [1, 2].map(() => {
            const vechicle = new Truck();
            let position;
            do {
              position = Math.floor(Math.random() * (columns / 3));
            } while (occupiedPositions.has(position));
            occupiedPositions.add(position);
            vechicle.position.x = (position * positionWidth * 3 + positionWidth / 2) * zoom - boardWidth * zoom / 2;
            if (!this.direction) vechicle.rotation.z = Math.PI;
            this.mesh.add(vechicle);
            return vechicle;
          });
          this.speed = laneSpeeds[Math.floor(Math.random() * laneSpeeds.length)];
          break;
        }
      }
    }

    // Звук движения
    const moveSoundEffect = new Audio("move.mp3");

    // Обработчики кнопок управления
    document.getElementById('forward').addEventListener("click", () => move('forward'));
    document.getElementById('backward').addEventListener("click", () => move('backward'));
    document.getElementById('left').addEventListener("click", () => move('left'));
    document.getElementById('right').addEventListener("click", () => move('right'));

    function move(direction) {
      moveSoundEffect.currentTime = 0;
      moveSoundEffect.play().catch(err => console.log(err));
      const finalPositions = moves.reduce((position, move) => {
        if (move === 'forward') return { lane: position.lane + 1, column: position.column };
        if (move === 'backward') return { lane: position.lane - 1, column: position.column };
        if (move === 'left') return { lane: position.lane, column: position.column - 1 };
        if (move === 'right') return { lane: position.lane, column: position.column + 1 };
      }, { lane: currentLane, column: currentColumn });

      if (direction === 'forward') {
        if (lanes[finalPositions.lane + 1].type === 'forest' &&
            lanes[finalPositions.lane + 1].occupiedPositions.has(finalPositions.column)) return;
        if (!stepStartTimestamp) startMoving = true;
        addLane();
      } else if (direction === 'backward') {
        if (finalPositions.lane === 0) return;
        if (lanes[finalPositions.lane - 1].type === 'forest' &&
            lanes[finalPositions.lane - 1].occupiedPositions.has(finalPositions.column)) return;
        if (!stepStartTimestamp) startMoving = true;
      } else if (direction === 'left') {
        if (finalPositions.column === 0) return;
        if (lanes[finalPositions.lane].type === 'forest' &&
            lanes[finalPositions.lane].occupiedPositions.has(finalPositions.column - 1)) return;
        if (!stepStartTimestamp) startMoving = true;
      } else if (direction === 'right') {
        if (finalPositions.column === columns - 1) return;
        if (lanes[finalPositions.lane].type === 'forest' &&
            lanes[finalPositions.lane].occupiedPositions.has(finalPositions.column + 1)) return;
        if (!stepStartTimestamp) startMoving = true;
      }
      moves.push(direction);
    }

    // Функция для создания эффекта частиц при столкновении
    function spawnParticles(x, y, z) {
      for (let i = 0; i < 50; i++) {
        const particleGeometry = new THREE.SphereGeometry(1 * zoom, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.set(x, y, z);
        const velocity = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, Math.random()*2);
        const lifetime = 1000 + Math.random()*500; // в мс
        particles.push({ mesh: particle, velocity: velocity, lifetime: lifetime, born: performance.now() });
        scene.add(particle);
      }
    }

    // Функция завершения игры – воспроизводит звук смерти, записывает очки и показывает модальное окно
    function endGame() {
      if (gameEnded) return;
      // Запускаем эффект частиц и тряску камеры
      spawnParticles(chicken.position.x, chicken.position.y, chicken.position.z);
      cameraShakeTime = cameraShakeDuration;
      gameEnded = true;
      document.getElementById('deathSound').play().catch(err => console.log(err));
      localUserData.points += currentLane;
      if (userRef) userRef.update({ points: localUserData.points });
      document.getElementById('controlls').style.display = 'none';
      modalType = "gameOver";
      document.getElementById('endTitle').textContent = 'Game Over!';
      document.getElementById('endMessage').textContent = 'Your score: ' + currentLane;
      document.getElementById('end').style.visibility = 'visible';
    }

    // Если билетов нет или данные не загружены – показываем модальное окно
    function showNoTicketsModal() {
      modalType = "noTickets";
      document.getElementById('endTitle').textContent = 'Not enough tickets!';
      document.getElementById('endMessage').textContent = 'Please come back later.';
      document.getElementById('end').style.visibility = 'visible';
    }

    /* ----------------------------------------
       3. Главный игровой цикл и таймер
    ---------------------------------------- */
    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (!previousTimestamp) previousTimestamp = timestamp;
      const delta = timestamp - previousTimestamp;
      previousTimestamp = timestamp;

      // Обновление таймера (если игра запущена)
      if (gameStartTime) {
        let elapsed = timestamp - gameStartTime;
        let remaining = gameDuration - elapsed;
        let timeBar = document.getElementById('timeBar');
        if (remaining <= 0) {
          timeBar.style.width = "0%";
          if (!gameEnded) {
            endGame();
          }
        } else {
          timeBar.style.width = (remaining / gameDuration * 100) + "%";
        }
      }

      lanes.forEach(lane => {
        if (lane.type === 'car' || lane.type === 'truck') {
          const aBitBefore = -boardWidth * zoom / 2 - positionWidth * 2 * zoom;
          const aBitAfter  = boardWidth * zoom / 2 + positionWidth * 2 * zoom;
          lane.vechicles.forEach(vehicle => {
            if (lane.direction) {
              vehicle.position.x = vehicle.position.x < aBitBefore ? aBitAfter : vehicle.position.x - lane.speed / 16 * delta;
            } else {
              vehicle.position.x = vehicle.position.x > aBitAfter ? aBitBefore : vehicle.position.x + lane.speed / 16 * delta;
            }
          });
        }
      });

      if (startMoving) {
        stepStartTimestamp = timestamp;
        startMoving = false;
      }

      if (stepStartTimestamp) {
        const moveDeltaTime = timestamp - stepStartTimestamp;
        const progress = Math.min(moveDeltaTime / stepTime, 1);
        const moveDeltaDistance = progress * positionWidth * zoom;
        const jumpDeltaDistance = Math.sin(progress * Math.PI) * 8 * zoom;
        switch (moves[0]) {
          case 'forward': {
            const targetY = currentLane * positionWidth * zoom + moveDeltaDistance;
            chicken.position.y = targetY;
            chicken.position.z = jumpDeltaDistance;
            camera.position.y = chicken.position.y + cameraOffset.y;
            camera.position.x = chicken.position.x + cameraOffset.x;
            break;
          }
          case 'backward': {
            const targetY = currentLane * positionWidth * zoom - moveDeltaDistance;
            chicken.position.y = targetY;
            chicken.position.z = jumpDeltaDistance;
            camera.position.y = chicken.position.y + cameraOffset.y;
            camera.position.x = chicken.position.x + cameraOffset.x;
            break;
          }
          case 'left': {
            const targetX = (currentColumn * positionWidth + positionWidth / 2) * zoom - boardWidth * zoom / 2 - moveDeltaDistance;
            chicken.position.x = targetX;
            chicken.position.z = jumpDeltaDistance;
            camera.position.x = chicken.position.x + cameraOffset.x;
            camera.position.y = chicken.position.y + cameraOffset.y;
            break;
          }
          case 'right': {
            const targetX = (currentColumn * positionWidth + positionWidth / 2) * zoom - boardWidth * zoom / 2 + moveDeltaDistance;
            chicken.position.x = targetX;
            chicken.position.z = jumpDeltaDistance;
            camera.position.x = chicken.position.x + cameraOffset.x;
            camera.position.y = chicken.position.y + cameraOffset.y;
            break;
          }
        }
        if (moveDeltaTime > stepTime) {
          switch (moves[0]) {
            case 'forward': {
              currentLane++;
              document.getElementById('counter').textContent = currentLane;
              break;
            }
            case 'backward': {
              currentLane--;
              document.getElementById('counter').textContent = currentLane;
              break;
            }
            case 'left': {
              currentColumn--;
              break;
            }
            case 'right': {
              currentColumn++;
              break;
            }
          }
          moves.shift();
          stepStartTimestamp = moves.length === 0 ? null : timestamp;
        }
      }

      // Проверка столкновения в текущем ряду
      if (lanes[currentLane].type === 'car' || lanes[currentLane].type === 'truck') {
        const chickenMinX = chicken.position.x - chickenSize * zoom / 2;
        const chickenMaxX = chicken.position.x + chickenSize * zoom / 2;
        const vehicleLength = { car: 60, truck: 105 }[lanes[currentLane].type];
        lanes[currentLane].vechicles.forEach(vehicle => {
          const vehicleMinX = vehicle.position.x - vehicleLength * zoom / 2;
          const vehicleMaxX = vehicle.position.x + vehicleLength * zoom / 2;
          if (chickenMaxX > vehicleMinX && chickenMinX < vehicleMaxX) {
            endGame();
          }
        });
      }

      // Обновление эффекта частиц
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        const lifeTime = timestamp - particle.born;
        if (lifeTime > particle.lifetime) {
          scene.remove(particle.mesh);
          particles.splice(i, 1);
        } else {
          particle.mesh.position.add(particle.velocity.clone().multiplyScalar(delta / 1000));
          let opacity = 1 - (lifeTime / particle.lifetime);
          if(particle.mesh.material) {
            particle.mesh.material.opacity = opacity;
            particle.mesh.material.transparent = true;
          }
        }
      }

      // Сохраняем базовую позицию камеры и добавляем тряску, если она активна
      const originalCameraPosition = camera.position.clone();
      if (cameraShakeTime > 0) {
        const shakeMagnitude = 10 * zoom;
        camera.position.x += (Math.random() - 0.5) * shakeMagnitude;
        camera.position.y += (Math.random() - 0.5) * shakeMagnitude;
        cameraShakeTime -= delta;
        if(cameraShakeTime < 0) cameraShakeTime = 0;
      }
      camera.lookAt(chicken.position);

      // Рендер с использованием постобработки (если композитор инициализирован)
      if (composer) {
        composer.render(delta);
      } else {
        renderer.render(scene, camera);
      }
      // Восстанавливаем позицию камеры после рендера
      camera.position.copy(originalCameraPosition);
    }
    requestAnimationFrame(animate);

    /* ----------------------------------------
       4. Функция старта игры
    ---------------------------------------- */
    document.body.addEventListener('click', () => {
      const bgSound = document.getElementById('bgSound');
      if (bgSound.paused) {
        bgSound.play().catch(err => console.log(err));
      }
    }, { once: true });

    function startGame() {
      // Если данные не загружены или билетов недостаточно, показываем модальное окно
      if (!dataLoaded || localUserData.tickets < 1) {
        showNoTicketsModal();
        return;
      }
      localUserData.tickets--;
      if (userRef) userRef.update({ tickets: localUserData.tickets });
      updateHeader();
      // Скрываем меню: header, back и кнопку Start
      document.getElementById('header').style.display = 'none';
      document.getElementById('backContainer').style.display = 'none';
      document.getElementById('startBtn').style.display = 'none';
      // Показываем область игры и контролы
      document.getElementById('gameWrapper').style.display = 'block';
      document.getElementById('controlls').style.display = 'flex';
      // Показываем time bar
      document.getElementById('timeBarContainer').style.display = 'block';
      // Устанавливаем время старта игры для таймера
      gameStartTime = performance.now();

      initGame();
      if (!renderer) {
        initRenderer();
      }
    }
  </script>
</body>
</html>
