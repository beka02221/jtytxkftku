<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Snake PvP Multiplayer</title>
  
  <!-- Press Start 2P Font -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Base CSS (you can keep your existing CSS rules) -->
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0f0;
      font-family: 'Press Start 2P', sans-serif;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: #111;
      border-bottom: 2px solid #0f0;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .user-info img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }
    .balances span {
      margin-right: 10px;
    }
    .hamburger-line {
      display: block;
      width: 20px;
      height: 2px;
      background-color: #0f0;
      margin: 4px 0;
    }
    #design-options {
      display: none;
      position: absolute;
      background: #222;
      border: 1px solid #0f0;
      padding: 10px;
      z-index: 99;
    }
    main {
      position: relative;
      width: 100vw;
      height: calc(100vh - 58px); /* header height subtracted */
      overflow: hidden;
    }
    /* Signaling UI */
    #signalingUI {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      border: 1px solid #0f0;
      padding: 10px;
      z-index: 1000;
      max-width: 90%;
    }
    #signalingUI textarea {
      width: 100%;
      height: 80px;
    }
    #signalingUI button {
      margin-top: 5px;
      padding: 5px 10px;
      font-size: 14px;
    }
    /* Multiplayer game views */
    .view {
      display: none;
      width: 100%;
      height: 100%;
    }
    .activeView {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    /* Search/Waiting view */
    .search-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    @keyframes searching {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
    .search-animation {
      animation: searching 1.2s infinite;
      font-size: 16px;
      margin-top: 10px;
    }
    .opponent-found {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .opponent-found img {
      border-radius: 50%;
      width: 60px;
      height: 60px;
    }
    /* Game view */
    .game-container {
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    .timer-bar {
      margin: 5px 0;
      width: 80%;
      height: 12px;
      background: #555;
      border: 1px solid #0f0;
      position: relative;
    }
    .timer-fill {
      background: #0f0;
      width: 100%;
      height: 100%;
      transition: width 1s linear;
    }
    .scores {
      margin: 5px 0;
    }
    #snakeCanvas {
      flex: 1;
      width: 100%;
      height: 100%;
      background: #333;
      border-top: 2px solid #0f0;
      border-bottom: 2px solid #0f0;
      image-rendering: pixelated;
    }
    /* Draw grid lines (green) */
    .grid-line {
      stroke: rgba(0,255,0,0.3);
      stroke-width: 1;
    }
    /* Modals */
    .modal-backdrop, .endgame-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-backdrop.active, .endgame-backdrop.active {
      display: flex;
    }
    .modal, .endgame-modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }
  </style>

  <!-- SimplePeer from CDN -->
  <script src="https://unpkg.com/simple-peer/simplepeer.min.js"></script>
</head>
<body>
  <!-- Header (user info, balances, design) -->
  <header>
    <div class="user-info">
      <img id="userPhoto" src="" alt="Avatar"/>
      <span id="username">@User</span>
    </div>
    <div class="balances">
      <span>
        <img src="https://img.icons8.com/external-kmg-design-glyph-kmg-design/64/00FF00/external-ticket-cinema-kmg-design-glyph-kmg-design.png" alt="Tickets" width="20"/>
        <span id="ticketCount">0</span>
      </span>
      <span>
        <img src="https://img.icons8.com/ios-filled/50/00FF00/coins.png" alt="Coins" width="20"/>
        <span id="coinCount">0</span>
      </span>
      <span>
        <img src="https://img.icons8.com/ios-filled/50/00FF00/rating.png" alt="Points" width="20"/>
        <span id="pointCount">0</span>
      </span>
    </div>
    <div class="header-left" id="design-settings" style="position:relative;">
      <button onclick="toggleDesignMenu()">
        <span class="hamburger-line"></span>
        <span class="hamburger-line"></span>
        <span class="hamburger-line"></span>
      </button>
      <div id="design-options">
        <p onclick="changeDesign('st1.css')">Design (Default)</p>
        <p onclick="changeDesign('st2.css')">Retro Design</p>
        <p onclick="changeDesign('st3.css')">Cyberpunk Design</p>
      </div>
    </div>
  </header>

  <!-- Signaling UI (for manual SDP exchange) -->
  <div id="signalingUI">
    <div id="peerSelect">
      <button id="hostBtn">Host Game</button>
      <button id="joinBtn">Join Game</button>
    </div>
    <div id="hostUI" style="display:none;">
      <p>Share this offer with your friend:</p>
      <textarea id="offerSDP" readonly></textarea>
      <p>Paste your friend’s answer below:</p>
      <textarea id="answerSDP"></textarea>
      <button id="submitAnswerBtn">Submit Answer</button>
    </div>
    <div id="joinUI" style="display:none;">
      <p>Paste host's offer:</p>
      <textarea id="hostOffer"></textarea>
      <button id="submitOfferBtn">Submit Offer</button>
      <p>Send this answer to the host:</p>
      <textarea id="myAnswer" readonly></textarea>
    </div>
  </div>

  <!-- Main Views -->
  <main>
    <!-- Signaling view is visible initially (above) -->
    <div id="gameView" class="view">
      <!-- Search/Waiting view -->
      <div id="searchView" class="view activeView">
        <div class="search-container">
          <h2>Snake PvP Multiplayer</h2>
          <p>Game duration: 2 minutes | Cost: 1 Ticket</p>
          <div class="search-animation">Waiting for opponent...</div>
        </div>
      </div>
      <!-- Game view -->
      <div id="playView" class="view">
        <div class="game-container">
          <div class="timer-bar">
            <div class="timer-fill" id="timerFill"></div>
          </div>
          <div class="scores">
            <span id="playerScoreLabel">You: 0</span> | 
            <span id="opponentScoreLabel">Opponent: 0</span>
          </div>
          <canvas id="snakeCanvas"></canvas>
        </div>
      </div>
    </div>
  </main>

  <!-- Modals -->
  <div class="modal-backdrop" id="noTicketsModal">
    <div class="modal">
      <h2>Not enough tickets</h2>
      <p>You do not have enough tickets to play.</p>
      <button onclick="returnToMain()">Return</button>
    </div>
  </div>
  <div class="endgame-backdrop" id="endgameBackdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>
  <div class="modal-backdrop" id="connectionErrorModal">
    <div class="modal">
      <h2>Connection Error</h2>
      <p>Connection lost. The game will end.</p>
      <button onclick="finishGame()">Return to Main</button>
    </div>
  </div>

  <!-- JavaScript: Multiplayer game with WebRTC (SimplePeer) -->
  <script>
    /***** GLOBAL VARIABLES *****/
    let peer = null; // SimplePeer instance
    let isHostMode = false;
    let connected = false;
    
    // Game state variables
    let localSnake = {
      x: 5, y: 5,
      direction: 'RIGHT',
      // Start with 3 blocks horizontally
      body: [ {x:3,y:5}, {x:4,y:5}, {x:5,y:5} ],
      color: '#0f0'
    };
    let remoteSnake = {
      x: 15, y: 15,
      direction: 'LEFT',
      body: [ {x:17,y:15}, {x:16,y:15}, {x:15,y:15} ],
      color: '#f00'
    };
    let localScore = 0, remoteScore = 0;
    let apple = { x: 10, y: 10 };
    let gridCols = 20, gridRows = 30;
    let tileSizeX = 0, tileSizeY = 0;
    let snakeSpeed = 200; // 200ms per move
    let lastMoveTime = 0;
    let gameDuration = 120; // 120 seconds (2 minutes)
    let gameTimeLeft = gameDuration;
    let gameInterval = null;
    let gameStarted = false;

    /***** SIGNALING / PEER CONNECTION *****/
    const hostBtn = document.getElementById('hostBtn');
    const joinBtn = document.getElementById('joinBtn');
    const hostUI = document.getElementById('hostUI');
    const joinUI = document.getElementById('joinUI');
    const offerSDPText = document.getElementById('offerSDP');
    const answerSDPText = document.getElementById('answerSDP');
    const submitAnswerBtn = document.getElementById('submitAnswerBtn');
    const hostOfferText = document.getElementById('hostOffer');
    const submitOfferBtn = document.getElementById('submitOfferBtn');
    const myAnswerText = document.getElementById('myAnswer');

    hostBtn.addEventListener('click', () => {
      isHostMode = true;
      document.getElementById('peerSelect').style.display = 'none';
      hostUI.style.display = 'block';
      // Create peer as initiator
      peer = new SimplePeer({ initiator: true, trickle: false });
      setPeerEvents();
    });
    joinBtn.addEventListener('click', () => {
      isHostMode = false;
      document.getElementById('peerSelect').style.display = 'none';
      joinUI.style.display = 'block';
    });
    submitOfferBtn.addEventListener('click', () => {
      let offer = hostOfferText.value;
      if (!offer) return alert("Please paste host's offer.");
      // Create peer as non-initiator and signal with offer
      peer = new SimplePeer({ initiator: false, trickle: false });
      setPeerEvents();
      peer.signal(JSON.parse(offer));
    });
    submitAnswerBtn.addEventListener('click', () => {
      let answer = answerSDPText.value;
      if (!answer) return alert("Please paste your friend's answer.");
      try {
        peer.signal(JSON.parse(answer));
      } catch(e) {
        alert("Invalid answer data.");
      }
    });
    function setPeerEvents() {
      peer.on('signal', data => {
        // When signaling, output SDP based on role
        if (isHostMode) {
          // Host: show offer; then later wait for answer
          offerSDPText.value = JSON.stringify(data);
        } else {
          // Joiner: output answer for host
          myAnswerText.value = JSON.stringify(data);
        }
      });
      peer.on('connect', () => {
        connected = true;
        document.getElementById('signalingUI').style.display = 'none';
        // When connected, show search view (waiting for opponent)
        document.getElementById('gameView').classList.add('activeView');
        // Start game search phase (for this example, once connection is established, we consider both peers ready)
        startGameSearch();
      });
      peer.on('data', data => {
        try {
          let msg = JSON.parse(data);
          handlePeerMessage(msg);
        } catch(e) {
          console.error("Invalid message", data);
        }
      });
      peer.on('close', () => {
        connected = false;
        showConnectionError();
      });
      peer.on('error', err => {
        console.error("Peer error", err);
        showConnectionError();
      });
    }

    /***** PEER MESSAGE HANDLING *****/
    function handlePeerMessage(msg) {
      if (msg.type === 'stateUpdate') {
        // Update remote snake and score
        remoteSnake = msg.snake;
        remoteScore = msg.score;
        // If host sends apple update, update local apple (joiner accepts host apple)
        if (msg.apple !== undefined) {
          apple = msg.apple;
        }
      } else if (msg.type === 'gameOver') {
        // Received game over message from peer
        endGame(msg.result);
      }
    }

    /***** GAME LOGIC *****/
    function startGameSearch() {
      // Both peers are now connected. Show a "waiting" screen for 5 seconds,
      // then start the game and deduct the ticket.
      document.getElementById('searchView').classList.add('activeView');
      setTimeout(() => {
        // Start game – both peers deduct ticket (simulate local ticket deduction)
        // In a real app, tickets would be maintained persistently.
        startGame();
      }, 5000);
    }

    function startGame() {
      // Hide search view; show game view.
      document.getElementById('searchView').style.display = 'none';
      document.getElementById('playView').style.display = 'flex';
      
      // Set up canvas dimensions and grid tile sizes.
      const canvas = document.getElementById('snakeCanvas');
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      tileSizeX = canvas.width / gridCols;
      tileSizeY = canvas.height / gridRows;

      // Initialize game timer and reset scores.
      gameTimeLeft = gameDuration;
      localScore = 0;
      remoteScore = 0;
      updateScoreLabels();
      updateTimerBar();

      // Start game loop.
      gameStarted = true;
      lastMoveTime = performance.now();
      gameInterval = setInterval(() => {
        gameTimeLeft--;
        updateTimerBar();
        if (gameTimeLeft <= 0) {
          clearInterval(gameInterval);
          sendPeerMessage({ type: 'gameOver', result: calculateResult() });
          endGame(calculateResult());
        }
      }, 1000);
      requestAnimationFrame(gameLoop);
    }

    function gameLoop(timestamp) {
      if (!gameStarted) return;
      if (timestamp - lastMoveTime > snakeSpeed) {
        lastMoveTime = timestamp;
        // Update local snake movement
        updateSnake(localSnake, true);
        // Send local state to peer
        sendPeerMessage({ type: 'stateUpdate', snake: localSnake, score: localScore, apple: isHostMode ? apple : undefined });
      }
      drawScene();
      requestAnimationFrame(gameLoop);
    }

    function updateSnake(snk, isLocal) {
      let newX = snk.x, newY = snk.y;
      if (snk.direction === 'LEFT') newX--;
      else if (snk.direction === 'RIGHT') newX++;
      else if (snk.direction === 'UP') newY--;
      else if (snk.direction === 'DOWN') newY++;
      if (newX < 0) newX = gridCols - 1;
      if (newX >= gridCols) newX = 0;
      if (newY < 0) newY = gridRows - 1;
      if (newY >= gridRows) newY = 0;
      snk.x = newX; snk.y = newY;
      let ateApple = (newX === apple.x && newY === apple.y);
      snk.body.unshift({ x: newX, y: newY });
      if (!ateApple) {
        snk.body.pop();
      } else {
        if (isLocal) { localScore++; }
        else { remoteScore++; }
        // If host, generate new apple and send update.
        if (isHostMode) {
          apple.x = Math.floor(Math.random() * gridCols);
          apple.y = Math.floor(Math.random() * gridRows);
        }
      }
      updateScoreLabels();
    }

    function updateScoreLabels() {
      document.getElementById('playerScoreLabel').textContent = `You: ${localScore}`;
      document.getElementById('opponentScoreLabel').textContent = `Opponent: ${remoteScore}`;
    }

    function drawScene() {
      const canvas = document.getElementById('snakeCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid(ctx, canvas.width, canvas.height);
      drawSnake(ctx, localSnake, "You");
      drawSnake(ctx, remoteSnake, opponentData.username || "Opponent");
      // Draw apple
      ctx.fillStyle = "#ff0";
      ctx.fillRect(apple.x * tileSizeX, apple.y * tileSizeY, tileSizeX, tileSizeY);
    }

    function drawGrid(ctx, width, height) {
      ctx.strokeStyle = "rgba(0,255,0,0.3)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridCols; i++) {
        ctx.beginPath();
        ctx.moveTo(i * tileSizeX, 0);
        ctx.lineTo(i * tileSizeX, height);
        ctx.stroke();
      }
      for (let j = 0; j <= gridRows; j++) {
        ctx.beginPath();
        ctx.moveTo(0, j * tileSizeY);
        ctx.lineTo(width, j * tileSizeY);
        ctx.stroke();
      }
    }

    function drawSnake(ctx, snk, label) {
      ctx.fillStyle = snk.color;
      snk.body.forEach(part => {
        ctx.fillRect(part.x * tileSizeX, part.y * tileSizeY, tileSizeX, tileSizeY);
      });
      ctx.fillStyle = "#fff";
      ctx.font = "10px 'Press Start 2P'";
      ctx.fillText(label, snk.body[0].x * tileSizeX, snk.body[0].y * tileSizeY - 2);
    }

    function sendPeerMessage(msg) {
      if (peer && connected) {
        peer.send(JSON.stringify(msg));
      }
    }

    function calculateResult() {
      if (localScore > remoteScore) return "win";
      else if (localScore < remoteScore) return "lose";
      else return "draw";
    }

    function endGame(resultMsg) {
      gameStarted = false;
      clearInterval(gameTimer);
      document.getElementById('playView').style.display = 'none';
      document.getElementById('endgameMessage').textContent =
        `Your score: ${localScore}, Opponent: ${remoteScore}. ` +
        (resultMsg === "win" ? "You won!" : resultMsg === "lose" ? "You lost!" : "Draw!");
      document.getElementById('endgameBackdrop').classList.add("active");
    }

    /***** INPUT HANDLERS FOR CONTROLLING SNAKE *****/
    document.addEventListener("keydown", (e) => {
      if (!gameStarted) return;
      if (e.key === "ArrowLeft" && localSnake.direction !== "RIGHT") localSnake.direction = "LEFT";
      else if (e.key === "ArrowRight" && localSnake.direction !== "LEFT") localSnake.direction = "RIGHT";
      else if (e.key === "ArrowUp" && localSnake.direction !== "DOWN") localSnake.direction = "UP";
      else if (e.key === "ArrowDown" && localSnake.direction !== "UP") localSnake.direction = "DOWN";
    });
    function setupTouchControls() {
      let touchStartX = 0, touchStartY = 0;
      document.addEventListener("touchstart", (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, false);
      document.addEventListener("touchmove", (e) => { e.preventDefault(); }, { passive: false });
      document.addEventListener("touchend", (e) => {
        let touchEndX = e.changedTouches[0].clientX;
        let touchEndY = e.changedTouches[0].clientY;
        let diffX = touchEndX - touchStartX;
        let diffY = touchEndY - touchStartY;
        if (Math.abs(diffX) > Math.abs(diffY)) {
          if (diffX > 0 && localSnake.direction !== "LEFT") localSnake.direction = "RIGHT";
          else if (diffX < 0 && localSnake.direction !== "RIGHT") localSnake.direction = "LEFT";
        } else {
          if (diffY > 0 && localSnake.direction !== "UP") localSnake.direction = "DOWN";
          else if (diffY < 0 && localSnake.direction !== "DOWN") localSnake.direction = "UP";
        }
      }, false);
    }

    /***** TIMER *****/
    function updateTimerBar() {
      const percent = (gameTimeLeft / gameDuration) * 100;
      document.getElementById("timerFill").style.width = percent + "%";
    }

    /***** CONNECTION ERROR HANDLING *****/
    function showConnectionError() {
      document.getElementById("connectionErrorModal").classList.add("active");
    }
    function returnToMain() {
      document.getElementById("noTicketsModal").classList.remove("active");
      window.location.href = "index.html";
    }
    function finishGame() {
      document.getElementById("endgameBackdrop").classList.remove("active");
      window.location.href = "index.html";
    }
  </script>
</body>
</html>
