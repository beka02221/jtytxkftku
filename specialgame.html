<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>
  
  <!-- Шрифт Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Подключите ваш CSS (например, st1.css) -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* Основные стили страницы */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0f0;
      font-family: 'Press Start 2P', sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
    /* Кнопка копирования inviteLink */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', sans-serif;
      font-size: 10px;
      padding: 5px 10px;
      display: none;
      cursor: pointer;
    }
    /* Модальное окно итогов */
    .endgame-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .endgame-backdrop.active {
      display: flex;
    }
    .endgame-modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Canvas игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>
  
  <!-- Кнопка для копирования inviteLink -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>
  
  <!-- Модальное окно итогов игры -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>
  
  <script>
    /* ============================================================
       specialgame1.js (оптимизированная версия)
       Изменения:
         - Начальный текст поиска мигает, выполнен в розовом (#FF69B4) пиксельном шрифте.
         - После нахождения соперника отображаются его фото и username, затем начинается обратный отсчёт.
         - Исправлен баг подбора себя (пользователь не может быть выбран как соперник).
         - Текст ссылки приглашения адаптирован по размеру, и добавлена кнопка Copy Invite Link.
         - Время игры – ровно 1 минута.
         - При столкновении со своей змейкой игра завершается, а столкновения с соперником не приводят к смерти.
         - Модальное окно итогов с кнопкой «Continue» отправляет на index.html.
    ============================================================ */

    let specialGameCanvas;
    let specialCtx;

    // Положение и размеры игровой зоны на canvas
    const GAME_AREA_X = 50;
    const GAME_AREA_Y = 175;
    const GAME_AREA_WIDTH = 300;
    const GAME_AREA_HEIGHT = 500;

    // Размер клетки и количество ячеек
    const gridSize = 20;
    const tileCountX = GAME_AREA_WIDTH / gridSize;
    const tileCountY = GAME_AREA_HEIGHT / gridSize;

    // Глобальные идентификаторы комнаты/игроков
    let roomId = null;
    let playerId = null;
    let opponentId = null;
    let gameStateRef = null;

    // Локальное состояние змейки игрока
    let localSnake = [];
    let localDirection = 'right';
    let score = 0;

    // Состояние соперника
    let opponentSnake = [];
    let opponentScore = 0;
    let opponentName = 'Opponent';

    // Яблоко
    let applePos = { x: 0, y: 0 };

    // Флаги игры
    let isGameRunning = false;
    let isGameOver = false;
    let countdownValue = 5;
    let showOpponentNameTimeout = null;

    // Таймер (1 минута = 60 сек)
    let timerTotal = 60;
    let timerCurrent = 60;

    // Интервалы
    let logicTimer = null;
    let countdownInterval = null;

    // Цвета змей: player1 — фиолетовый, player2 — жёлтый
    const snakeColors = {
      player1: '#800080',
      player2: '#FFFF00'
    };

    // Интервал логики (150 мс)
    const LOGIC_INTERVAL = 150;

    // Ссылка для приглашения (будет сформирована)
    let inviteLink = "";

    /* ======================================
       1. ИНИЦИАЛИЗАЦИЯ И СБРОС ИГРЫ
    ===================================== */
    function initSpecialGame1() {
      specialGameCanvas = document.getElementById('specialGameCanvas');
      specialCtx = specialGameCanvas.getContext('2d');

      resetSpecialGame1();
      drawWaitingScreen(); // Отображаем начальный экран ожидания

      // Показываем кнопку копирования ссылки
      document.getElementById('copyButton').style.display = "block";

      findOrCreateRoom(); // Запускаем поиск/создание комнаты
    }

    function resetSpecialGame1() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      if (showOpponentNameTimeout) {
        clearTimeout(showOpponentNameTimeout);
        showOpponentNameTimeout = null;
      }
      roomId = null;
      playerId = null;
      opponentId = null;
      gameStateRef = null;
      localSnake = [];
      localDirection = 'right';
      score = 0;
      opponentSnake = [];
      opponentScore = 0;
      opponentName = 'Opponent';
      applePos = { x: 0, y: 0 };
      isGameRunning = false;
      isGameOver = false;
      countdownValue = 5;
      timerTotal = 60;
      timerCurrent = 60;
      inviteLink = "";
      removeSwipeListeners();
    }

    /* ======================================
       2. ПОИСК / СОЗДАНИЕ КОМНАТЫ
         Исключаем возможность подобрать себя.
    ===================================== */
    function findOrCreateRoom() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.once('value', (snapshot) => {
        const queueData = snapshot.val() || {};

        let openRoomKey = null;
        for (const key in queueData) {
          // Если в очереди уже есть запись, убедимся, что это не мы сами
          if (queueData[key].status === 'waiting' && key !== (window.currentUser ? window.currentUser.username : "")) {
            openRoomKey = key;
            break;
          }
        }

        if (openRoomKey) {
          // Присоединяемся как player2
          roomId = openRoomKey;
          playerId = 'player2';
          opponentId = 'player1';
          firebase.database().ref('snakeQueue/' + roomId)
            .update({ status: 'ready' })
            .catch((err) => console.error('Error updating room status:', err));
          setupGameReferences();
        } else {
          // Создаём новую комнату как player1
          roomId = queueRef.push().key;
          playerId = 'player1';
          opponentId = 'player2';
          queueRef.child(roomId).set({
            status: 'waiting',
            createdAt: firebase.database.ServerValue.TIMESTAMP
          }).catch((err) => console.error('Error creating room:', err));
          setupGameReferences();
        }

        // Формируем ссылку для приглашения (замените адрес на свой)
        inviteLink = "https://mygame.example.com/invite?room=" + roomId;
        waitForOpponent();
      }, (err) => {
        console.error('Error reading queue:', err);
      });
    }

    function waitForOpponent() {
      drawSearchScreen(); // Отрисовка экрана поиска (с розовым мигающим текстом)
      const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
      statusRef.on('value', (snapshot) => {
        const currentStatus = snapshot.val();
        if (currentStatus === 'ready') {
          statusRef.off();
          drawOpponentFoundScreen();
          showOpponentNameTimeout = setTimeout(() => {
            startCountdown();
          }, 2000);
        }
      });
    }

    /* ======================================
       3. НАСТРОЙКА gameStateRef И СЛУШАТЕЛЕЙ
    ===================================== */
    function setupGameReferences() {
      gameStateRef = firebase.database().ref('snakeGames/' + roomId);
      const playerRef = gameStateRef.child('players').child(playerId);
      playerRef.once('value', (snapshot) => {
        if (!snapshot.exists()) {
          // Стартовые точки
          let startX, startY;
          if (playerId === 'player1') {
            startX = 3;
            startY = Math.floor(tileCountY / 2);
          } else {
            startX = tileCountX - 4;
            startY = Math.floor(tileCountY / 2);
          }
          const initialSnake = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
          ];
          playerRef.set({
            snake: initialSnake,
            direction: 'right',
            score: 0,
            username: window.currentUser ? window.currentUser.username : 'Unknown'
          }).catch((err) => console.error('Error init player data:', err));
        }
      });
      // Подписка на данные соперника
      const oppRef = gameStateRef.child('players').child(opponentId);
      oppRef.on('value', (snap) => {
        const oppData = snap.val() || {};
        opponentSnake = oppData.snake || [];
        opponentScore = oppData.score || 0;
        opponentName = oppData.username || 'Opponent';
      });
      // Подписка на яблоко
      gameStateRef.child('apple').on('value', (snapshot) => {
        const aData = snapshot.val() || {};
        if (typeof aData.x === 'number' && typeof aData.y === 'number') {
          applePos.x = aData.x;
          applePos.y = aData.y;
        }
      });
      // Подписка на gameOver
      gameStateRef.child('gameOver').on('value', (snapshot) => {
        if (snapshot.val() === true && !isGameOver) {
          isGameOver = true;
          endGame();
        }
      });
    }

    /* ======================================
       4. ОБРАТНЫЙ ОТСЧЁТ (5...1) И СТАРТ
    ===================================== */
    function startCountdown() {
      countdownValue = 5;
      countdownInterval = setInterval(() => {
        drawCountdownScreen(countdownValue);
        countdownValue--;
        if (countdownValue < 1) {
          clearInterval(countdownInterval);
          launchGame();
        }
      }, 1000);
    }

    function launchGame() {
      isGameRunning = true;
      isGameOver = false;
      gameStateRef.child('players').child(playerId).once('value', (snapshot) => {
        const data = snapshot.val();
        if (data && data.snake) {
          localSnake = data.snake;
        }
        localDirection = (data && data.direction) ? data.direction : 'right';
        score = (data && data.score) ? data.score : 0;
        // Если яблоко отсутствует – создаём его
        gameStateRef.child('apple').once('value', (appleSnap) => {
          if (!appleSnap.exists()) {
            spawnApple();
          }
        });
        addSwipeListeners();
        startLogicLoop();
        startTimer();
        requestAnimationFrame(renderLoop);
      });
    }

    /* ======================================
       5. ЛОГИКА И ОТРИСОВКА
    ===================================== */
    function startLogicLoop() {
      logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
    }

    function stopLogicLoop() {
      if (logicTimer) {
        clearInterval(logicTimer);
        logicTimer = null;
      }
    }

    function gameLogicUpdate() {
      if (!isGameRunning || isGameOver) return;
      moveLocalSnake();
      // Проверяем столкновение с собственной змейкой – при этом игра завершается.
      if (checkSelfCollision()) {
        setGameOver();
        return;
      }
      // Столкновения с соперником больше не убивают змейку.
      const head = localSnake[0];
      if (head.x === applePos.x && head.y === applePos.y) {
        score++;
        updatePlayerState(true);
        spawnApple();
      } else {
        updatePlayerState(false);
      }
    }

    function renderLoop() {
      renderGame();
      if (!isGameOver) {
        requestAnimationFrame(renderLoop);
      }
    }

    /* ======================================
       6. ЛОГИКА ДВИЖЕНИЯ И СТОЛКНОВЕНИЯ
    ===================================== */
    function moveLocalSnake() {
      const head = { ...localSnake[0] };
      switch (localDirection) {
        case 'left':  head.x--; break;
        case 'right': head.x++; break;
        case 'up':    head.y--; break;
        case 'down':  head.y++; break;
      }
      // Проход через стены
      if (head.x < 0) head.x = tileCountX - 1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY - 1;
      if (head.y >= tileCountY) head.y = 0;
      localSnake.unshift(head);
      localSnake.pop();
    }

    function checkSelfCollision() {
      const head = localSnake[0];
      for (let i = 1; i < localSnake.length; i++) {
        if (localSnake[i].x === head.x && localSnake[i].y === head.y) {
          return true;
        }
      }
      return false;
    }

    /* ======================================
       7. ОБНОВЛЕНИЕ СОСТОЯНИЯ В FIREBASE
    ===================================== */
    function updatePlayerState(ateApple) {
      if (ateApple) {
        const lastSegment = localSnake[localSnake.length - 1];
        localSnake.push({ ...lastSegment });
      }
      gameStateRef.child('players').child(playerId).update({
        snake: localSnake,
        direction: localDirection,
        score: score
      }).catch((err) => console.error('Error updating player state:', err));
    }

    function spawnApple() {
      const newApple = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY)
      };
      gameStateRef.child('apple').set(newApple)
        .catch((err) => console.error('Error setting apple:', err));
    }

    /* ======================================
       8. ЗАВЕРШЕНИЕ ИГРЫ
    ===================================== */
    function setGameOver() {
      isGameOver = true;
      gameStateRef.update({ gameOver: true })
        .catch((err) => console.error('Error setting gameOver:', err));
      endGame();
    }

    function endGame() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      let resultTitle = 'Игра окончена';
      if (score > opponentScore) {
        resultTitle = 'Вы победили!';
      } else if (score < opponentScore) {
        resultTitle = 'Вы проиграли...';
      } else {
        resultTitle = 'Ничья';
      }
      const msg = `Ваш счёт: ${score} | Соперник: ${opponentScore}`;
      showEndGameModal(resultTitle, msg);
    }

    /* ======================================
       9. ТАЙМЕР (1 МИНУТА)
    ===================================== */
    function startTimer() {
      timerCurrent = timerTotal;
      const timerInterval = setInterval(() => {
        if (!isGameRunning || isGameOver) {
          clearInterval(timerInterval);
          return;
        }
        timerCurrent--;
        if (timerCurrent <= 0) {
          setGameOver();
          clearInterval(timerInterval);
        }
      }, 1000);
    }

    /* ======================================
       10. ОТРИСОВКА (renderGame)
    ===================================== */
    function renderGame() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = 'rgba(0,0,0,0.8)';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      drawMatrixGrid();
      // Яблоко
      specialCtx.fillStyle = '#FF0000';
      specialCtx.fillRect(
        GAME_AREA_X + applePos.x * gridSize,
        GAME_AREA_Y + applePos.y * gridSize,
        gridSize,
        gridSize
      );
      // Наша змейка
      specialCtx.fillStyle = snakeColors[playerId] || '#800080';
      localSnake.forEach(seg => {
        specialCtx.fillRect(
          GAME_AREA_X + seg.x * gridSize,
          GAME_AREA_Y + seg.y * gridSize,
          gridSize,
          gridSize
        );
      });
      // Змейка соперника
      specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
      opponentSnake.forEach(seg => {
        specialCtx.fillRect(
          GAME_AREA_X + seg.x * gridSize,
          GAME_AREA_Y + seg.y * gridSize,
          gridSize,
          gridSize
        );
      });
      // Имя соперника над его головой
      if (opponentSnake.length > 0) {
        const oppHead = opponentSnake[0];
        specialCtx.fillStyle = '#00FF00';
        specialCtx.font = '12px "Press Start 2P", sans-serif';
        specialCtx.fillText(
          opponentName,
          GAME_AREA_X + oppHead.x * gridSize,
          GAME_AREA_Y + oppHead.y * gridSize - 5
        );
      }
      // Имя игрока над головой
      if (localSnake.length > 0) {
        const myHead = localSnake[0];
        specialCtx.fillStyle = '#00FF00';
        specialCtx.font = '12px "Press Start 2P", sans-serif';
        const myName = window.currentUser ? window.currentUser.username : 'You';
        specialCtx.fillText(
          myName,
          GAME_AREA_X + myHead.x * gridSize,
          GAME_AREA_Y + myHead.y * gridSize - 5
        );
      }
      // Счёт
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '12px "Press Start 2P", sans-serif';
      specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 100, GAME_AREA_Y + 15);
      specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 100, GAME_AREA_Y + 30);
      // Тайм-бар
      const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
      specialCtx.fillStyle = '#00FF00';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
    }

    function drawMatrixGrid() {
      specialCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
      specialCtx.strokeStyle = 'rgba(0,255,0,0.3)';
      for (let i = 0; i <= tileCountX; i++) {
        let x = GAME_AREA_X + i * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(x, GAME_AREA_Y);
        specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
        specialCtx.stroke();
      }
      for (let j = 0; j <= tileCountY; j++) {
        let y = GAME_AREA_Y + j * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(GAME_AREA_X, y);
        specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
        specialCtx.stroke();
      }
      specialCtx.strokeStyle = 'rgb(0,255,0)';
      specialCtx.lineWidth = 2;
      specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
    }

    /* ======================================
       11. ЭКРАНЫ "ОЖИДАНИЕ / ПОИСК..."
    ===================================== */
    // Изменённый экран поиска: мигающий розовый текст с пиксельным шрифтом
    function drawSearchScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      // Розовый цвет для текста
      specialCtx.fillStyle = '#FF69B4';
      specialCtx.font = '16px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(
        'Search for opponent...',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2
      );
      // Вывод ссылки для приглашения (мелким шрифтом, чтобы влезало)
      specialCtx.font = '10px "Press Start 2P", sans-serif';
      specialCtx.fillText(
        'Invite friend:',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2 + 40
      );
      specialCtx.fillText(
        inviteLink,
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2 + 55
      );
      specialCtx.font = '8px "Press Start 2P", sans-serif';
      specialCtx.fillText(
        'Click "Copy Invite Link" below',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2 + 70
      );
    }

    function drawWaitingScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
    }

    // Экран найденного соперника: вывод фото и username
    function drawOpponentFoundScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      // Отрисовка фото соперника (если загружено)
      const img = new Image();
      img.src = opponentData.photo || 'https://img.icons8.com/ios-filled/50/FF69B4/user.png';
      img.onload = function() {
        specialCtx.drawImage(img, specialGameCanvas.width / 2 - 30, specialGameCanvas.height / 2 - 100, 60, 60);
        // Отрисовка username
        specialCtx.fillStyle = '#FF69B4';
        specialCtx.font = '16px "Press Start 2P", sans-serif';
        specialCtx.fillText(opponentData.username, specialGameCanvas.width / 2, specialGameCanvas.height / 2 - 20);
      }
    }

    /* ======================================
       12. ОБРАТНЫЙ ОТСЧЁТ (5..1)
    ===================================== */
    function drawCountdownScreen(value) {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '48px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(
        value.toString(),
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2
      );
    }

    /* ======================================
       13. УПРАВЛЕНИЕ (СВАЙП + КЛАВИШИ)
    ===================================== */
    function addSwipeListeners() {
      let touchStartX = null;
      let touchStartY = null;
      function onTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
      function onTouchMove(e) {
        e.preventDefault();
      }
      function onTouchEnd(e) {
        if (!touchStartX || !touchStartY) return;
        const touch = e.changedTouches[0];
        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0 && localDirection !== 'left') {
            localDirection = 'right';
          } else if (dx < 0 && localDirection !== 'right') {
            localDirection = 'left';
          }
        } else {
          if (dy > 0 && localDirection !== 'up') {
            localDirection = 'down';
          } else if (dy < 0 && localDirection !== 'down') {
            localDirection = 'up';
          }
        }
        touchStartX = null;
        touchStartY = null;
      }
      specialGameCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
      specialGameCanvas.addEventListener('touchmove', onTouchMove, { passive: false });
      specialGameCanvas.addEventListener('touchend', onTouchEnd, { passive: false });
      function onKeyDown(e) {
        switch (e.key) {
          case 'ArrowLeft':
            if (localDirection !== 'right') localDirection = 'left';
            break;
          case 'ArrowRight':
            if (localDirection !== 'left') localDirection = 'right';
            break;
          case 'ArrowUp':
            if (localDirection !== 'down') localDirection = 'up';
            break;
          case 'ArrowDown':
            if (localDirection !== 'up') localDirection = 'down';
            break;
        }
      }
      window.addEventListener('keydown', onKeyDown);
      window.__special_onKeyDown = onKeyDown;
      window.__special_onTouchStart = onTouchStart;
      window.__special_onTouchMove = onTouchMove;
      window.__special_onTouchEnd = onTouchEnd;
    }

    function removeSwipeListeners() {
      if (!specialGameCanvas) return;
      specialGameCanvas.removeEventListener('touchstart', window.__special_onTouchStart);
      specialGameCanvas.removeEventListener('touchmove', window.__special_onTouchMove);
      specialGameCanvas.removeEventListener('touchend', window.__special_onTouchEnd);
      window.removeEventListener('keydown', window.__special_onKeyDown);
      window.__special_onTouchStart = null;
      window.__special_onTouchMove = null;
      window.__special_onTouchEnd = null;
      window.__special_onKeyDown = null;
    }

    /* ======================================
       14. КОПИРОВАНИЕ ССЫЛКИ (inviteLink)
    ===================================== */
    function copyInviteLink() {
      if (!inviteLink) return;
      navigator.clipboard.writeText(inviteLink)
        .then(() => { console.log("Invite link copied:", inviteLink); })
        .catch(err => console.error("Error copying invite link:", err));
    }

    /* ======================================
       15. МОДАЛКА РЕЗУЛЬТАТОВ
    ===================================== */
    function showEndGameModal(title, message) {
      const modal = document.getElementById('endgameBackdrop');
      document.getElementById('endgameTitle').textContent = title;
      document.getElementById('endgameMessage').textContent = message;
      modal.classList.add('active');
    }

    /* ============================================================
       Подключите этот скрипт в HTML и вызовите initSpecialGame1() при загрузке.
    ============================================================ */
  </script>
  
  <script>
    // Функции завершения игры и переход на index.html
    function finishGame() {
      document.getElementById('endgameBackdrop').classList.remove('active');
      window.location.href = 'index.html';
    }
    function returnToMain() {
      window.location.href = 'index.html';
    }
    
    // Запуск игры после загрузки страницы и настройка Firebase
    window.addEventListener('load', () => {
      // Настройка Firebase (замените на свои реальные параметры)
     const firebaseConfig = {
      apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
      firebase.initializeApp(firebaseConfig);
      
      // Для корректной работы с Telegram Web App (если используется)
      window.currentUser = tg.initDataUnsafe.user;
      
      // Запускаем игру
      initSpecialGame1();
    });
  </script>
</body>
</html>
