<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" 
        content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>
  
  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Ваш CSS -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* Общие стили */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0f0;
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
    }
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background-color: #222;
      border: 2px solid #0f0;
      color: #0f0;
      cursor: pointer;
      border-radius: 8px;
      z-index: 1000;
      display: none;
      transition: background-color 0.3s;
    }
    #copyButton:hover {
      background-color: #333;
    }
    .endgame-backdrop, .modal-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .endgame-modal, .modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
    }
    @keyframes blink {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
    .blinking {
      animation: blink 1.2s infinite;
    }
  </style>
</head>
<body>
  <!-- Canvas -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>
  
  <!-- Invite Link Copy Button -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>
  
  <!-- Endgame Modal -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>
  
  <!-- "Not enough tickets" Modal -->
  <div id="noTicketsModal" class="modal-backdrop">
    <div class="modal">
      <h2>Not enough tickets</h2>
      <p>You do not have enough tickets to join the game.</p>
      <button onclick="returnToMain()">Return</button>
    </div>
  </div>
  
  <script>
    /* ======================
       1. Firebase Setup
    ======================= */
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_AUTH_DOMAIN",
      databaseURL: "YOUR_DB_URL",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_BUCKET",
      messagingSenderId: "YOUR_SENDER_ID",
      appId: "YOUR_APP_ID",
      measurementId: "YOUR_MEASUREMENT_ID"
    };
    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    
    /* ======================
       2. Global Vars
    ======================= */
    let specialGameCanvas, specialCtx;
    const GAME_AREA_X = 50, GAME_AREA_Y = 175,
          GAME_AREA_WIDTH = 300, GAME_AREA_HEIGHT = 500;
    const gridSize = 20;
    const tileCountX = GAME_AREA_WIDTH / gridSize;
    const tileCountY = GAME_AREA_HEIGHT / gridSize;
    let roomId = null,
        playerId = null,
        opponentId = null,
        gameStateRef = null;
    let localSnake = [],
        localDirection = 'right',
        score = 0;
    let opponentSnake = [],
        opponentScore = 0,
        opponentName = 'Opponent';  // Будем обновлять при получении данных
    let applePos = { x:0, y:0 };
    let isGameRunning = false,
        isGameOver = false,
        countdownValue = 5;
    let logicTimer = null,
        countdownInterval = null,
        showOpponentNameTimeout = null;
    let timerTotal = 60,
        timerCurrent = 60;
    const LOGIC_INTERVAL = 150; // скорость змейки
    let inviteLink = "";
    
    // Цвета змейки
    const snakeColors = {
      player1: '#800080',
      player2: '#FFFF00'
    };
    
    /* ======================
       3. Инициализация
    ======================= */
    function initSpecialGame1() {
      specialGameCanvas = document.getElementById('specialGameCanvas');
      specialCtx = specialGameCanvas.getContext('2d');
      resetSpecialGame1();
      drawWaitingScreen();
      findOrCreateRoom();
    }
    
    function resetSpecialGame1() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      if (showOpponentNameTimeout) {
        clearTimeout(showOpponentNameTimeout);
        showOpponentNameTimeout = null;
      }
      roomId = null;
      playerId = null;
      opponentId = null;
      gameStateRef = null;
      localSnake = [];
      localDirection = 'right';
      score = 0;
      opponentSnake = [];
      opponentScore = 0;
      opponentName = 'Opponent';
      applePos = { x:0, y:0 };
      isGameRunning = false;
      isGameOver = false;
      countdownValue = 5;
      timerTotal = 60;
      timerCurrent = 60;
      inviteLink = "";
      removeSwipeListeners();
    }
    
    /* ======================
       4. Поиск/создание комнаты
         И проверка на самоподбор (refresh)
    ======================= */
    function findOrCreateRoom() {
      const queueRef = firebase.database().ref('snakeQueue');
      // Сначала удаляем свою старую запись
      queueRef.child(currentUser.username).remove()
        .then(() => {
          queueRef.once('value').then((snap) => {
            const queueData = snap.val() || {};
            let openRoomKey = null;
            for (const key in queueData) {
              if (key !== currentUser.username && queueData[key].status === 'waiting') {
                openRoomKey = key;
                break;
              }
            }
            if (openRoomKey) {
              // Присоединяемся как player2
              roomId = openRoomKey;
              playerId = 'player2';
              opponentId = 'player1';
              firebase.database().ref('snakeQueue/' + roomId)
                .update({ status: 'ready' });
            } else {
              // Создаём новую комнату как player1
              roomId = queueRef.push().key;
              playerId = 'player1';
              opponentId = 'player2';
              queueRef.child(roomId).set({
                status: 'waiting',
                createdAt: firebase.database.ServerValue.TIMESTAMP
              });
            }
            // Линкуем основную логику
            setupGameReferences();
            // Генерируем inviteLink
            inviteLink = "https://mygame.example.com/invite?room=" + roomId;
            document.getElementById('copyButton').style.display = 'block';
            waitForOpponent();
          });
        });
    }
    
    function waitForOpponent() {
      drawSearchScreen();
      const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
      statusRef.on('value', (snap) => {
        const currentStatus = snap.val();
        if (currentStatus === 'ready') {
          statusRef.off();
          drawOpponentFoundScreen();
          document.getElementById('copyButton').style.display = 'none';
          
          showOpponentNameTimeout = setTimeout(() => {
            startCountdown();
          }, 2000);
        }
      });
    }
    
    /* ======================
       5. Настройка gameStateRef
    ======================= */
    function setupGameReferences() {
      gameStateRef = firebase.database().ref('snakeGames/' + roomId);
      // Игрок
      const playerRef = gameStateRef.child('players').child(playerId);
      playerRef.once('value').then((snap) => {
        if (!snap.exists()) {
          let startX, startY;
          if (playerId === 'player1') {
            startX = 3;
            startY = Math.floor(tileCountY / 2);
          } else {
            startX = tileCountX - 4;
            startY = Math.floor(tileCountY / 2);
          }
          const initSnake = [
            { x:startX,   y:startY },
            { x:startX-1, y:startY },
            { x:startX-2, y:startY }
          ];
          playerRef.set({
            snake: initSnake,
            direction: 'right',
            score: 0,
            username: currentUser.username
          });
        }
      });
      // Соперник
      const oppRef = gameStateRef.child('players').child(opponentId);
      oppRef.on('value', (snap) => {
        if (!snap.exists()) {
          // Opponent left or didn't exist
          if (isGameRunning) setGameOver();
          return;
        }
        const oppData = snap.val();
        opponentSnake = oppData.snake || [];
        opponentScore = oppData.score || 0;
        opponentName  = oppData.username || 'Opponent';
        // Если это тот же user => можно проверить/выдать ошибку, но обычно уже проверено
      });
      // Яблоко
      gameStateRef.child('apple').on('value', (snap) => {
        const a = snap.val() || {};
        if (typeof a.x === 'number' && typeof a.y === 'number') {
          applePos.x = a.x;
          applePos.y = a.y;
        }
      });
      // Флаг gameOver
      gameStateRef.child('gameOver').on('value', (snap) => {
        if (snap.val() === true && !isGameOver) {
          isGameOver = true;
          endGame();
        }
      });
    }
    
    /* ======================
       6. Обратный отсчёт и старт
    ======================= */
    function startCountdown() {
      countdownValue = 5;
      countdownInterval = setInterval(() => {
        drawCountdownScreen(countdownValue);
        countdownValue--;
        if (countdownValue < 1) {
          clearInterval(countdownInterval);
          launchGame();
        }
      }, 1000);
    }
    
    function launchGame() {
      isGameRunning = true;
      isGameOver = false;
      gameStateRef.child('players').child(playerId).once('value').then((snap) => {
        const d = snap.val();
        if (d && d.snake) localSnake = d.snake;
        localDirection = (d && d.direction) ? d.direction : 'right';
        score = (d && d.score) ? d.score : 0;
        gameStateRef.child('apple').once('value').then((aSnap) => {
          if (!aSnap.exists()) spawnApple();
        });
        addSwipeListeners();
        startLogicLoop();
        startTimer();
        requestAnimationFrame(renderLoop);
      });
    }
    
    /* ======================
       7. Логика и отрисовка
    ======================= */
    function startLogicLoop() {
      logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
    }
    function stopLogicLoop() {
      if (logicTimer) clearInterval(logicTimer);
      logicTimer = null;
    }
    function gameLogicUpdate() {
      if (!isGameRunning || isGameOver) return;
      moveLocalSnake();
      if (checkSelfCollision()) {
        setGameOver();
        return;
      }
      // Apple
      const head = localSnake[0];
      if (head.x === applePos.x && head.y === applePos.y) {
        score++;
        updatePlayerState(true);
        spawnApple();
      } else {
        updatePlayerState(false);
      }
    }
    function renderLoop() {
      renderGame();
      if (!isGameOver) requestAnimationFrame(renderLoop);
    }
    
    /* ======================
       8. Движение, столкновения
    ======================= */
    function moveLocalSnake() {
      const head = {...localSnake[0]};
      if (localDirection === 'left')  head.x--;
      if (localDirection === 'right') head.x++;
      if (localDirection === 'up')    head.y--;
      if (localDirection === 'down')  head.y++;
      if (head.x < 0) head.x = tileCountX-1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY-1;
      if (head.y >= tileCountY) head.y = 0;
      localSnake.unshift(head);
      localSnake.pop();
    }
    
    function checkSelfCollision() {
      const head = localSnake[0];
      for (let i=1; i<localSnake.length; i++){
        if (localSnake[i].x===head.x && localSnake[i].y===head.y) return true;
      }
      return false;
    }
    
    /* ======================
       9. Update Player State
    ======================= */
    function updatePlayerState(ateApple) {
      if (ateApple) {
        const lastSeg = localSnake[localSnake.length-1];
        localSnake.push({...lastSeg});
      }
      gameStateRef.child('players').child(playerId).update({
        snake: localSnake,
        direction: localDirection,
        score: score
      });
    }
    function spawnApple() {
      const newA = {
        x: Math.floor(Math.random()*tileCountX),
        y: Math.floor(Math.random()*tileCountY)
      };
      gameStateRef.child('apple').set(newA);
    }
    
    /* ======================
       10. Окончание игры
    ======================= */
    function setGameOver() {
      isGameOver = true;
      gameStateRef.update({gameOver:true});
      endGame();
    }
    function endGame() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      let resultTitle = 'Game Over';
      if (score > opponentScore) resultTitle='You Win!';
      else if (score<opponentScore) resultTitle='You Lose...';
      else resultTitle='Draw';
      const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
      showEndGameModal(resultTitle,msg);
    }
    
    /* ======================
       11. Таймер (1 мин)
    ======================= */
    function startTimer() {
      timerCurrent = timerTotal;
      const timerInt = setInterval(()=>{
        if (!isGameRunning || isGameOver) {
          clearInterval(timerInt);
          return;
        }
        timerCurrent--;
        if (timerCurrent<=0) {
          setGameOver();
          clearInterval(timerInt);
        }
      },1000);
    }
    
    /* ======================
       12. Рендер
    ======================= */
    function renderGame() {
      specialCtx.clearRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='rgba(0,0,0,0.8)';
      specialCtx.fillRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      
      drawMatrixGrid();
      
      // Apple
      specialCtx.fillStyle='#f00';
      specialCtx.fillRect(
        GAME_AREA_X + applePos.x*gridSize,
        GAME_AREA_Y + applePos.y*gridSize,
        gridSize, gridSize
      );
      
      // Our snake
      specialCtx.fillStyle = snakeColors[playerId] || '#800080';
      localSnake.forEach(seg=>{
        specialCtx.fillRect(
          GAME_AREA_X + seg.x*gridSize,
          GAME_AREA_Y + seg.y*gridSize,
          gridSize, gridSize
        );
      });
      
      // Opponent snake
      specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
      opponentSnake.forEach(seg=>{
        specialCtx.fillRect(
          GAME_AREA_X + seg.x*gridSize,
          GAME_AREA_Y + seg.y*gridSize,
          gridSize, gridSize
        );
      });
      
      // Opponent name above head
      if (opponentSnake.length>0) {
        const oppHead=opponentSnake[0];
        specialCtx.fillStyle='#0f0';
        specialCtx.font='12px "Press Start 2P"';
        specialCtx.fillText(
          opponentName,
          GAME_AREA_X + oppHead.x*gridSize,
          GAME_AREA_Y + oppHead.y*gridSize -5
        );
      }
      // Our name above head
      if (localSnake.length>0){
        const myHead=localSnake[0];
        specialCtx.fillStyle='#0f0';
        specialCtx.font='12px "Press Start 2P"';
        const myName = currentUser.username || 'You';
        specialCtx.fillText(
          myName,
          GAME_AREA_X + myHead.x*gridSize,
          GAME_AREA_Y + myHead.y*gridSize -5
        );
      }
      
      // Счёт
      specialCtx.fillStyle='#0f0';
      specialCtx.font='12px "Press Start 2P"';
      specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH -100, GAME_AREA_Y+15);
      specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH -100, GAME_AREA_Y+30);
      
      // Timer bar
      const barW = (timerCurrent/timerTotal)*GAME_AREA_WIDTH;
      specialCtx.fillStyle='#0f0';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y-5, barW,4);
    }
    
    function drawMatrixGrid() {
      specialCtx.fillStyle='rgba(0,0,0,0.5)';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
      
      specialCtx.strokeStyle='rgba(0,255,0,0.3)';
      for (let i=0; i<=tileCountX; i++){
        let x=GAME_AREA_X + i*gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(x,GAME_AREA_Y);
        specialCtx.lineTo(x,GAME_AREA_Y+GAME_AREA_HEIGHT);
        specialCtx.stroke();
      }
      for (let j=0;j<=tileCountY;j++){
        let y=GAME_AREA_Y + j*gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(GAME_AREA_X,y);
        specialCtx.lineTo(GAME_AREA_X+GAME_AREA_WIDTH,y);
        specialCtx.stroke();
      }
      specialCtx.strokeStyle='#0f0';
      specialCtx.lineWidth=2;
      specialCtx.strokeRect(GAME_AREA_X,GAME_AREA_Y,GAME_AREA_WIDTH,GAME_AREA_HEIGHT);
    }
    
    /* ======================
       13. Поисковые экраны
    ======================= */
    function drawSearchScreen() {
      specialCtx.clearRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#000';
      specialCtx.fillRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#0f0';
      specialCtx.font='16px "Press Start 2P"';
      specialCtx.textAlign='center';
      specialCtx.fillText('Searching for opponent...',specialGameCanvas.width/2, specialGameCanvas.height/2);
      
      specialCtx.font='10px "Press Start 2P"';
      specialCtx.fillText('Invite a friend:',specialGameCanvas.width/2, specialGameCanvas.height/2+40);
      specialCtx.fillText(inviteLink, specialGameCanvas.width/2, specialGameCanvas.height/2+60);
      
      specialCtx.font='8px "Press Start 2P"';
      specialCtx.fillText('Click to copy', specialGameCanvas.width/2, specialGameCanvas.height/2+80);
      document.getElementById('copyButton').style.display='block';
    }
    
    function drawWaitingScreen() {
      specialCtx.clearRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#000';
      specialCtx.fillRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
    }
    
    function drawOpponentFoundScreen() {
      specialCtx.clearRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#000';
      specialCtx.fillRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#0f0';
      specialCtx.font='16px "Press Start 2P"';
      specialCtx.textAlign='center';
      specialCtx.fillText('Opponent found',specialGameCanvas.width/2, specialGameCanvas.height/2);
    }
    
    function drawCountdownScreen(value) {
      specialCtx.clearRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#000';
      specialCtx.fillRect(0,0,specialGameCanvas.width,specialGameCanvas.height);
      specialCtx.fillStyle='#0f0';
      specialCtx.font='48px "Press Start 2P"';
      specialCtx.textAlign='center';
      specialCtx.fillText(value.toString(), specialGameCanvas.width/2, specialGameCanvas.height/2);
    }
    
    /* ======================
       14. Управление
    ======================= */
    function addSwipeListeners() {
      let touchStartX=0, touchStartY=0;
      function onTouchStart(e) {
        e.preventDefault();
        const t=e.touches[0];
        touchStartX=t.clientX; touchStartY=t.clientY;
      }
      function onTouchMove(e) { e.preventDefault(); }
      function onTouchEnd(e) {
        if (!touchStartX||!touchStartY) return;
        const t=e.changedTouches[0], dx=t.clientX-touchStartX, dy=t.clientY-touchStartY;
        if (Math.abs(dx)>Math.abs(dy)){
          if (dx>0 && localDirection!=='left') localDirection='right';
          else if (dx<0 && localDirection!=='right') localDirection='left';
        } else {
          if (dy>0 && localDirection!=='up') localDirection='down';
          else if (dy<0 && localDirection!=='down') localDirection='up';
        }
        touchStartX=0; touchStartY=0;
      }
      specialGameCanvas.addEventListener('touchstart', onTouchStart,{passive:false});
      specialGameCanvas.addEventListener('touchmove', onTouchMove,{passive:false});
      specialGameCanvas.addEventListener('touchend', onTouchEnd,{passive:false});
      function onKeyDown(e) {
        switch(e.key){
          case 'ArrowLeft': if(localDirection!=='right') localDirection='left'; break;
          case 'ArrowRight':if(localDirection!=='left')  localDirection='right';break;
          case 'ArrowUp':   if(localDirection!=='down')  localDirection='up';   break;
          case 'ArrowDown': if(localDirection!=='up')    localDirection='down'; break;
        }
      }
      window.addEventListener('keydown', onKeyDown);
      
      // Сохраняем для удаления
      window.__special_onKeyDown=onKeyDown;
      window.__special_onTouchStart=onTouchStart;
      window.__special_onTouchMove=onTouchMove;
      window.__special_onTouchEnd=onTouchEnd;
    }
    function removeSwipeListeners() {
      if(!specialGameCanvas) return;
      specialGameCanvas.removeEventListener('touchstart',window.__special_onTouchStart);
      specialGameCanvas.removeEventListener('touchmove',window.__special_onTouchMove);
      specialGameCanvas.removeEventListener('touchend',window.__special_onTouchEnd);
      window.removeEventListener('keydown',window.__special_onKeyDown);
      window.__special_onKeyDown=null;
      window.__special_onTouchStart=null;
      window.__special_onTouchMove=null;
      window.__special_onTouchEnd=null;
    }
    
    /* ======================
       15. Copy Invite Link
    ======================= */
    function copyInviteLink() {
      if (!inviteLink) return;
      navigator.clipboard.writeText(inviteLink)
        .then(()=>{ console.log("Invite link copied:", inviteLink); })
        .catch(err=> console.error("Error copying link:",err));
    }
    
    /* ======================
       16. Модальное окно итога
    ======================= */
    function showEndGameModal(title, message){
      const modal=document.getElementById('endgameBackdrop');
      document.getElementById('endgameTitle').textContent=title;
      document.getElementById('endgameMessage').textContent=message;
      modal.classList.add('active');
    }
  </script>
  
  <script>
    /* Функции модалок */
    function finishGame() {
      document.getElementById('endgameBackdrop').classList.remove('active');
      window.location.href='index.html';
    }
    function returnToMain(){
      document.getElementById('noTicketsModal').classList.remove('active');
      window.location.href='index.html';
    }
    
    // Инициализация
    window.addEventListener('load', ()=>{
      // Замените конфиг на ваш реальный
      const firebaseConfig = {
      apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
      if(!firebase.apps.length) firebase.initializeApp(config);
      
      // Если нет currentUser, создадим для теста
      if(!window.currentUser){
        window.currentUser={
          username:"TestUser",
          photo_url:"https://img.icons8.com/ios-filled/50/00FF00/user.png"
        };
      }
      
      initSpecialGame1();
    });
  </script>
</body>
</html>
