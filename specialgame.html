<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>
  
  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Your CSS -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API (если нужно) -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* Общие стили страницы */
    body {
      margin: 0;
      padding: 0;
      background: #00103c;
      color: #FF00FF;
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
      overflow: hidden;
    }
    
    /* Кнопка переключения языка и кнопки Back */
    #toggleLanguageBtn, #backToIndexBtn, #backToRefreshBtn {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 8px 14px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    #toggleLanguageBtn:hover, #backToIndexBtn:hover, #backToRefreshBtn:hover {
      transform: scale(1.05);
    }
    #toggleLanguageBtn:active, #backToIndexBtn:active, #backToRefreshBtn:active {
      transform: translateY(1px) scale(1.0);
    }

    #toggleLanguageBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 2001;
    }
    #backToIndexBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 2001;
    }
    #backToRefreshBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 2001;
      display: none; /* Изначально скрыт, показывается при поиске */
    }

    /* Canvas для игры */
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background-image: url('1.jpg'); /* Задний фон для канваса (если нужен) */
    }
    
    /* Кнопка копирования ссылки */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
    }
    #copyButton:hover {
      transform: scale(1.05);
    }
    #copyButton:active {
      animation: press 0.15s forwards;
      transform: translateY(1px) scale(1.0);
    }
    
    /* Модальные окна */
    .endgame-backdrop, .modal-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .endgame-modal, .modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
    }
    
    /* Анимация мигания */
    @keyframes blink {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
    .blinking {
      animation: blink 1.2s infinite;
    }
    
    /* Стили панели управления (если нужно) */
    #controlPanel {
      width: 150px;
      height: 150px;
      margin: 20px auto;
      position: relative;
    }
    #controlPanel .control-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background: #06B6D1;
      border: none;
      border-radius: 10px;
      color: #262626;
      font-size: 24px;
      font-family: 'Press Start 2P', sans-serif;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
      transition: transform 0.1s ease;
    }
    #btn-up {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }
    .control-button:hover {
      transform: scale(1.2);
    }
    .control-button:active {
      transform: translateY(1px) scale(1);
      box-shadow: 0 1px #6b6b6b;
    }
    
    /* Стили джойстика */
    #joystick {
      position: fixed;
      width: 100px;
      height: 100px;
      margin: -50px 0 0 -50px;
      background: rgba(100, 100, 100, 0.3);
      border: 2px solid rgba(200, 200, 200, 0.7);
      border-radius: 50%;
      display: none;
      z-index: 1000;
      touch-action: none;
    }
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      margin: -25px 0 0 -25px;
      background: rgba(200, 200, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      touch-action: none;
    }
    
    /* Стили обучающей (landing) страницы */
    #landingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #00103c, #0a0a23);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      color: #FF00FF;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    .landingContent {
      max-width: 600px;
      overflow-y: auto;
    }
    .landingContent img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
      border: 2px solid #FF00FF;
      border-radius: 8px;
    }
    .landingContent h1 {
      margin: 10px 0;
      font-size: 28px;
    }
    .landingContent p {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 20px;
      text-align: left;
    }
    .landingContent button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 14px;
      padding: 10px 20px;
      margin: 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
      transition: transform 0.1s ease;
    }
    .landingContent button:hover {
      transform: scale(1.05);
    }
    .landingContent button:active {
      transform: translateY(1px);
    }
    
  </style>
</head>
<body>
  <!-- Кнопка переключения языка (EN -> RU) -->
  <button id="toggleLanguageBtn">RU</button>
  <!-- Кнопка Back (на главном экране - ведёт на index.html) -->
  <button id="backToIndexBtn">Back</button>
  <!-- Кнопка Back (во время поиска - просто перезагружает страницу) -->
  <button id="backToRefreshBtn">Back</button>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>
  
  <!-- Обучающая (landing) страница -->
  <div id="landingScreen">
    <div class="landingContent">
      <img src="game_preview.jpg" alt="Game Preview">
      <h1 id="landingTitle">Special Snake PvP</h1>
      <p id="landingDescription">
        <!-- Текст будет меняться в зависимости от языка через JS -->
      </p>
      <button id="startSearchBtn">Start Search</button>
      <button id="cancelSearchBtn" style="display: none;">Cancel Search</button>
    </div>
  </div>

  <!-- Джойстик (для мобильных устройств) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- Кнопка для копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()" style="display: none;">Copy Invite Link</button>
  
  <!-- Модальное окно итогов -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()" id="endgameContinueBtn">Continue</button>
    </div>
  </div>
  
  <!-- Модальное окно "Not enough tickets" -->
  <div id="noTicketsModal" class="modal-backdrop">
    <div class="modal">
      <h2 id="noTicketsTitle">Not enough tickets</h2>
      <p id="noTicketsText">You do not have enough tickets to join the game.</p>
      <button onclick="returnToMain()" id="noTicketsReturnBtn">Return</button>
    </div>
  </div>
  
  <script>
/* 
============================================================
  0. ПЕРЕВОДЫ (ANGL/RUS)
============================================================
*/
const translations = {
  en: {
    landingTitle: "Special Snake PvP",
    landingDescription: "Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes decide the fate of every encounter! Control your unique snake in a retro-style arena with impressive visuals and an immersive soundtrack. Every second is a fight for survival: avoid collisions, collect bonuses, and outsmart your opponent in the labyrinth. Play with friends or random opponents in real-time and prove you're the true snake master!",
    startSearch: "Start Search",
    cancelSearch: "Cancel Search",
    searchingForOpponent: "Searching for opponent...",
    copyInviteLink: "Copy Invite Link",
    opponentFound: "Opponent found: ",
    gameOver: "Game Over!",
    youWin: "You Win!",
    youLose: "You Lose...",
    draw: "Draw",
    opponentDisconnected: "Opponent Disconnected. You Win!",
    yourScore: "Your score",
    opponentScore: "Opponent score",
    endgameContinue: "Continue",
    notEnoughTickets: "Not enough tickets",
    notEnoughTicketsText: "You do not have enough tickets to join the game.",
    returnBtn: "Return",
    back: "Back" // универсальный текст
  },
  ru: {
    landingTitle: "Special Snake PvP",
    landingDescription: "Добро пожаловать в Special Snake PvP – захватывающий мир динамичных PvP-сражений, где скорость, стратегия и рефлексы решают судьбу каждой битвы! Управляйте своей уникальной змеёй в ретро-стилистике с эффектной графикой и атмосферным звуковым сопровождением. Каждая секунда – это борьба за выживание: избегайте столкновений, собирайте бонусы и перехитрите соперника в лабиринте арены. Играйте с друзьями или случайными соперниками в реальном времени и докажите, что вы – настоящий мастер змей!",
    startSearch: "Начать поиск",
    cancelSearch: "Отмена поиска",
    searchingForOpponent: "Поиск соперника...",
    copyInviteLink: "Скопировать ссылку-приглашение",
    opponentFound: "Соперник найден: ",
    gameOver: "Конец игры!",
    youWin: "Вы победили!",
    youLose: "Вы проиграли...",
    draw: "Ничья",
    opponentDisconnected: "Соперник отключился. Вы победили!",
    yourScore: "Ваш счёт",
    opponentScore: "Счёт соперника",
    endgameContinue: "Продолжить",
    notEnoughTickets: "Недостаточно билетов",
    notEnoughTicketsText: "У вас недостаточно билетов, чтобы присоединиться к игре.",
    returnBtn: "Вернуться",
    back: "Назад"
  }
};

let currentLanguage = 'en';

/* 
============================================================
  1. ФУНКЦИЯ ДЛЯ ОБНОВЛЕНИЯ ТЕКСТА НА СТРАНИЦЕ ПРИ СМЕНЕ ЯЗЫКА
============================================================
*/
function updateLanguageText(lang) {
  // Заголовок и описание на landing-экране
  document.getElementById('landingTitle').textContent = translations[lang].landingTitle;
  document.getElementById('landingDescription').textContent = translations[lang].landingDescription;
  
  // Кнопки
  document.getElementById('startSearchBtn').textContent = translations[lang].startSearch;
  document.getElementById('cancelSearchBtn').textContent = translations[lang].cancelSearch;
  document.getElementById('copyButton').textContent = translations[lang].copyInviteLink;
  
  // Модальное окно "End Game"
  document.getElementById('endgameTitle').textContent = translations[lang].gameOver;
  document.getElementById('endgameContinueBtn').textContent = translations[lang].endgameContinue;
  
  // Модальное окно "Not enough tickets"
  document.getElementById('noTicketsTitle').textContent = translations[lang].notEnoughTickets;
  document.getElementById('noTicketsText').textContent = translations[lang].notEnoughTicketsText;
  document.getElementById('noTicketsReturnBtn').textContent = translations[lang].returnBtn;
  
  // Кнопки Back
  document.getElementById('backToIndexBtn').textContent = translations[lang].back;
  document.getElementById('backToRefreshBtn').textContent = translations[lang].back;
}

/* 
============================================================
  2. ПЕРЕКЛЮЧЕНИЕ ЯЗЫКА ПО КНОПКЕ (RU <-> EN)
============================================================
*/
function toggleLanguage() {
  if (currentLanguage === 'en') {
    currentLanguage = 'ru';
    document.getElementById('toggleLanguageBtn').textContent = 'EN';
  } else {
    currentLanguage = 'en';
    document.getElementById('toggleLanguageBtn').textContent = 'RU';
  }
  updateLanguageText(currentLanguage);
}

/* 
============================================================
  3. ОСНОВНОЙ ИГРОВОЙ КОД (ваш оригинальный, адаптированный)
============================================================
*/

// Глобальные переменные для canvas и контекста
let specialGameCanvas;
let specialCtx;

// Область игры (центрированная на canvas)
const GAME_AREA_X = 50;
const GAME_AREA_Y = 50;
const GAME_AREA_WIDTH = 300;
const GAME_AREA_HEIGHT = 500;

// Настройки сетки
const gridSize = 20;
const tileCountX = GAME_AREA_WIDTH / gridSize;
const tileCountY = GAME_AREA_HEIGHT / gridSize;

// Идентификаторы комнаты и игроков
let roomId = null;
let playerId = null;
let opponentId = null;
let gameStateRef = null;

// Локальное состояние змейки
let localSnake = [];
let localDirection = 'right';
let score = 0;

// Состояние змейки противника
let opponentSnake = [];
let opponentScore = 0;
let opponentName = '';

// Позиция яблока
let applePos = { x: 0, y: 0 };

// Флаги игры
let isGameRunning = false;
let isGameOver = false;
let countdownValue = 5;
let showOpponentNameTimeout = null;

// Таймер (1 минута)
let timerTotal = 60;
let timerCurrent = 60;

// Интервалы
let logicTimer = null;
let countdownInterval = null;

// Слушатели Firebase для отмены поиска
let waitingListener = null;
let oppListener = null;

// Цвета змейки
const snakeColors = {
  player1: '#FFFF00', // жёлтый
  player2: '#FF0000'  // красный
};

// Логический интервал (мс)
const LOGIC_INTERVAL = 150;

// Пригласительная ссылка
let inviteLink = "";

// Флаг отключения противника (авто-победа)
let opponentDisconnected = false;

/* ======================================
   ИНИЦИАЛИЗАЦИЯ ИГРЫ
====================================== */
function initSpecialGame1() {
  specialGameCanvas = document.getElementById('specialGameCanvas');
  specialCtx = specialGameCanvas.getContext('2d');

  resetSpecialGame1();
  drawWaitingScreen();
  
  // Настраиваем кнопки управления (если нужны кнопки-стрелки)
  setupControlButtons();
}

/* Сброс */
function resetSpecialGame1() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  if (showOpponentNameTimeout) {
    clearTimeout(showOpponentNameTimeout);
    showOpponentNameTimeout = null;
  }
  roomId = null;
  playerId = null;
  opponentId = null;
  gameStateRef = null;
  localSnake = [];
  localDirection = 'right';
  score = 0;
  opponentSnake = [];
  opponentScore = 0;
  opponentName = "";
  applePos = { x: 0, y: 0 };
  isGameRunning = false;
  isGameOver = false;
  countdownValue = 5;
  timerTotal = 60;
  timerCurrent = 60;
  inviteLink = "";
  
  if (waitingListener && roomId) {
    firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
    waitingListener = null;
  }
  if (oppListener && roomId) {
    firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
    oppListener = null;
  }
  removeSwipeListeners();
}

/* ======================================
   ПОИСК / СОЗДАНИЕ КОМНАТЫ
====================================== */
function findOrCreateRoom() {
  const queueRef = firebase.database().ref('snakeQueue');
  
  // Удаляем все "зависшие" комнаты, созданные этим пользователем
  queueRef.orderByChild('creator').equalTo(window.currentUser.username).once('value')
    .then(snapshot => {
      snapshot.forEach(childSnapshot => {
        childSnapshot.ref.remove();
      });
      return queueRef.once('value');
    })
    .then((snapshot) => {
      const queueData = snapshot.val() || {};
      let openRoomKey = null;

      // Ищем комнату со статусом "waiting", созданную другим пользователем
      for (const key in queueData) {
        if (queueData[key].status === 'waiting' && queueData[key].creator !== window.currentUser.username) {
          openRoomKey = key;
          break;
        }
      }
      if (openRoomKey) {
        // Присоединяемся как player2
        roomId = openRoomKey;
        playerId = 'player2';
        opponentId = 'player1';
        firebase.database().ref('snakeQueue/' + roomId)
          .update({ status: 'ready' })
          .catch((err) => console.error('Error updating room status:', err));
        setupGameReferences();
      } else {
        // Создаём новую комнату как player1
        roomId = queueRef.push().key;
        playerId = 'player1';
        opponentId = 'player2';
        queueRef.child(roomId).set({
          status: 'waiting',
          createdAt: firebase.database.ServerValue.TIMESTAMP,
          creator: window.currentUser.username
        }).catch((err) => console.error('Error creating room:', err));
        // Удаляем комнату при отключении создателя
        queueRef.child(roomId).onDisconnect().remove();
        setupGameReferences();
      }
      // Генерируем ссылку-приглашение
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';
      waitForOpponent();
    })
    .catch((err) => console.error('Error in findOrCreateRoom:', err));
}

/* ======================================
   ОЖИДАНИЕ ПРОТИВНИКА
====================================== */
function waitForOpponent() {
  drawSearchScreen();
  
  const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
  waitingListener = statusRef.on('value', async (snapshot) => {
    const currentStatus = snapshot.val();
    if (currentStatus === 'ready') {
      // Останавливаем слушание изменений статуса
      statusRef.off('value', waitingListener);
      waitingListener = null;
      
      // Получаем данные противника
      try {
        const oppSnapshot = await firebase.database()
          .ref('snakeGames/' + roomId + '/players/' + opponentId)
          .once('value');
        const oppData = oppSnapshot.val();
        if (oppData && oppData.username) {
          opponentName = oppData.username;
        }
      } catch(e) {
        console.error("Error reading opponent data: ", e);
      }

      drawOpponentFoundScreen();
      document.getElementById('copyButton').style.display = 'none';

      showOpponentNameTimeout = setTimeout(() => {
        startCountdown();
      }, 2000);
    }
  });

  // Следим за отключением противника
  const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
  oppListener = oppRef.on('value', (snapshot) => {
    const oppData = snapshot.val();
    if (oppData) {
      opponentSnake = oppData.snake || [];
      opponentScore = oppData.score || 0;
      opponentName  = oppData.username || "";
    } else {
      if (isGameRunning) {
        opponentDisconnected = true;
        setGameOver();
      }
    }
  });
}

/* ======================================
   НАСТРОЙКА gameStateRef + СЛУШАТЕЛИ
====================================== */
function setupGameReferences() {
  gameStateRef = firebase.database().ref('snakeGames/' + roomId);
  const playerRef = gameStateRef.child('players').child(playerId);

  playerRef.once('value').then((snapshot) => {
    if (!snapshot.exists()) {
      let startX, startY;
      if (playerId === 'player1') {
        startX = 3;
        startY = Math.floor(tileCountY / 2);
      } else {
        startX = tileCountX - 4;
        startY = Math.floor(tileCountY / 2);
      }
      const initialSnake = [
        { x: startX,     y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];
      playerRef.set({
        snake: initialSnake,
        direction: 'right',
        score: 0,
        username: window.currentUser ? window.currentUser.username : 'Unknown'
      }).catch((err) => console.error('Error initializing player data:', err));

      playerRef.onDisconnect().remove()
        .then(() => console.log("onDisconnect set for player:", playerId))
        .catch((err) => console.error("Error setting onDisconnect:", err));
    }
  });

  gameStateRef.child('apple').on('value', (snapshot) => {
    const aData = snapshot.val() || {};
    if (typeof aData.x === 'number' && typeof aData.y === 'number') {
      applePos.x = aData.x;
      applePos.y = aData.y;
    }
  });

  gameStateRef.child('gameOver').on('value', (snapshot) => {
    if (snapshot.val() === true && !isGameOver) {
      isGameOver = true;
      endGame();
    }
  });
}

/* ======================================
   ОБРАТНЫЙ ОТСЧЁТ (5...1) И СТАРТ ИГРЫ
====================================== */
function startCountdown() {
  countdownValue = 5;
  countdownInterval = setInterval(() => {
    drawCountdownScreen(countdownValue);
    countdownValue--;
    if (countdownValue < 1) {
      clearInterval(countdownInterval);
      launchGame();
    }
  }, 1000);
}

function launchGame() {
  isGameRunning = true;
  isGameOver = false;

  gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
    const data = snapshot.val();
    if (data && data.snake) {
      localSnake = data.snake;
    }
    localDirection = (data && data.direction) ? data.direction : 'right';
    score = (data && data.score) ? data.score : 0;

    gameStateRef.child('apple').once('value').then((appleSnap) => {
      if (!appleSnap.exists()) {
        spawnApple();
      }
    });

    addSwipeListeners();
    startLogicLoop();
    startTimer();
    requestAnimationFrame(renderLoop);
  });
}

/* ======================================
   ЛОГИКА ИГРЫ И РЕНДЕР
====================================== */
function startLogicLoop() {
  logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
}

function stopLogicLoop() {
  if (logicTimer) {
    clearInterval(logicTimer);
    logicTimer = null;
  }
}

function gameLogicUpdate() {
  if (!isGameRunning || isGameOver) return;

  moveLocalSnake();

  if (checkSelfCollision()) {
    setGameOver();
    return;
  }

  const head = localSnake[0];
  if (head.x === applePos.x && head.y === applePos.y) {
    score++;
    updatePlayerState(true);
    spawnApple();
  } else {
    updatePlayerState(false);
  }
}

function renderLoop() {
  renderGame();
  if (!isGameOver) {
    requestAnimationFrame(renderLoop);
  }
}

/* ======================================
   ДВИЖЕНИЕ И СТОЛКНОВЕНИЯ
====================================== */
function moveLocalSnake() {
  const head = { ...localSnake[0] };
  switch (localDirection) {
    case 'left':  head.x--; break;
    case 'right': head.x++; break;
    case 'up':    head.y--; break;
    case 'down':  head.y++; break;
  }
  // Обход границ
  if (head.x < 0) head.x = tileCountX - 1;
  if (head.x >= tileCountX) head.x = 0;
  if (head.y < 0) head.y = tileCountY - 1;
  if (head.y >= tileCountY) head.y = 0;
  localSnake.unshift(head);
  localSnake.pop();
}

function checkSelfCollision() {
  // Доп. логика на самопересечение, при необходимости
  return false;
}

/* ======================================
   ОБНОВЛЕНИЕ СОСТОЯНИЯ В FIREBASE
====================================== */
function updatePlayerState(ateApple) {
  if (ateApple) {
    const lastSegment = localSnake[localSnake.length - 1];
    localSnake.push({ ...lastSegment });
  }
  gameStateRef.child('players').child(playerId).update({
    snake: localSnake,
    direction: localDirection,
    score: score
  }).catch((err) => console.error('Error updating player state:', err));
}

function spawnApple() {
  const newApple = {
    x: Math.floor(Math.random() * tileCountX),
    y: Math.floor(Math.random() * tileCountY)
  };
  gameStateRef.child('apple').set(newApple)
    .catch((err) => console.error('Error setting apple:', err));
}

/* ======================================
   КОНЕЦ ИГРЫ
====================================== */
function setGameOver() {
  isGameOver = true;
  gameStateRef.update({ gameOver: true })
    .catch((err) => console.error('Error setting gameOver:', err));
  endGame();
}

function endGame() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  
  let resultTitle = translations[currentLanguage].gameOver; // "Game Over!"
  if (opponentDisconnected) {
    resultTitle = translations[currentLanguage].opponentDisconnected; 
  } else {
    if (score > opponentScore) {
      resultTitle = translations[currentLanguage].youWin;
    } else if (score < opponentScore) {
      resultTitle = translations[currentLanguage].youLose;
    } else {
      resultTitle = translations[currentLanguage].draw;
    }
  }

  const msg = `${translations[currentLanguage].yourScore}: ${score} | ${translations[currentLanguage].opponentScore}: ${opponentScore}`;
  showEndGameModal(resultTitle, msg);
  cleanupRoom();
}

/* ======================================
   ТАЙМЕР (1 минута)
====================================== */
function startTimer() {
  timerCurrent = timerTotal;
  const timerInterval = setInterval(() => {
    if (!isGameRunning || isGameOver) {
      clearInterval(timerInterval);
      return;
    }
    timerCurrent--;
    if (timerCurrent <= 0) {
      setGameOver();
      clearInterval(timerInterval);
    }
  }, 1000);
}

/* ======================================
   РЕНДЕР ИГРЫ
====================================== */
function renderGame() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  drawMatrixGrid();

  // Рисуем яблоко
  let appleImg = new Image();
  // Пример звезды (или поменяйте на вашу иконку)
  appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
  if (appleImg.complete) {
    specialCtx.drawImage(
      appleImg,
      GAME_AREA_X + applePos.x * gridSize,
      GAME_AREA_Y + applePos.y * gridSize,
      gridSize,
      gridSize
    );
  }

  // Рисуем локальную змейку
  localSnake.forEach(seg => {
    const x = GAME_AREA_X + seg.x * gridSize;
    const y = GAME_AREA_Y + seg.y * gridSize;
    specialCtx.fillStyle = snakeColors[playerId] || '#800080';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  });

  // Рисуем змейку противника
  opponentSnake.forEach(seg => {
    const x = GAME_AREA_X + seg.x * gridSize;
    const y = GAME_AREA_Y + seg.y * gridSize;
    specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  });

  // Имя противника над головой
  if (opponentSnake.length > 0) {
    const oppHead = opponentSnake[0];
    specialCtx.fillStyle = '#FFF';
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    specialCtx.fillText(
      opponentName ? ('@' + opponentName) : '@Anonymous',
      GAME_AREA_X + oppHead.x * gridSize,
      GAME_AREA_Y + oppHead.y * gridSize - 5
    );
  }

  // Имя игрока над головой
  if (localSnake.length > 0) {
    const myHead = localSnake[0];
    specialCtx.fillStyle = '#FFF';
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    const myName = window.currentUser ? window.currentUser.username : 'You';
    specialCtx.fillText(
      '@' + myName,
      GAME_AREA_X + myHead.x * gridSize,
      GAME_AREA_Y + myHead.y * gridSize - 5
    );
  }

  // Счёт
  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '12px "Press Start 2P", sans-serif';
  specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
  specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);

  // Таймер (в виде полоски)
  const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
  specialCtx.fillStyle = '#FF00FF';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
}

function drawMatrixGrid() {
  specialCtx.fillStyle = '#433171';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

  specialCtx.strokeStyle = '#00103c';
  for (let i = 0; i <= tileCountX; i++) {
    let x = GAME_AREA_X + i * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(x, GAME_AREA_Y);
    specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
    specialCtx.stroke();
  }
  for (let j = 0; j <= tileCountY; j++) {
    let y = GAME_AREA_Y + j * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(GAME_AREA_X, y);
    specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
    specialCtx.stroke();
  }
  specialCtx.strokeStyle = '#8F509D';
  specialCtx.lineWidth = 2;
  specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
}

/* ======================================
   ЭКРАН "SEARCHING / WAITING..."
====================================== */
function drawSearchScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '15px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(
    translations[currentLanguage].searchingForOpponent,
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
}

function drawWaitingScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#000';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
}

function drawOpponentFoundScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '16px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  const displayName = opponentName ? opponentName : "Anonymous";
  specialCtx.fillText(
    translations[currentLanguage].opponentFound + '@' + displayName,
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
}

function drawCountdownScreen(value) {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '60px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(value.toString(), specialGameCanvas.width / 2, specialGameCanvas.height / 2);
}

/* ======================================
   УПРАВЛЕНИЕ: ДЖОЙСТИК + КЛАВИАТУРА
====================================== */
function addSwipeListeners() {
  // Клавиатура
  function onKeyDown(e) {
    switch (e.key) {
      case 'ArrowLeft':
        if (localDirection !== 'right') localDirection = 'left';
        break;
      case 'ArrowRight':
        if (localDirection !== 'left') localDirection = 'right';
        break;
      case 'ArrowUp':
        if (localDirection !== 'down') localDirection = 'up';
        break;
      case 'ArrowDown':
        if (localDirection !== 'up') localDirection = 'down';
        break;
    }
  }
  window.addEventListener('keydown', onKeyDown);
  window.__joystick_keydown = onKeyDown;
  
  // Джойстик
  const canvas = specialGameCanvas;
  const joystick = document.getElementById('joystick');
  const joystickStick = document.getElementById('joystick-stick');
  let joystickActive = false;
  let joystickCenter = { x: 0, y: 0 };
  const maxDistance = 40;
  
  function handleTouchStart(e) {
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      joystickCenter.x = touch.clientX;
      joystickCenter.y = touch.clientY;
      joystick.style.left = joystickCenter.x + 'px';
      joystick.style.top = joystickCenter.y + 'px';
      joystick.style.display = 'block';
      joystickStick.style.transform = 'translate(0px, 0px)';
      joystickActive = true;
      e.preventDefault();
    }
  }
  
  function handleTouchMove(e) {
    if (!joystickActive) return;
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      let dx = touch.clientX - joystickCenter.x;
      let dy = touch.clientY - joystickCenter.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDistance;
        dy = Math.sin(angle) * maxDistance;
      }
      joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
      // Определяем направление
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && localDirection !== 'left') {
          localDirection = 'right';
        } else if (dx < 0 && localDirection !== 'right') {
          localDirection = 'left';
        }
      } else {
        if (dy > 0 && localDirection !== 'up') {
          localDirection = 'down';
        } else if (dy < 0 && localDirection !== 'down') {
          localDirection = 'up';
        }
      }
      e.preventDefault();
    }
  }
  
  function handleTouchEnd(e) {
    joystickActive = false;
    joystick.style.display = 'none';
    e.preventDefault();
  }
  
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
  
  window.__joystick_touchstart = handleTouchStart;
  window.__joystick_touchmove = handleTouchMove;
  window.__joystick_touchend = handleTouchEnd;
}

function removeSwipeListeners() {
  if (!specialGameCanvas) return;
  specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
  specialGameCanvas.removeEventListener('touchmove', window.__joystick_touchmove);
  specialGameCanvas.removeEventListener('touchend', window.__joystick_touchend);
  window.removeEventListener('keydown', window.__joystick_keydown);
  window.__joystick_touchstart = null;
  window.__joystick_touchmove = null;
  window.__joystick_touchend = null;
  window.__joystick_keydown = null;
}

/* ======================================
   КОПИРОВАНИЕ ССЫЛКИ
====================================== */
function copyInviteLink() {
  if (!inviteLink) return;
  navigator.clipboard.writeText(inviteLink)
    .then(() => { console.log("Invite link copied:", inviteLink); })
    .catch(err => console.error("Error copying invite link:", err));
}

/* ======================================
   МОДАЛЬНОЕ ОКНО КОНЦА ИГРЫ
====================================== */
function showEndGameModal(title, message) {
  const modal = document.getElementById('endgameBackdrop');
  const titleEl = document.getElementById('endgameTitle');
  const msgEl = document.getElementById('endgameMessage');
  titleEl.textContent = title;
  msgEl.textContent = message;
  modal.style.display = 'flex';
}

/* ======================================
   НАСТРОЙКА КНОПОК УПРАВЛЕНИЯ
====================================== */
function setupControlButtons() {
  const buttons = document.querySelectorAll('.control-button');
  buttons.forEach(button => {
    button.addEventListener('click', () => {
      const newDirection = button.getAttribute('data-direction');
      if ((localDirection === 'left'  && newDirection === 'right') ||
          (localDirection === 'right' && newDirection === 'left')  ||
          (localDirection === 'up'    && newDirection === 'down')  ||
          (localDirection === 'down'  && newDirection === 'up')) {
        return;
      }
      localDirection = newDirection;
    });
  });
}

/* ======================================
   ОТМЕНА ПОИСКА
====================================== */
function cancelSearch() {
  if (roomId) {
    const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
    if (waitingListener) {
      statusRef.off('value', waitingListener);
      waitingListener = null;
    }
    const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
    if (oppListener) {
      oppRef.off('value', oppListener);
      oppListener = null;
    }
    cleanupRoom();
  }
  resetSpecialGame1();
  document.getElementById('cancelSearchBtn').style.display = 'none';
  document.getElementById('landingScreen').style.display = 'flex';
  
  // Возвращаем исходный вид кнопок (язык, back и т.д.)
  document.getElementById('backToIndexBtn').style.display = 'block';
  document.getElementById('backToRefreshBtn').style.display = 'none';
  document.getElementById('toggleLanguageBtn').style.display = 'block';
}

/* ======================================
   УБОРКА КОМНАТЫ ПОСЛЕ ИГРЫ
====================================== */
function cleanupRoom() {
  if (roomId) {
    firebase.database().ref('snakeGames/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeGames."))
      .catch((err) => console.error("Error removing game room:", err));

    firebase.database().ref('snakeQueue/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeQueue."))
      .catch((err) => console.error("Error removing room from snakeQueue:", err));
  }
}

window.addEventListener('beforeunload', function() {
  if (roomId && gameStateRef) {
    gameStateRef.child('players').child(playerId).remove();
  }
});

/* ======================================
   ФИНИШ ИГРЫ И ВОЗВРАТ В МЕНЮ
====================================== */
function finishGame() {
  document.getElementById('endgameBackdrop').style.display = 'none';
  window.location.href = 'index.html';
}
function returnToMain() {
  document.getElementById('noTicketsModal').style.display = 'none';
  window.location.href = 'index.html';
}

/* ======================================
   СЛУШАТЕЛИ КНОПОК НА LANDING
====================================== */
document.getElementById('startSearchBtn').addEventListener('click', function(){
  // Скрываем экран обучения, показываем кнопку "cancelSearch"
  document.getElementById('landingScreen').style.display = 'none';
  document.getElementById('cancelSearchBtn').style.display = 'block';
  
  // Прячем кнопку переключения языка (согласно требованию)
  document.getElementById('toggleLanguageBtn').style.display = 'none';
  
  // Меняем кнопку Back: скрываем backToIndexBtn, показываем backToRefreshBtn
  document.getElementById('backToIndexBtn').style.display = 'none';
  document.getElementById('backToRefreshBtn').style.display = 'block';

  findOrCreateRoom();
});

document.getElementById('cancelSearchBtn').addEventListener('click', function(){
  cancelSearch();
});

/* ======================================
   ОБРАБОТКА КНОПОК BACK
====================================== */
document.getElementById('backToIndexBtn').addEventListener('click', function() {
  // Кнопка Back на главном экране – ведёт на index.html
  window.location.href = 'index.html';
});
document.getElementById('backToRefreshBtn').addEventListener('click', function() {
  // Кнопка Back во время поиска – перезагружает страницу
  window.location.reload();
});

/* ======================================
   СЛУШАТЕЛЬ ДЛЯ КНОПКИ СМЕНЫ ЯЗЫКА
====================================== */
document.getElementById('toggleLanguageBtn').addEventListener('click', toggleLanguage);

/* ======================================
   ЗАПУСК ПРИ ЗАГРУЗКЕ
====================================== */
window.addEventListener('load', () => {
  // Инициализация Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
    authDomain: "test-with-likes.firebaseapp.com",
    databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
    projectId: "test-with-likes",
    storageBucket: "test-with-likes.appspot.com",
    messagingSenderId: "764738820142",
    appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
    measurementId: "G-WJNF0HSN9P"
  };
  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
  }

  // Псевдо-логика для currentUser
  if (!window.currentUser) {
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      const tgUser = Telegram.WebApp.initDataUnsafe.user;
      window.currentUser = {
        username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
        photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
      };
    } else {
      window.currentUser = {
        username: "TestUser",
        photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
      };
    }
  }

  // Запуск игры
  initSpecialGame1();
  
  // Устанавливаем язык по умолчанию (en) и обновляем текст
  updateLanguageText(currentLanguage);
});

function changeDirection(newDir) {
  if (
    (newDir === 'up'    && localDirection === 'down') ||
    (newDir === 'down'  && localDirection === 'up')   ||
    (newDir === 'left'  && localDirection === 'right')||
    (newDir === 'right' && localDirection === 'left')
  ) {
    return;
  }
  localDirection = newDir;
}
  </script>
</body>
</html>
