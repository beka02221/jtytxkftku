<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>

  <!-- Ретро-шрифт -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Подключение внешнего файла CSS (пример) -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* Ваши стили – оставляем как были */
    body {
      margin: 0; padding: 0;
      background: radial-gradient(circle, #0d0d0d, #1a1a1a);
      color: #e0e0e0;
      font-family: 'Roboto', sans-serif;
      overflow: hidden;
    }
    /* ... Остальные стили без изменений ... */

    /* Для удобства всё, как в предыдущих примерах */
  </style>
</head>
<body>
  <!-- Верхняя панель -->
  <div id="topBar">
    <button id="homeBackBtn">Back</button>
    <button id="coinButton" onclick="window.location.href='buy.html'">
      0m <img src="https://raw.githubusercontent.com/qnexst/404token/main/token.png" alt="Coins" width="20"/>
    </button>
    <button id="langToggleBtn">RU</button>
  </div>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>

  <!-- Обучающая страница -->
  <div id="landingScreen">
    <div class="landingContent">
      <h1 id="landingTitle">Special Snake PvP</h1>
      <p id="landingText">
        Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style...
      </p>
      <button id="createRoomBtn">Create Room</button>
      <button id="searchRoomBtn">Search Room</button>
      <button id="playFreeBtn">Play for Free</button>
    </div>
  </div>

  <!-- Модальное окно создания комнаты -->
  <div id="createRoomModal" class="modal-backdrop">
    <div class="modal create-room-modal">
      <h2 id="createRoomTitle">Create Room</h2>
      <p id="createRoomHint">Choose bet (in millions):</p>
      <div class="bet-container">
        <input type="range" id="betSlider" min="1" max="100" value="1" step="1">
        <span id="betValueDisplay">1 m</span>
      </div>
      <div class="bet-error" id="betError" style="display: none;">Not enough coins</div>
      <div class="modal-buttons">
        <button id="confirmCreateRoomBtn">Create</button>
        <button id="cancelCreateRoomBtn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно поиска комнат -->
  <div id="searchRoomModal" class="modal-backdrop full-screen">
    <div class="modal search-room-modal">
      <h2 id="searchRoomTitle">Search Rooms</h2>
      <button id="refreshRoomsBtn" class="refresh-button">Refresh</button>
      <div id="roomListContainer">
        <table id="roomListTable">
          <thead>
            <tr>
              <th>Creator</th>
              <th>Bet</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="roomList">
            <!-- Динамически -->
          </tbody>
        </table>
      </div>
      <button id="cancelSearchRoomBtn" class="back-button">Back</button>
    </div>
  </div>

  <!-- Кнопка Back для ожидания -->
  <button id="searchBackBtn">Back</button>

  <!-- Джойстик (для мобильных) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- Модальное окно итогов -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>

  <!-- Модальное окно недостатка монет -->
  <div id="insufficientModal" class="modal-backdrop">
    <div class="modal">
      <h2>Not enough coins</h2>
      <p>You don't have enough coins to join the game.</p>
      <button onclick="window.location.href='buy.html'">Top Up</button>
    </div>
  </div>

  <script>
    /* 
      =====================================================================================
       Special Snake PvP — обновлённый полный код с исправленной логикой победы/ничьей
      =====================================================================================
       1) Если score > opponentScore => победитель получает ставку * 2
       2) Если score < opponentScore => текущий игрок ничего не получает
       3) Если score === opponentScore => обоим возвращается своя ставка (по ставке * 1)
    */

    function formatNumber(num) {
      if(num >= 1e9) {
        return (num / 1e9).toFixed(1).replace(/\.0$/, '') + 'b';
      } else {
        return (num / 1e6).toFixed(1).replace(/\.0$/, '') + 'm';
      }
    }
    function formatScore(num) {
      return num.toString();
    }

    // Глобальные переменные
    let specialGameCanvas;
    let specialCtx;

    const GAME_AREA_X = 50;
    const GAME_AREA_Y = 50;
    const GAME_AREA_WIDTH = 300;
    const GAME_AREA_HEIGHT = 500;

    const gridSize = 20;
    const tileCountX = GAME_AREA_WIDTH / gridSize;
    const tileCountY = GAME_AREA_HEIGHT / gridSize;

    let roomId = null;
    let playerId = null;
    let opponentId = null;
    let gameStateRef = null;

    let localSnake = [];
    let localDirection = 'right';
    let score = 0;

    let previousSnake = [];
    let lastLogicUpdateTime = 0;

    let opponentSnake = [];
    let opponentScore = 0;
    let opponentName = '';

    let previousOpponentSnake = [];
    let lastOpponentUpdateTime = performance.now();

    let applePos = { x: 0, y: 0, eaten: null };

    let isGameRunning = false;
    let isGameOver = false;
    let showOpponentNameTimeout = null;

    let timerTotal = 60;
    let timerCurrent = 60;

    let logicTimer = null;
    let waitingListener = null;
    let oppListener = null;

    const snakeColors = {
      player1: '#FFFF00',
      player2: '#FF0000'
    };

    const LOGIC_INTERVAL = 150;
    let inviteLink = "";

    let opponentDisconnected = false;
    let currentCoins = 0;

    // Ссылки onDisconnect, чтобы отменять при штатном выходе
    let onDisconnectRoomRef = null;
    let onDisconnectGameRef = null;

    /* =======================
       1. ИНИЦИАЛИЗАЦИЯ
    ======================= */
    function initSpecialGame1() {
      specialGameCanvas = document.getElementById('specialGameCanvas');
      specialCtx = specialGameCanvas.getContext('2d');
      resetSpecialGame1();
      drawWaitingScreen();
      setupControlButtons();
    }

    function resetSpecialGame1() {
      stopLogicLoop();
      if (showOpponentNameTimeout) {
        clearTimeout(showOpponentNameTimeout);
        showOpponentNameTimeout = null;
      }
      roomId = null;
      playerId = null;
      opponentId = null;
      gameStateRef = null;
      localSnake = [];
      localDirection = 'right';
      score = 0;
      opponentSnake = [];
      opponentScore = 0;
      opponentName = "";
      applePos = { x: 0, y: 0, eaten: null };
      isGameRunning = false;
      isGameOver = false;
      timerTotal = 60;
      timerCurrent = 60;
      inviteLink = "";
      if (waitingListener && roomId) {
        firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
        waitingListener = null;
      }
      if (oppListener && roomId) {
        firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
        oppListener = null;
      }
      removeSwipeListeners();
    }

    /* =======================
       2. СОЗДАНИЕ/ПОИСК
    ======================= */
    function autoJoinFreeGame() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('bet').equalTo(0).once('value')
        .then(snapshot => {
          let found = false;
          snapshot.forEach(child => {
            const room = child.val();
            if (room.status === 'waiting' && room.creator !== window.currentUser.username) {
              joinRoom(child.key);
              found = true;
              return true;
            }
          });
          if (!found) {
            createRoom(0);
          }
        })
        .catch(err => {
          console.error(err);
          createRoom(0);
        });
    }

    // Транзакция для списания монет
    function deductUserCoins(amount) {
      const userRef = firebase.database().ref('users/' + window.currentUser.username);
      return userRef.transaction(function(currentData) {
        if (currentData) {
          if (currentData.coins >= amount * 1e6) {
            currentData.coins -= amount * 1e6;
            return currentData;
          } else {
            return; // прерывает транзакцию
          }
        }
        return;
      });
    }

    function showInsufficientModal() {
      document.getElementById('insufficientModal').style.display = 'flex';
    }

    function createRoom(bet) {
      actuallyCreateRoom(bet);
    }

    function showBetError() {
      const betErrorEl = document.getElementById('betError');
      betErrorEl.style.display = 'block';
      setTimeout(() => {
        betErrorEl.style.display = 'none';
      }, 3000);
    }

    function actuallyCreateRoom(bet) {
      const queueRef = firebase.database().ref('snakeQueue');
      roomId = queueRef.push().key;
      playerId = 'player1';
      opponentId = 'player2';

      // Создаём комнату со статусом waiting
      queueRef.child(roomId).set({
        status: 'waiting',
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        creator: window.currentUser.username,
        bet: bet
      }).catch(err => console.error('Error creating room:', err));

      // onDisconnect: если игрок исчез, комната удалится
      onDisconnectRoomRef = queueRef.child(roomId).onDisconnect();
      onDisconnectRoomRef.remove().catch((err) => console.error('Error setting onDisconnect:', err));

      document.getElementById('createRoomModal').style.display = 'none';
      drawWaitingScreen();
      setupGameReferences();
      waitForOpponent();
    }

    function searchRooms() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('status').equalTo('waiting').once('value')
        .then(snapshot => {
          const rooms = snapshot.val();
          const roomListBody = document.getElementById('roomList');
          roomListBody.innerHTML = '';
          if (rooms) {
            Object.keys(rooms).forEach(roomKey => {
              const room = rooms[roomKey];
              if (room.creator === window.currentUser.username) return;
              const tr = document.createElement('tr');

              const creatorTd = document.createElement('td');
              creatorTd.textContent = "@" + room.creator;
              tr.appendChild(creatorTd);

              const betTd = document.createElement('td');
              betTd.textContent = room.bet + " m";
              tr.appendChild(betTd);

              const actionTd = document.createElement('td');
              const joinBtn = document.createElement('button');
              joinBtn.textContent = "Join";
              joinBtn.addEventListener('click', function() {
                joinRoom(roomKey);
              });
              actionTd.appendChild(joinBtn);
              tr.appendChild(actionTd);

              roomListBody.appendChild(tr);
            });
          }
          if (!roomListBody.hasChildNodes()) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.setAttribute("colspan", "3");
            td.style.color = "#FF00FF";
            td.textContent = "No available rooms. Check back later.";
            tr.appendChild(td);
            roomListBody.appendChild(tr);
          }
        })
        .catch(err => console.error('Error searching rooms:', err));
    }

    function joinRoom(roomKey) {
      firebase.database().ref('snakeQueue/' + roomKey).once('value').then(snapshot => {
        const room = snapshot.val();
        if (!room) return;
        const bet = room.bet || 0;
        if (room.status !== 'waiting') {
          // Комната уже занята
          return;
        }
        if (bet > 0) {
          // Пытаемся списать ставку
          deductUserCoins(bet).then(result => {
            if (!result.committed) {
              showInsufficientModal();
              return;
            } else {
              proceedJoin(roomKey);
            }
          }).catch(err => {
            console.error(err);
            showInsufficientModal();
          });
        } else {
          proceedJoin(roomKey);
        }
      });
    }

    function proceedJoin(roomKey) {
      roomId = roomKey;
      playerId = 'player2';
      opponentId = 'player1';
      // Меняем статус комнаты на 'ready'
      firebase.database().ref('snakeQueue/' + roomId).update({ status: 'ready' })
        .catch(err => console.error('Error updating room status:', err));

      // Ставим onDisconnect на случай, если мы внезапно «пропадём»
      onDisconnectRoomRef = firebase.database().ref('snakeQueue/' + roomId).onDisconnect();
      onDisconnectRoomRef.remove().catch((err) => console.error('Error setting onDisconnect:', err));

      document.getElementById('searchRoomModal').style.display = 'none';
      drawWaitingScreen();
      setupGameReferences();
      waitForOpponent();
    }

    /* =======================
       3. ОЖИДАНИЕ СОПЕРНИКА
    ======================= */
    function waitForOpponent() {
      drawSearchScreen();
      document.getElementById('searchBackBtn').style.display = 'block';

      const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
      waitingListener = statusRef.on('value', async (snapshot) => {
        const currentStatus = snapshot.val();
        if (currentStatus === 'ready') {
          statusRef.off('value', waitingListener);
          waitingListener = null;

          document.getElementById('searchBackBtn').style.display = 'none';

          try {
            const oppSnapshot = await firebase.database()
              .ref('snakeGames/' + roomId + '/players/' + opponentId)
              .once('value');
            const oppData = oppSnapshot.val();
            if (oppData && oppData.username) {
              opponentName = oppData.username;
            }
          } catch (e) {
            console.error("Error reading opponent data: ", e);
          }
          // Если мы player1, то теперь списываем монеты (создатель платит при заходе оппонента)
          if (playerId === 'player1') {
            firebase.database().ref('snakeQueue/' + roomId + '/bet').once('value').then(snap => {
              const betValue = snap.val() || 0;
              if (betValue > 0) {
                deductUserCoins(betValue).then(result => {
                  if (!result.committed) {
                    showInsufficientModal();
                    cleanupRoom();
                  } else {
                    proceedWithOpponentFound();
                  }
                });
              } else {
                proceedWithOpponentFound();
              }
            });
          } else {
            proceedWithOpponentFound();
          }
        }
      });

      // Слежка за оппонентом
      oppListener = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId)
        .on('value', (snapshot) => {
          const oppData = snapshot.val();
          if (oppData) {
            previousOpponentSnake = opponentSnake.length ? opponentSnake.map(seg => ({ ...seg })) : (oppData.snake || []);
            opponentSnake = oppData.snake || [];
            opponentScore = oppData.score || 0;
            opponentName = oppData.username || 'Player';
            lastOpponentUpdateTime = performance.now();
          } else {
            // оппонент вышел
            if (isGameRunning) {
              opponentDisconnected = true;
              setGameOver();
            }
          }
        });
    }

    function proceedWithOpponentFound() {
      drawOpponentFoundScreen();
      document.getElementById('topBar').style.display = 'none';
      setTimeout(() => {
        startPreGameCountdown();
      }, 2000);
    }

    /* =======================
       4. gameStateRef и onDisconnect
    ======================= */
    function setupGameReferences() {
      gameStateRef = firebase.database().ref('snakeGames/' + roomId);

      const playerRef = gameStateRef.child('players').child(playerId);
      playerRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
          let startX, startY;
          if (playerId === 'player1') {
            startX = 3;
            startY = Math.floor(tileCountY / 2);
          } else {
            startX = tileCountX - 4;
            startY = Math.floor(tileCountY / 2);
          }
          const initialSnake = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
          ];
          playerRef.set({
            snake: initialSnake,
            direction: 'right',
            score: 0,
            username: window.currentUser.username || 'Player'
          }).catch(err => console.error('Error initializing player data:', err));
        }
      });

      // onDisconnect для snakeGames
      onDisconnectGameRef = gameStateRef.child('players').child(playerId).onDisconnect();
      onDisconnectGameRef.remove()
        .then(() => console.log("onDisconnect set for player:", playerId))
        .catch(err => console.error("Error setting onDisconnect:", err));

      // Слежка за яблоком
      gameStateRef.child('apple').on('value', (snapshot) => {
        const aData = snapshot.val() || {};
        if (typeof aData.x === 'number' && typeof aData.y === 'number') {
          applePos = {
            x: aData.x,
            y: aData.y,
            eaten: aData.eaten || null
          };
        }
      });

      // Защита от «двойного» gameOver
      gameStateRef.child('gameOver').on('value', (snapshot) => {
        if (snapshot.val() === true && !isGameOver) {
          isGameOver = true;
          endGame();
        }
      });
    }

    /* =======================
       5. ОТСЧЁТ ПЕРЕД СТАРТОМ
    ======================= */
    function startPreGameCountdown() {
      const totalTime = 15; 
      const startTime = performance.now();
      function countdownLoop() {
        const now = performance.now();
        const elapsed = (now - startTime) / 1000;
        const remaining = Math.max(totalTime - elapsed, 0);
        drawPreGameCountdownScreen(remaining);
        if (remaining > 0) {
          requestAnimationFrame(countdownLoop);
        } else {
          launchGame();
        }
      }
      countdownLoop();
    }

    function drawPreGameCountdownScreen(remaining) {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#1f1c2c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '60px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      const displayTime = Math.ceil(remaining);
      specialCtx.fillText(displayTime.toString(), specialGameCanvas.width / 2, specialGameCanvas.height / 3);
    }

    /* =======================
       6. СТАРТ ИГРЫ
    ======================= */
    function launchGame() {
      document.getElementById('topBar').style.display = 'none';
      isGameRunning = true;
      isGameOver = false;
      gameStateRef.child('players').child(playerId).once('value').then(snapshot => {
        const data = snapshot.val();
        if (data && data.snake) {
          localSnake = data.snake;
        }
        localDirection = (data && data.direction) ? data.direction : 'right';
        score = (data && data.score) ? data.score : 0;
        previousSnake = localSnake.map(seg => ({ ...seg }));
        lastLogicUpdateTime = performance.now();

        // Если мы хост (player1), то отвечаем за спавн первого яблока
        if (playerId === 'player1') {
          gameStateRef.child('apple').once('value').then(appleSnap => {
            if (!appleSnap.exists()) {
              spawnApple();
            }
          });
        }
        addSwipeListeners();
        startLogicLoop();
        startTimer();
        requestAnimationFrame(renderLoop);
      });
    }

    /* =======================
       7. ЛОГИКА И ТАЙМЕР
    ======================= */
    function startLogicLoop() {
      logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
    }

    function stopLogicLoop() {
      if (logicTimer) {
        clearInterval(logicTimer);
        logicTimer = null;
      }
    }

    function gameLogicUpdate() {
      if (!isGameRunning || isGameOver) return;

      previousSnake = localSnake.map(seg => ({ ...seg }));
      moveLocalSnake();
      lastLogicUpdateTime = performance.now();

      // Проверяем коллизию с собой
      if (checkSelfCollision()) {
        setGameOver();
        return;
      }

      // Попытка «съесть яблоко» – через транзакцию
      const head = localSnake[0];
      tryEatApple(head.x, head.y);
      
      // Обновляем положение/счёт (уже без учёта яблока, яблоко идёт транзакцией)
      updatePlayerState();
    }

    function startTimer() {
      timerCurrent = timerTotal;
      const timerInterval = setInterval(() => {
        if (!isGameRunning || isGameOver) {
          clearInterval(timerInterval);
          return;
        }
        timerCurrent--;
        if (timerCurrent <= 0) {
          setGameOver();
          clearInterval(timerInterval);
        }
      }, 1000);
    }

    /* =======================
       8. ДВИЖЕНИЕ ЗМЕЙКИ
    ======================= */
    function moveLocalSnake() {
      const head = { ...localSnake[0] };
      switch (localDirection) {
        case 'left': head.x--; break;
        case 'right': head.x++; break;
        case 'up': head.y--; break;
        case 'down': head.y++; break;
      }
      if (head.x < 0) head.x = tileCountX - 1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY - 1;
      if (head.y >= tileCountY) head.y = 0;
      localSnake.unshift(head);
      localSnake.pop();
    }

    function checkSelfCollision() {
      // Пример: если голова встала на любой другой сегмент
      const [head, ...body] = localSnake;
      return body.some(seg => seg.x === head.x && seg.y === head.y);
    }

    /* =======================
       9. ТРАНЗАКЦИЯ ПРИ ПОЕДАНИИ ЯБЛОКА
    ======================= */
    function tryEatApple(headX, headY) {
      const appleRef = gameStateRef.child('apple');
      appleRef.transaction((appleData) => {
        if (!appleData) return appleData;
        // Если яблоко ещё не съедено и координаты совпадают с головой змейки
        if (!appleData.eaten && appleData.x === headX && appleData.y === headY) {
          appleData.eaten = playerId; // Помечаем, что съедено
        }
        return appleData;
      }).then((result) => {
        if (result.committed && result.snapshot.val()) {
          const newAppleData = result.snapshot.val();
          // Если действительно «пометили» яблоко (т. е. мы съели)
          if (newAppleData.eaten === playerId) {
            // Увеличиваем счёт
            score++;
            // Увеличиваем длину змейки
            const lastSegment = localSnake[localSnake.length - 1];
            localSnake.push({ ...lastSegment });
            
            // Обновляем состояние игрока
            updatePlayerState();

            // Новый спавн яблока – делает хост (player1)
            if (playerId === 'player1') {
              spawnApple();
            }
          }
        }
      });
    }

    /* =======================
       10. ОБНОВЛЕНИЕ СОСТОЯНИЯ
    ======================= */
    function updatePlayerState() {
      gameStateRef.child('players').child(playerId).update({
        snake: localSnake,
        direction: localDirection,
        score: score
      }).catch(err => console.error('Error updating player state:', err));
    }

    /* =======================
       11. СПАВН ЯБЛОКА (хост)
    ======================= */
    function spawnApple() {
      const newApple = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY),
        eaten: null
      };
      gameStateRef.child('apple').set(newApple)
        .catch(err => console.error('Error setting apple:', err));
    }

    /* =======================
       12. GAME OVER
    ======================= */
    function setGameOver() {
      // Транзакция: если gameOver ещё не true, ставим true
      gameStateRef.child('gameOver').transaction(prevVal => {
        if (!prevVal) return true;
        return prevVal;
      });
    }

    function endGame() {
      stopLogicLoop();
      // Распределяем ставки (победитель = всё, ничья = вернуть каждому)
      settleBets(() => {
        let resultTitle = '';
        if (score > opponentScore) {
          // Наш локальный игрок победил
          resultTitle = "You Win!";
        } else if (score < opponentScore) {
          // Проигрыш
          resultTitle = "You Lose...";
        } else {
          // Ничья
          resultTitle = "Draw";
        }
        const msg = `Your score: ${formatScore(score)} | Opponent: ${formatScore(opponentScore)}`;
        showEndGameModal(resultTitle, msg);
        cleanupRoom();
      });
    }

    /* =======================
       13. РАСПРЕДЕЛЕНИЕ СТАВОК (исправлено)
    ======================= */
    /*
      Правила:
       - Если score > opponentScore => текущий игрок получает "ставка × 2"
       - Если score < opponentScore => ничего не получает
       - Если score === opponentScore => возвращает себе "ставка"
    */
    function settleBets(onComplete) {
      firebase.database().ref('snakeQueue/' + roomId + '/bet').once('value').then(snapshot => {
        const betValue = snapshot.val() || 0;
        if (betValue > 0) {
          const userRef = firebase.database().ref('users/' + window.currentUser.username);
          userRef.transaction((currentData) => {
            if (currentData) {
              if (score > opponentScore) {
                // Победа: забираем весь банк (удвоенную ставку)
                currentData.coins = (currentData.coins || 0) + betValue * 1e6 * 2;
              } else if (score === opponentScore) {
                // Ничья: возвращаем свою ставку
                currentData.coins = (currentData.coins || 0) + betValue * 1e6;
              }
              // Если проиграл — ничего не добавляем
              return currentData;
            }
            return currentData;
          }).finally(() => {
            if (onComplete) onComplete();
          });
        } else {
          // Ставка = 0, делать нечего
          if (onComplete) onComplete();
        }
      });
    }

    /* =======================
       14. ОТРИСОВКА ИГРЫ
    ======================= */
    function renderLoop() {
      renderGame();
      if (!isGameOver) {
        requestAnimationFrame(renderLoop);
      }
    }

    function renderGame() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00103c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      drawMatrixGrid();

      const now = performance.now();
      const factor = Math.min((now - lastLogicUpdateTime) / LOGIC_INTERVAL, 1);

      // Рисуем яблоко (если не съедено)
      if (!applePos.eaten) {
        let appleImg = new Image();
        appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
        if (appleImg.complete) {
          specialCtx.drawImage(
            appleImg,
            GAME_AREA_X + applePos.x * gridSize,
            GAME_AREA_Y + applePos.y * gridSize,
            gridSize,
            gridSize
          );
        } else {
          // fallback
          specialCtx.fillStyle = '#FFAA00';
          specialCtx.fillRect(
            GAME_AREA_X + applePos.x * gridSize,
            GAME_AREA_Y + applePos.y * gridSize,
            gridSize,
            gridSize
          );
        }
      }

      // Рисуем змею локального игрока
      for (let i = 0; i < localSnake.length; i++) {
        const curr = localSnake[i];
        const prev = previousSnake[i] || curr;
        const interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
        const interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
        const x = GAME_AREA_X + interpX * gridSize;
        const y = GAME_AREA_Y + interpY * gridSize;
        specialCtx.fillStyle = snakeColors[playerId] || '#800080';
        specialCtx.fillRect(x, y, gridSize, gridSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(x, y, gridSize, gridSize);
      }

      // Рисуем змею оппонента
      const opponentFactor = Math.min((now - lastOpponentUpdateTime) / LOGIC_INTERVAL, 1);
      for (let i = 0; i < opponentSnake.length; i++) {
        const curr = opponentSnake[i];
        const prev = previousOpponentSnake[i] || curr;
        const interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
        const interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
        const x = GAME_AREA_X + interpX * gridSize;
        const y = GAME_AREA_Y + interpY * gridSize;
        specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
        specialCtx.fillRect(x, y, gridSize, gridSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(x, y, gridSize, gridSize);
      }

      // Счёт
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '12px "Press Start 2P", sans-serif';
      specialCtx.fillText(`Score: ${formatScore(score)}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
      specialCtx.fillText(`Opp: ${formatScore(opponentScore)}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);

      // Таймер
      const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
    }

    function interpolateCoordinate(prevVal, currVal, factor, maxVal) {
      let diff = currVal - prevVal;
      if (Math.abs(diff) > maxVal / 2) {
        if (diff > 0) diff -= maxVal;
        else diff += maxVal;
      }
      let interp = prevVal + diff * factor;
      if (interp < 0) interp += maxVal;
      if (interp >= maxVal) interp -= maxVal;
      return interp;
    }

    function drawMatrixGrid() {
      specialCtx.fillStyle = '#433171';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
      specialCtx.strokeStyle = '#00103c';
      for (let i = 0; i <= tileCountX; i++) {
        const x = GAME_AREA_X + i * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(x, GAME_AREA_Y);
        specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
        specialCtx.stroke();
      }
      for (let j = 0; j <= tileCountY; j++) {
        const y = GAME_AREA_Y + j * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(GAME_AREA_X, y);
        specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
        specialCtx.stroke();
      }
      specialCtx.strokeStyle = '#8F509D';
      specialCtx.lineWidth = 2;
      specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
    }

    /* =======================
       15. "WAITING / FOUND"
    ======================= */
    function drawSearchScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00103c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '15px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText('Searching for opponent...', specialGameCanvas.width / 2, specialGameCanvas.height / 2);
    }

    function drawWaitingScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
    }

    function drawOpponentFoundScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#1f1c2c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '16px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText('Opponent found!', specialGameCanvas.width / 2, specialGameCanvas.height / 2);
    }

    /* =======================
       16. УПРАВЛЕНИЕ (клава + тач)
    ======================= */
    function addSwipeListeners() {
      function onKeyDown(e) {
        switch (e.key) {
          case 'ArrowLeft':
            if (localDirection !== 'right') localDirection = 'left';
            break;
          case 'ArrowRight':
            if (localDirection !== 'left') localDirection = 'right';
            break;
          case 'ArrowUp':
            if (localDirection !== 'down') localDirection = 'up';
            break;
          case 'ArrowDown':
            if (localDirection !== 'up') localDirection = 'down';
            break;
        }
      }
      window.addEventListener('keydown', onKeyDown);
      window.__joystick_keydown = onKeyDown;

      const canvas = specialGameCanvas;
      const joystick = document.getElementById('joystick');
      const joystickStick = document.getElementById('joystick-stick');
      let joystickActive = false;
      let joystickCenter = { x: 0, y: 0 };
      const maxDistance = 40;

      function handleTouchStart(e) {
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          joystickCenter.x = touch.clientX;
          joystickCenter.y = touch.clientY;
          joystick.style.left = joystickCenter.x + 'px';
          joystick.style.top = joystickCenter.y + 'px';
          joystick.style.display = 'block';
          joystickStick.style.transform = 'translate(0px, 0px)';
          joystickActive = true;
          e.preventDefault();
        }
      }
      function handleTouchMove(e) {
        if (!joystickActive) return;
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          let dx = touch.clientX - joystickCenter.x;
          let dy = touch.clientY - joystickCenter.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > maxDistance) {
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * maxDistance;
            dy = Math.sin(angle) * maxDistance;
          }
          joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
          let angleDeg = Math.atan2(dy, dx) * (180 / Math.PI);
          if (angleDeg < 0) angleDeg += 360;

          // Определяем направление
          if (angleDeg >= 45 && angleDeg < 135) {
            if (localDirection !== 'up') localDirection = 'down';
          } else if (angleDeg >= 135 && angleDeg < 225) {
            if (localDirection !== 'right') localDirection = 'left';
          } else if (angleDeg >= 225 && angleDeg < 315) {
            if (localDirection !== 'down') localDirection = 'up';
          } else {
            if (localDirection !== 'left') localDirection = 'right';
          }
          e.preventDefault();
        }
      }
      function handleTouchEnd(e) {
        joystickActive = false;
        joystick.style.display = 'none';
        e.preventDefault();
      }

      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

      window.__joystick_touchstart = handleTouchStart;
      window.__joystick_touchmove = handleTouchMove;
      window.__joystick_touchend = handleTouchEnd;
    }

    function removeSwipeListeners() {
      if (!specialGameCanvas) return;
      specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
      specialGameCanvas.removeEventListener('touchmove', window.__joystick_touchmove);
      specialGameCanvas.removeEventListener('touchend', window.__joystick_touchend);
      window.removeEventListener('keydown', window.__joystick_keydown);
      window.__joystick_touchstart = null;
      window.__joystick_touchmove = null;
      window.__joystick_touchend = null;
      window.__joystick_keydown = null;
    }

    /* =======================
       17. КОНЕЦ ИГРЫ (UI)
    ======================= */
    function showEndGameModal(title, message) {
      const modal = document.getElementById('endgameBackdrop');
      const titleEl = document.getElementById('endgameTitle');
      const msgEl = document.getElementById('endgameMessage');
      titleEl.textContent = title;
      msgEl.textContent = message;
      modal.classList.add('active');
      modal.style.display = 'flex';
    }

    /* =======================
       18. КНОПКИ УПРАВЛЕНИЯ
    ======================= */
    function setupControlButtons() {
      // Если есть кнопки-стрелки на экране – можно обработать
      const buttons = document.querySelectorAll('.control-button');
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          const newDirection = button.getAttribute('data-direction');
          if ((localDirection === 'left' && newDirection === 'right') ||
              (localDirection === 'right' && newDirection === 'left') ||
              (localDirection === 'up' && newDirection === 'down') ||
              (localDirection === 'down' && newDirection === 'up')) {
            return;
          }
          localDirection = newDirection;
        });
      });
    }

    /* =======================
       19. УДАЛЕНИЕ КОМНАТЫ
    ======================= */
    function cleanupRoom() {
      if (onDisconnectRoomRef) {
        onDisconnectRoomRef.cancel().catch(err => console.error("Error canceling onDisconnect:", err));
        onDisconnectRoomRef = null;
      }
      if (onDisconnectGameRef) {
        onDisconnectGameRef.cancel().catch(err => console.error("Error canceling onDisconnect:", err));
        onDisconnectGameRef = null;
      }
      if (roomId) {
        firebase.database().ref('snakeGames/' + roomId).remove()
          .catch(err => console.error("Error removing game room:", err));
        firebase.database().ref('snakeQueue/' + roomId).remove()
          .catch(err => console.error("Error removing room from snakeQueue:", err));
      }
    }

    window.addEventListener('beforeunload', function() {
      // Если игрок внезапно «закрывает вкладку»
      if (roomId && gameStateRef) {
        gameStateRef.child('players').child(playerId).remove();
      }
    });

    /* =======================
       20. КНОПКА "FINISH"
    ======================= */
    function finishGame() {
      document.getElementById('endgameBackdrop').classList.remove('active');
      document.getElementById('endgameBackdrop').style.display = 'none';
      window.location.href = 'index.html';
    }
    function returnToMain() {
      window.location.href = 'index.html';
    }

    /* =======================
       21. СЛУШАТЕЛИ КНОПОК (Landing)
    ======================= */
    document.getElementById('createRoomBtn').addEventListener('click', function() {
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      document.getElementById('createRoomModal').style.display = 'flex';
    });

    document.getElementById('searchRoomBtn').addEventListener('click', function() {
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      document.getElementById('searchRoomModal').style.display = 'flex';
      searchRooms();
    });

    document.getElementById('playFreeBtn').addEventListener('click', function() {
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      autoJoinFreeGame();
    });

    document.getElementById('cancelCreateRoomBtn').addEventListener('click', function() {
      document.getElementById('createRoomModal').style.display = 'none';
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
    });

    document.getElementById('confirmCreateRoomBtn').addEventListener('click', function() {
      const betValue = parseInt(document.getElementById('betSlider').value);
      if (currentCoins < betValue * 1e6) {
        showBetError();
        return;
      }
      createRoom(betValue);
    });

    document.getElementById('betSlider').addEventListener('input', function() {
      const value = document.getElementById('betSlider').value;
      document.getElementById('betValueDisplay').textContent = value + " m";
    });

    document.getElementById('cancelSearchRoomBtn').addEventListener('click', function() {
      document.getElementById('searchRoomModal').style.display = 'none';
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
    });

    document.getElementById('refreshRoomsBtn').addEventListener('click', function() {
      searchRooms();
    });

    document.getElementById('searchBackBtn').addEventListener('click', function() {
      cleanupRoom();
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
      document.getElementById('searchBackBtn').style.display = 'none';
    });

    /* =======================
       22. ЗАПУСК ПРИ LOAD
    ======================= */
    window.addEventListener('load', () => {
      const firebaseConfig = {
        apiKey: "AIzaSyB90ev...",
        authDomain: "test-with-likes.firebaseapp.com",
        databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
        projectId: "test-with-likes",
        storageBucket: "test-with-likes.appspot.com",
        messagingSenderId: "764738820142",
        appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
        measurementId: "G-WJNF0HSN9P"
      };
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      if (!window.currentUser) {
        if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
          const tgUser = Telegram.WebApp.initDataUnsafe.user;
          window.currentUser = {
            username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
            photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
          };
        } else {
          window.currentUser = {
            username: "TestUser",
            photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
          };
        }
      }
      if (window.currentUser && window.currentUser.username) {
        const userRef = firebase.database().ref('users/' + window.currentUser.username);
        userRef.once('value').then(snapshot => {
          if (!snapshot.exists()) {
            userRef.set({
              coins: 0,
              tickets: 0,
              points: 0,
              lastSpinTime: 0
            });
          }
        });
        userRef.on('value', snapshot => {
          const data = snapshot.val() || {};
          const coins = data.coins || 0;
          currentCoins = coins;
          updateCoinDisplay(coins);
        });
      }
      initSpecialGame1();
    });

    function updateCoinDisplay(coins) {
      document.getElementById('coinButton').innerHTML =
        formatNumber(coins) + ' <img src="https://raw.githubusercontent.com/qnexst/404token/main/token.png" alt="Coins" width="20"/>';
    }

    /* =======================
       (Пример локализации, если нужно)
    ======================= */
    let currentLanguage = "en";
    const languageStrings = {
      en: {
        /* ... */
      },
      ru: {
        /* ... */
      }
    };
    function updateLanguageTexts() { /* ... */ }
    document.getElementById('langToggleBtn').addEventListener('click', function() {
      currentLanguage = currentLanguage === "en" ? "ru" : "en";
      updateLanguageTexts();
    });
    document.getElementById('homeBackBtn').addEventListener('click', function() {
      window.location.href = 'index.html';
    });
  </script>
</body>
</html>

