<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>

  <!-- Ретро-шрифт -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Подключение внешнего файла CSS, если нужно -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* Общие стили */
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle, #0d0d0d, #1a1a1a);
      color: #e0e0e0;
      font-family: 'Roboto', sans-serif;
      overflow: hidden;
    }
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Press Start 2P', cursive;
    }
    /* Верхняя панель */
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, #ff007f, #007fff);
      padding: 10px 20px;
      box-shadow: 0 0 15px rgba(255, 0, 127, 0.5), 0 0 15px rgba(0, 127, 255, 0.5);
      z-index: 2100;
    }
    #topBar button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 5px 10px;
      background: #111;
      color: #ff007f;
      border: 2px solid #ff007f;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.2s ease;
    }
    #topBar button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 10px #ff007f;
    }
    /* Canvas для игры */
    #specialGameCanvas {
      display: block;
      margin: 20px auto;
      background: url('1.jpg') no-repeat center center;
      background-size: cover;
      /* Границы убраны */
      border: none;
      border-radius: 8px;
    }
    /* Кнопка для копирования ссылки */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: #111;
      color: #ff007f;
      border: 2px solid #ff007f;
      border-radius: 4px;
      cursor: pointer;
      display: none;
      transition: transform 0.1s ease;
    }
    #copyButton:hover {
      transform: scale(1.05);
    }
    /* Модальные окна с плавной анимацией */
    .modal-backdrop, .endgame-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index: 999;
    }
    .modal-backdrop.active, .endgame-backdrop.active {
      visibility: visible;
      opacity: 1;
    }
    .modal, .endgame-modal {
      background: #1a1a1a;
      border: 3px solid #ff007f;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(255, 0, 127, 0.5);
      animation: fadeIn 0.3s ease;
    }
    /* Стилизация слайдера (окно создания комнаты) */
    .slider-container {
      margin: 20px 0;
    }
    #betSlider {
      -webkit-appearance: none;
      width: 100%;
      height: 10px;
      background: #333;
      border-radius: 5px;
      outline: none;
      transition: background 0.3s ease;
    }
    #betSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #ff007f;
      border: 2px solid #007fff;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    #betSlider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }
    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #ff007f;
    }
    /* Кнопки модальных окон */
    .modal-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: space-around;
    }
    .modal-buttons button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 10px 20px;
      background: #111;
      color: #ff007f;
      border: 2px solid #ff007f;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .modal-buttons button:hover {
      transform: scale(1.05);
    }
    /* Индикатор загрузки для поиска комнат */
    .loading {
      font-size: 14px;
      color: #FF00FF;
      margin: 10px 0;
    }
    /* Карточки комнат в окне поиска */
    .room-card {
      border: 2px solid #007fff;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #111;
      box-shadow: 0 0 10px #007fff;
    }
    .room-info p {
      margin: 4px 0;
      font-size: 12px;
    }
    .room-card button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Фиксированная кнопка Back (в режиме ожидания) */
    #searchBackBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      font-family: 'Press Start 2P', sans-serif;
      font-size: 14px;
      padding: 5px 10px;
      background: #111;
      color: #ff007f;
      border: 2px solid #ff007f;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 0 10px #ff007f;
      z-index: 3000;
      display: none;
      transition: transform 0.1s ease;
    }
    #searchBackBtn:hover {
      transform: scale(1.05);
    }
    /* Обучающая страница (landing) */
    #landingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #000, #1a1a1a);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      color: #e0e0e0;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    .landingContent {
      max-width: 600px;
      overflow-y: auto;
    }
    .landingContent img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
      border: 3px solid #007fff;
      border-radius: 8px;
      box-shadow: 0 0 10px #007fff;
    }
    .landingContent h1 {
      margin: 10px 0;
      font-size: 28px;
      color: #ff007f;
    }
    .landingContent p {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 10px;
      text-align: left;
      color: #e0e0e0;
    }
    .landingContent button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 14px;
      padding: 10px 20px;
      margin: 10px;
      background: #111;
      color: #ff007f;
      border: 2px solid #ff007f;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .landingContent button:hover {
      transform: scale(1.05);
    }
    .landingContent button:active {
      transform: translateY(1px);
    }
    /* Анимация появления */
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    /* Адаптивность для мобильных устройств */
    @media (max-width: 480px) {
      .modal {
        padding: 15px;
        max-width: 90%;
      }
      .modal-buttons button {
        font-size: 14px;
        padding: 12px 20px;
      }
      #betSlider {
        height: 12px;
      }
      #betSlider::-webkit-slider-thumb {
        width: 24px;
        height: 24px;
      }
    }
  </style>
</head>
<body>
  <!-- Верхняя панель -->
  <div id="topBar">
    <button id="homeBackBtn">Back</button>
    <button id="coinButton" onclick="window.location.href='buy.html'">
      0m <img src="https://raw.githubusercontent.com/qnexst/404token/main/token.png" alt="Coins" width="20"/>
    </button>
    <button id="langToggleBtn">RU</button>
  </div>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>

  <!-- Обучающая страница (landing) -->
  <div id="landingScreen">
    <div class="landingContent">
      <h1 id="landingTitle">Special Snake PvP</h1>
      <p id="landingText">
        Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!
      </p>
      <button id="createRoomBtn">Create Room</button>
      <button id="searchRoomBtn">Search Room</button>
      <button id="playFreeBtn">Play for Free</button>
    </div>
  </div>

  <!-- Модальное окно создания комнаты -->
  <div id="createRoomModal" class="modal-backdrop" role="dialog" aria-labelledby="createRoomTitle" aria-describedby="createRoomDesc">
    <div class="modal">
      <h2 id="createRoomTitle">Create Room</h2>
      <p id="createRoomDesc">Ставка (в млн): <span id="betValueDisplay">1</span></p>
      <div class="slider-container">
        <input type="range" id="betSlider" min="1" max="100" value="1" step="1">
        <div class="slider-labels">
          <span class="slider-min">1</span>
          <span class="slider-max">100</span>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="confirmCreateRoomBtn">Create</button>
        <button id="cancelCreateRoomBtn">Cancel</button>
      </div>
      <div id="creationHint" class="hint" aria-live="polite"></div>
    </div>
  </div>

  <!-- Модальное окно поиска комнат -->
  <div id="searchRoomModal" class="modal-backdrop" role="dialog" aria-labelledby="searchRoomTitle" aria-describedby="searchRoomDesc">
    <div class="modal">
      <h2 id="searchRoomTitle">Search Rooms</h2>
      <div class="filter-container">
        <label for="minBetFilter">Min Bet (m):</label>
        <input type="number" id="minBetFilter" min="1" value="1">
        <label for="maxBetFilter">Max Bet (m):</label>
        <input type="number" id="maxBetFilter" min="1" value="100">
        <button id="applyFilterBtn">Filter</button>
      </div>
      <div id="loadingIndicator" class="loading">Loading...</div>
      <div id="roomList" class="room-list">
        <!-- Карточки комнат будут генерироваться динамически -->
      </div>
      <div class="modal-buttons">
        <button id="refreshSearchBtn">Refresh</button>
        <button id="cancelSearchRoomBtn">Назад</button>
      </div>
    </div>
  </div>

  <!-- Кнопка Back для ожидания -->
  <button id="searchBackBtn">Back</button>

  <!-- Джойстик (для мобильных устройств) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- Кнопка для копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>

  <!-- Модальное окно итогов -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>

  <!-- Модальное окно недостатка монет -->
  <div id="insufficientModal" class="modal-backdrop">
    <div class="modal">
      <h2>Not enough coins</h2>
      <p>You don't have enough coins to join the game.</p>
      <button onclick="window.location.href='buy.html'">Top Up</button>
    </div>
  </div>

  <script>
    /* ============================================================
       Special Snake PvP – полный исправленный код с улучшенными
       окнами создания и поиска комнаты, адаптивностью и анимациями.
    ============================================================ */

    // Функции показа/скрытия модальных окон с анимацией
    function showModal(modalId) {
      const modal = document.getElementById(modalId);
      modal.classList.add('active');
      modal.style.display = 'flex';
    }
    function hideModal(modalId) {
      const modal = document.getElementById(modalId);
      modal.classList.remove('active');
      setTimeout(() => { modal.style.display = 'none'; }, 300);
    }

    // Функции форматирования
    function formatNumber(num) {
      if(num >= 1e9) {
        return (num / 1e9).toFixed(1).replace(/\.0$/, '') + 'b';
      } else {
        return (num / 1e6).toFixed(1).replace(/\.0$/, '') + 'm';
      }
    }
    function formatScore(num) {
      return num.toString();
    }

    // Глобальные переменные
    let specialGameCanvas, specialCtx;
    const GAME_AREA_X = 50, GAME_AREA_Y = 50, GAME_AREA_WIDTH = 300, GAME_AREA_HEIGHT = 500;
    const gridSize = 20, tileCountX = GAME_AREA_WIDTH / gridSize, tileCountY = GAME_AREA_HEIGHT / gridSize;
    let roomId = null, playerId = null, opponentId = null, gameStateRef = null;
    let localSnake = [], localDirection = 'right', score = 0;
    let previousSnake = [], lastLogicUpdateTime = 0;
    let opponentSnake = [], opponentScore = 0, opponentName = '';
    let previousOpponentSnake = [], lastOpponentUpdateTime = performance.now();
    let applePos = { x: 0, y: 0 };
    let isGameRunning = false, isGameOver = false, showOpponentNameTimeout = null;
    let timerTotal = 60, timerCurrent = 60, logicTimer = null;
    let waitingListener = null, oppListener = null;
    const snakeColors = { player1: '#FFFF00', player2: '#FF0000' };
    const LOGIC_INTERVAL = 150;
    let inviteLink = "";
    let opponentDisconnected = false;

    function interpolateCoordinate(prevVal, currVal, factor, maxVal) {
      let diff = currVal - prevVal;
      if (Math.abs(diff) > maxVal / 2) {
        if (diff > 0) diff -= maxVal;
        else diff += maxVal;
      }
      let interp = prevVal + diff * factor;
      if (interp < 0) interp += maxVal;
      if (interp >= maxVal) interp -= maxVal;
      return interp;
    }

    function initSpecialGame1() {
      specialGameCanvas = document.getElementById('specialGameCanvas');
      specialCtx = specialGameCanvas.getContext('2d');
      resetSpecialGame1();
      drawWaitingScreen();
      setupControlButtons();
    }

    function resetSpecialGame1() {
      stopLogicLoop();
      if (showOpponentNameTimeout) {
        clearTimeout(showOpponentNameTimeout);
        showOpponentNameTimeout = null;
      }
      roomId = null; playerId = null; opponentId = null; gameStateRef = null;
      localSnake = []; localDirection = 'right'; score = 0;
      opponentSnake = []; opponentScore = 0; opponentName = "";
      applePos = { x: 0, y: 0 };
      isGameRunning = false; isGameOver = false;
      timerTotal = 60; timerCurrent = 60;
      inviteLink = "";
      if (waitingListener && roomId) {
        firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
        waitingListener = null;
      }
      if (oppListener && roomId) {
        firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
        oppListener = null;
      }
      removeSwipeListeners();
    }

    function autoJoinFreeGame() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('bet').equalTo(0).once('value')
        .then(snapshot => {
          let found = false;
          snapshot.forEach(child => {
            const room = child.val();
            if (room.status === 'waiting' && room.creator !== window.currentUser.username) {
              joinRoom(child.key);
              found = true;
              return true;
            }
          });
          if (!found) {
            createRoom(0);
          }
        })
        .catch(err => {
          console.error(err);
          createRoom(0);
        });
    }

    function deductUserCoins(amount) {
      const userRef = firebase.database().ref('users/' + window.currentUser.username);
      return userRef.transaction(function(currentData) {
        if (currentData) {
          if (currentData.coins >= amount) {
            currentData.coins -= amount;
            return currentData;
          } else {
            return;
          }
        }
        return;
      });
    }

    function showInsufficientModal() {
      document.getElementById('insufficientModal').style.display = 'flex';
    }

    function createRoom(bet) {
      if (bet > 0) {
        deductUserCoins(bet).then(function(result) {
          if (!result.committed) {
            document.getElementById('creationHint').textContent = "Not enough coins!";
            return;
          } else {
            actuallyCreateRoom(bet);
          }
        }).catch(err => {
          console.error(err);
          document.getElementById('creationHint').textContent = "Error creating room!";
        });
      } else {
        actuallyCreateRoom(bet);
      }
    }

    function actuallyCreateRoom(bet) {
      const queueRef = firebase.database().ref('snakeQueue');
      roomId = queueRef.push().key;
      playerId = 'player1'; opponentId = 'player2';
      queueRef.child(roomId).set({
        status: 'waiting',
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        creator: window.currentUser.username,
        bet: bet
      }).catch(err => console.error('Error creating room:', err));
      queueRef.child(roomId).onDisconnect().remove();
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';
      hideModal('createRoomModal');
      drawWaitingScreen();
      setupGameReferences();
      waitForOpponent();
    }

    function searchRooms() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('status').equalTo('waiting').once('value')
        .then(snapshot => {
          const rooms = snapshot.val();
          const roomListDiv = document.getElementById('roomList');
          roomListDiv.innerHTML = '';
          if (rooms) {
            Object.keys(rooms).forEach(roomKey => {
              const room = rooms[roomKey];
              if (room.creator === window.currentUser.username) return;
              const card = document.createElement('div');
              card.className = 'room-card';
              card.innerHTML = `
                <div class="room-info">
                  <p><strong>@${room.creator}</strong></p>
                  <p>Bet: ${room.bet} m</p>
                  <p>${new Date(room.createdAt).toLocaleTimeString()}</p>
                </div>
                <button class="joinRoomBtn" data-room="${roomKey}">${languageStrings[currentLanguage].join}</button>
              `;
              roomListDiv.appendChild(card);
              card.querySelector('.joinRoomBtn').addEventListener('click', function() {
                joinRoom(roomKey);
              });
            });
          } else {
            roomListDiv.innerHTML = '<p style="color: #FF00FF;">No available rooms</p>';
          }
        })
        .catch(err => console.error('Error searching rooms:', err));
    }

    function joinRoom(roomKey) {
      firebase.database().ref('snakeQueue/' + roomKey).once('value').then(snapshot => {
        const room = snapshot.val();
        const bet = room.bet || 0;
        if (bet > 0) {
          deductUserCoins(bet).then(result => {
            if (!result.committed) {
              showInsufficientModal();
              return;
            } else {
              proceedJoin(roomKey);
            }
          }).catch(err => {
            console.error(err);
            showInsufficientModal();
          });
        } else {
          proceedJoin(roomKey);
        }
      });
    }

    function proceedJoin(roomKey) {
      roomId = roomKey;
      playerId = 'player2'; opponentId = 'player1';
      firebase.database().ref('snakeQueue/' + roomId).update({ status: 'ready' })
        .catch(err => console.error('Error updating room status:', err));
      setupGameReferences();
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';
      hideModal('searchRoomModal');
      drawWaitingScreen();
      waitForOpponent();
    }

    function waitForOpponent() {
      drawSearchScreen();
      document.getElementById('searchBackBtn').style.display = 'block';
      const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
      waitingListener = statusRef.on('value', async (snapshot) => {
        const currentStatus = snapshot.val();
        if (currentStatus === 'ready') {
          statusRef.off('value', waitingListener);
          waitingListener = null;
          document.getElementById('searchBackBtn').style.display = 'none';
          try {
            const oppSnapshot = await firebase.database()
              .ref('snakeGames/' + roomId + '/players/' + opponentId)
              .once('value');
            const oppData = oppSnapshot.val();
            if (oppData && oppData.username) {
              opponentName = oppData.username;
            }
          } catch (e) {
            console.error("Error reading opponent data: ", e);
          }
          drawOpponentFoundScreen();
          document.getElementById('copyButton').style.display = 'none';
          document.getElementById('topBar').style.display = 'none';
          showOpponentNameTimeout = setTimeout(() => {
            startPreGameCountdown();
          }, 2000);
        }
      });
      
      const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
      oppListener = oppRef.on('value', (snapshot) => {
        const oppData = snapshot.val();
        if (oppData) {
          previousOpponentSnake = opponentSnake.length ? opponentSnake.map(seg => ({ ...seg })) : (oppData.snake || []);
          opponentSnake = oppData.snake || [];
          opponentScore = oppData.score || 0;
          opponentName = (oppData.username && oppData.username.trim() !== "") ? oppData.username : 'Player';
          lastOpponentUpdateTime = performance.now();
        } else {
          if (isGameRunning) {
            opponentDisconnected = true;
            setGameOver();
          }
        }
      });
    }

    function setupGameReferences() {
      gameStateRef = firebase.database().ref('snakeGames/' + roomId);
      const playerRef = gameStateRef.child('players').child(playerId);
      playerRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
          let startX, startY;
          if (playerId === 'player1') {
            startX = 3;
            startY = Math.floor(tileCountY / 2);
          } else {
            startX = tileCountX - 4;
            startY = Math.floor(tileCountY / 2);
          }
          const initialSnake = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
          ];
          playerRef.set({
            snake: initialSnake,
            direction: 'right',
            score: 0,
            username: (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'Player'
          }).catch(err => console.error('Error initializing player data:', err));
          playerRef.onDisconnect().remove()
            .then(() => console.log("onDisconnect set for player:", playerId))
            .catch(err => console.error("Error setting onDisconnect:", err));
        }
      });
      gameStateRef.child('apple').on('value', (snapshot) => {
        const aData = snapshot.val() || {};
        if (typeof aData.x === 'number' && typeof aData.y === 'number') {
          applePos.x = aData.x;
          applePos.y = aData.y;
        }
      });
      gameStateRef.child('gameOver').on('value', (snapshot) => {
        if (snapshot.val() === true && !isGameOver) {
          isGameOver = true;
          endGame();
        }
      });
    }

    function startPreGameCountdown() {
      const totalTime = 15;
      const startTime = performance.now();
      function countdownLoop() {
        const now = performance.now();
        const elapsed = (now - startTime) / 1000;
        const remaining = Math.max(totalTime - elapsed, 0);
        drawPreGameCountdownScreen(remaining);
        if (remaining > 0) {
          requestAnimationFrame(countdownLoop);
        } else {
          launchGame();
        }
      }
      countdownLoop();
    }

    function drawPreGameCountdownScreen(remaining) {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#1f1c2c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '60px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      const displayTime = Math.ceil(remaining);
      specialCtx.fillText(displayTime.toString(), specialGameCanvas.width / 2, specialGameCanvas.height / 3);
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '20px "Press Start 2P", sans-serif';
      specialCtx.fillText("Your snake is", specialGameCanvas.width / 2, specialGameCanvas.height / 3 + 60);
      const segmentSize = 20;
      const numSegments = 3;
      const snakeLength = numSegments * segmentSize;
      const period = 3000;
      const animTime = performance.now() % period;
      const animX = (animTime / period) * (specialGameCanvas.width - snakeLength);
      const snakeY = specialGameCanvas.height / 3 + 90;
      specialCtx.fillStyle = snakeColors[playerId] || '#FFFF00';
      for (let i = 0; i < numSegments; i++) {
        const segX = animX + i * segmentSize;
        specialCtx.fillRect(segX, snakeY, segmentSize, segmentSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(segX, snakeY, segmentSize, segmentSize);
      }
    }

    function launchGame() {
      document.getElementById('topBar').style.display = 'none';
      isGameRunning = true;
      isGameOver = false;
      gameStateRef.child('players').child(playerId).once('value').then(snapshot => {
        const data = snapshot.val();
        if (data && data.snake) {
          localSnake = data.snake;
        }
        localDirection = (data && data.direction) ? data.direction : 'right';
        score = (data && data.score) ? data.score : 0;
        previousSnake = localSnake.map(seg => ({ ...seg }));
        lastLogicUpdateTime = performance.now();
        gameStateRef.child('apple').once('value').then(appleSnap => {
          if (!appleSnap.exists()) {
            spawnApple();
          }
        });
        addSwipeListeners();
        startLogicLoop();
        startTimer();
        requestAnimationFrame(renderLoop);
      });
    }

    function startLogicLoop() {
      logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
    }

    function stopLogicLoop() {
      if (logicTimer) {
        clearInterval(logicTimer);
        logicTimer = null;
      }
    }

    function gameLogicUpdate() {
      if (!isGameRunning || isGameOver) return;
      previousSnake = localSnake.map(seg => ({ ...seg }));
      moveLocalSnake();
      lastLogicUpdateTime = performance.now();
      if (checkSelfCollision()) {
        setGameOver();
        return;
      }
      const head = localSnake[0];
      if (head.x === applePos.x && head.y === applePos.y) {
        score++;
        updatePlayerState(true);
        spawnApple();
      } else {
        updatePlayerState(false);
      }
    }

    function renderLoop() {
      renderGame();
      if (!isGameOver) {
        requestAnimationFrame(renderLoop);
      }
    }

    function moveLocalSnake() {
      const head = { ...localSnake[0] };
      switch (localDirection) {
        case 'left': head.x--; break;
        case 'right': head.x++; break;
        case 'up': head.y--; break;
        case 'down': head.y++; break;
      }
      if (head.x < 0) head.x = tileCountX - 1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY - 1;
      if (head.y >= tileCountY) head.y = 0;
      localSnake.unshift(head);
      localSnake.pop();
    }

    function checkSelfCollision() {
      return false;
    }

    function updatePlayerState(ateApple) {
      if (ateApple) {
        const lastSegment = localSnake[localSnake.length - 1];
        localSnake.push({ ...lastSegment });
      }
      gameStateRef.child('players').child(playerId).update({
        snake: localSnake,
        direction: localDirection,
        score: score
      }).catch(err => console.error('Error updating player state:', err));
    }

    function spawnApple() {
      const newApple = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY)
      };
      gameStateRef.child('apple').set(newApple)
        .catch(err => console.error('Error setting apple:', err));
    }

    function setGameOver() {
      isGameOver = true;
      gameStateRef.update({ gameOver: true })
        .catch(err => console.error('Error setting gameOver:', err));
      endGame();
    }

    function endGame() {
      stopLogicLoop();
      let resultTitle = '';
      if (opponentDisconnected) {
        resultTitle = languageStrings[currentLanguage].opponentDisconnected;
      } else {
        if (score > opponentScore) {
          resultTitle = languageStrings[currentLanguage].win;
        } else if (score < opponentScore) {
          resultTitle = languageStrings[currentLanguage].lose;
        } else {
          resultTitle = languageStrings[currentLanguage].draw;
        }
      }
      const msg = `Your score: ${formatScore(score)} | Opponent: ${formatScore(opponentScore)}`;
      showEndGameModal(resultTitle, msg);
      cleanupRoom();
    }

    function startTimer() {
      timerCurrent = timerTotal;
      const timerInterval = setInterval(() => {
        if (!isGameRunning || isGameOver) {
          clearInterval(timerInterval);
          return;
        }
        timerCurrent--;
        if (timerCurrent <= 0) {
          setGameOver();
          clearInterval(timerInterval);
        }
      }, 1000);
    }

    function renderGame() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00103c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      drawMatrixGrid();
      const now = performance.now();
      const factor = Math.min((now - lastLogicUpdateTime) / LOGIC_INTERVAL, 1);
      
      let appleImg = new Image();
      appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
      if (appleImg.complete) {
        specialCtx.drawImage(
          appleImg,
          GAME_AREA_X + applePos.x * gridSize,
          GAME_AREA_Y + applePos.y * gridSize,
          gridSize,
          gridSize
        );
      }
      
      for (let i = 0; i < localSnake.length; i++) {
        const curr = localSnake[i];
        const prev = previousSnake[i] || curr;
        const interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
        const interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
        const x = GAME_AREA_X + interpX * gridSize;
        const y = GAME_AREA_Y + interpY * gridSize;
        specialCtx.fillStyle = snakeColors[playerId] || '#800080';
        specialCtx.fillRect(x, y, gridSize, gridSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(x, y, gridSize, gridSize);
      }
      
      const opponentFactor = Math.min((now - lastOpponentUpdateTime) / LOGIC_INTERVAL, 1);
      for (let i = 0; i < opponentSnake.length; i++) {
        const curr = opponentSnake[i];
        const prev = previousOpponentSnake[i] || curr;
        const interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
        const interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
        const x = GAME_AREA_X + interpX * gridSize;
        const y = GAME_AREA_Y + interpY * gridSize;
        specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
        specialCtx.fillRect(x, y, gridSize, gridSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(x, y, gridSize, gridSize);
      }
      
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '12px "Press Start 2P", sans-serif';
      specialCtx.fillText(`Score: ${formatScore(score)}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
      specialCtx.fillText(`Opp: ${formatScore(opponentScore)}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);
      const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
    }

    function drawMatrixGrid() {
      specialCtx.fillStyle = '#433171';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
      specialCtx.strokeStyle = '#00103c';
      for (let i = 0; i <= tileCountX; i++) {
        const x = GAME_AREA_X + i * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(x, GAME_AREA_Y);
        specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
        specialCtx.stroke();
      }
      for (let j = 0; j <= tileCountY; j++) {
        const y = GAME_AREA_Y + j * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(GAME_AREA_X, y);
        specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
        specialCtx.stroke();
      }
      specialCtx.strokeStyle = '#8F509D';
      specialCtx.lineWidth = 2;
      specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
    }

    function drawSearchScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00103c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '15px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText('Searching for opponent...', specialGameCanvas.width / 2, specialGameCanvas.height / 2);
      specialCtx.font = '10px "Press Start 2P", sans-serif';
      specialCtx.fillText(' ', specialGameCanvas.width / 2, specialGameCanvas.height / 2 + 40);
    }

    function drawWaitingScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
    }

    function drawOpponentFoundScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#1f1c2c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '16px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText('Opponent found!', specialGameCanvas.width / 2, specialGameCanvas.height / 2);
    }

    function addSwipeListeners() {
      function onKeyDown(e) {
        switch (e.key) {
          case 'ArrowLeft':
            if (localDirection !== 'right') localDirection = 'left';
            break;
          case 'ArrowRight':
            if (localDirection !== 'left') localDirection = 'right';
            break;
          case 'ArrowUp':
            if (localDirection !== 'down') localDirection = 'up';
            break;
          case 'ArrowDown':
            if (localDirection !== 'up') localDirection = 'down';
            break;
        }
      }
      window.addEventListener('keydown', onKeyDown);
      window.__joystick_keydown = onKeyDown;
      const canvas = specialGameCanvas;
      const joystick = document.getElementById('joystick');
      const joystickStick = document.getElementById('joystick-stick');
      let joystickActive = false;
      let joystickCenter = { x: 0, y: 0 };
      const maxDistance = 40;
      function handleTouchStart(e) {
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          joystickCenter.x = touch.clientX;
          joystickCenter.y = touch.clientY;
          joystick.style.left = joystickCenter.x + 'px';
          joystick.style.top = joystickCenter.y + 'px';
          joystick.style.display = 'block';
          joystickStick.style.transform = 'translate(0px, 0px)';
          joystickActive = true;
          e.preventDefault();
        }
      }
      function handleTouchMove(e) {
        if (!joystickActive) return;
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          let dx = touch.clientX - joystickCenter.x;
          let dy = touch.clientY - joystickCenter.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < 1) return;
          if (distance > maxDistance) {
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * maxDistance;
            dy = Math.sin(angle) * maxDistance;
          }
          joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
          let angleDeg = Math.atan2(dy, dx) * (180 / Math.PI);
          if (angleDeg < 0) angleDeg += 360;
          if (angleDeg >= 45 && angleDeg < 135) {
            if (localDirection !== 'up') localDirection = 'down';
          } else if (angleDeg >= 135 && angleDeg < 225) {
            if (localDirection !== 'right') localDirection = 'left';
          } else if (angleDeg >= 225 && angleDeg < 315) {
            if (localDirection !== 'down') localDirection = 'up';
          } else {
            if (localDirection !== 'left') localDirection = 'right';
          }
          e.preventDefault();
        }
      }
      function handleTouchEnd(e) {
        joystickActive = false;
        joystick.style.display = 'none';
        e.preventDefault();
      }
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
      window.__joystick_touchstart = handleTouchStart;
      window.__joystick_touchmove = handleTouchMove;
      window.__joystick_touchend = handleTouchEnd;
    }

    function removeSwipeListeners() {
      if (!specialGameCanvas) return;
      specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
      specialGameCanvas.removeEventListener('touchmove', window.__joystick_touchmove);
      specialGameCanvas.removeEventListener('touchend', window.__joystick_touchend);
      window.removeEventListener('keydown', window.__joystick_keydown);
      window.__joystick_touchstart = null;
      window.__joystick_touchmove = null;
      window.__joystick_touchend = null;
      window.__joystick_keydown = null;
    }

    function copyInviteLink() {
      if (!inviteLink) return;
      navigator.clipboard.writeText(inviteLink)
        .then(() => { console.log("Invite link copied:", inviteLink); })
        .catch(err => console.error("Error copying invite link:", err));
    }

    function showEndGameModal(title, message) {
      const modal = document.getElementById('endgameBackdrop');
      const titleEl = document.getElementById('endgameTitle');
      const msgEl = document.getElementById('endgameMessage');
      titleEl.textContent = title;
      msgEl.textContent = message;
      modal.classList.add('active');
      modal.style.display = 'flex';
    }

    function setupControlButtons() {
      const buttons = document.querySelectorAll('.control-button');
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          const newDirection = button.getAttribute('data-direction');
          if ((localDirection === 'left' && newDirection === 'right') ||
              (localDirection === 'right' && newDirection === 'left') ||
              (localDirection === 'up' && newDirection === 'down') ||
              (localDirection === 'down' && newDirection === 'up')) {
            return;
          }
          localDirection = newDirection;
        });
      });
    }

    function cleanupRoom() {
      if (roomId) {
        firebase.database().ref('snakeGames/' + roomId).remove()
          .then(() => console.log("Game room removed from snakeGames."))
          .catch(err => console.error("Error removing game room:", err));
        firebase.database().ref('snakeQueue/' + roomId).remove()
          .then(() => console.log("Game room removed from snakeQueue."))
          .catch(err => console.error("Error removing room from snakeQueue:", err));
      }
    }

    window.addEventListener('beforeunload', function() {
      if (roomId && gameStateRef) {
        gameStateRef.child('players').child(playerId).remove();
      }
    });

    function finishGame() {
      document.getElementById('endgameBackdrop').classList.remove('active');
      document.getElementById('endgameBackdrop').style.display = 'none';
      window.location.href = 'index.html';
    }
    function returnToMain() {
      window.location.href = 'index.html';
    }

    // Слушатели кнопок на обучающей странице
    document.getElementById('createRoomBtn').addEventListener('click', function() {
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      showModal('createRoomModal');
    });

    document.getElementById('searchRoomBtn').addEventListener('click', function() {
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      showModal('searchRoomModal');
      searchRoomsWithFilter();
    });

    document.getElementById('playFreeBtn').addEventListener('click', function() {
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      autoJoinFreeGame();
    });

    document.getElementById('cancelCreateRoomBtn').addEventListener('click', function() {
      hideModal('createRoomModal');
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
    });

    document.getElementById('confirmCreateRoomBtn').addEventListener('click', function() {
      const betValue = parseInt(document.getElementById('betSlider').value);
      createRoom(betValue);
    });

    // Обновление отображения выбранной ставки в режиме реального времени
    document.getElementById('betSlider').addEventListener('input', function() {
      const value = this.value;
      document.getElementById('betValueDisplay').textContent = value;
    });

    document.getElementById('cancelSearchRoomBtn').addEventListener('click', function() {
      hideModal('searchRoomModal');
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
    });

    document.getElementById('searchBackBtn').addEventListener('click', function() {
      cleanupRoom();
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
      document.getElementById('searchBackBtn').style.display = 'none';
    });

    // Фильтрация и обновление списка комнат
    document.getElementById('applyFilterBtn').addEventListener('click', function() {
      const minBet = parseInt(document.getElementById('minBetFilter').value);
      const maxBet = parseInt(document.getElementById('maxBetFilter').value);
      searchRoomsWithFilter(minBet, maxBet);
    });
    document.getElementById('refreshSearchBtn').addEventListener('click', function() {
      const minBet = parseInt(document.getElementById('minBetFilter').value);
      const maxBet = parseInt(document.getElementById('maxBetFilter').value);
      searchRoomsWithFilter(minBet, maxBet);
    });

    function searchRoomsWithFilter(minBet = 1, maxBet = 100) {
      document.getElementById('loadingIndicator').style.display = 'block';
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('status').equalTo('waiting').once('value')
        .then(snapshot => {
          const rooms = snapshot.val();
          const roomListDiv = document.getElementById('roomList');
          roomListDiv.innerHTML = '';
          if (rooms) {
            Object.keys(rooms).forEach(roomKey => {
              const room = rooms[roomKey];
              if (room.bet < minBet || room.bet > maxBet) return;
              if (room.creator === window.currentUser.username) return;
              const card = document.createElement('div');
              card.className = 'room-card';
              card.innerHTML = `
                <div class="room-info">
                  <p><strong>@${room.creator}</strong></p>
                  <p>Bet: ${room.bet} m</p>
                  <p>${new Date(room.createdAt).toLocaleTimeString()}</p>
                </div>
                <button class="joinRoomBtn" data-room="${roomKey}">${languageStrings[currentLanguage].join}</button>
              `;
              roomListDiv.appendChild(card);
              card.querySelector('.joinRoomBtn').addEventListener('click', function() {
                joinRoom(roomKey);
              });
            });
          } else {
            roomListDiv.innerHTML = '<p style="color: #FF00FF;">No available rooms</p>';
          }
          document.getElementById('loadingIndicator').style.display = 'none';
        })
        .catch(err => {
          console.error('Error searching rooms:', err);
          document.getElementById('loadingIndicator').style.display = 'none';
        });
    }

    let currentLanguage = "en";
    const languageStrings = {
      en: {
        landingTitle: "Special Snake PvP",
        landingText: "Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!",
        homeBack: "Back",
        languageToggle: "RU",
        createRoomBtn: "Create Room",
        searchRoomBtn: "Search Room",
        playFreeBtn: "Play for Free",
        win: "You Win!",
        lose: "You Lose...",
        draw: "Draw",
        opponentDisconnected: "Opponent Disconnected. You Win!",
        createRoomTitle: "Create Room",
        chooseBet: "Choose bet (in millions): ",
        betUnit: " m",
        confirmCreateRoom: "Create",
        cancel: "Cancel",
        searchRoomTitle: "Search Rooms",
        back: "Back",
        insufficientTitle: "Not enough coins",
        insufficientText: "You don't have enough coins to join the game.",
        topUp: "Top Up",
        join: "Join"
      },
      ru: {
        landingTitle: "Спешл Снейк PvP",
        landingText: "Добро пожаловать в Special Snake PvP – захватывающий мир динамичных PvP-сражений, где скорость, стратегия и рефлексы решают судьбу каждой битвы! Управляйте своей уникальной змеей в ретро-стилистике, с эффектной графикой и атмосферным звуковым сопровождением. Каждая секунда – это борьба за выживание: избегайте столкновений, собирайте бонусы и опережайте противника в лабиринте арены. Играйте с друзьями или случайными противниками в режиме реального времени и докажите, что вы – настоящий мастер змей!",
        homeBack: "Назад",
        languageToggle: "EN",
        createRoomBtn: "Создать рум",
        searchRoomBtn: "Поиск рум",
        playFreeBtn: "Играть бесплатно",
        win: "ты выиграл",
        lose: "ты проиграл",
        draw: "Ничья",
        opponentDisconnected: "Противник отключился. ты выиграл",
        createRoomTitle: "Создать комнату",
        chooseBet: "Выберите ставку (в миллионах): ",
        betUnit: " млн",
        confirmCreateRoom: "Создать",
        cancel: "Отмена",
        searchRoomTitle: "Поиск комнат",
        back: "Назад",
        insufficientTitle: "Недостаточно монет",
        insufficientText: "У вас недостаточно монет для участия в игре.",
        topUp: "Пополнить",
        join: "Присоединиться"
      }
    };

    function updateLanguageTexts() {
      document.getElementById('landingTitle').textContent = languageStrings[currentLanguage].landingTitle;
      document.getElementById('landingText').textContent = languageStrings[currentLanguage].landingText;
      document.getElementById('homeBackBtn').textContent = languageStrings[currentLanguage].homeBack;
      document.getElementById('langToggleBtn').textContent = languageStrings[currentLanguage].languageToggle;
      document.getElementById('createRoomBtn').textContent = languageStrings[currentLanguage].createRoomBtn;
      document.getElementById('searchRoomBtn').textContent = languageStrings[currentLanguage].searchRoomBtn;
      document.getElementById('playFreeBtn').textContent = languageStrings[currentLanguage].playFreeBtn;
      
      if(document.querySelector('#createRoomModal .modal h2')) {
        document.querySelector('#createRoomModal .modal h2').textContent = languageStrings[currentLanguage].createRoomTitle;
      }
      if(document.querySelector('#createRoomModal .modal p')) {
        const betVal = document.getElementById('betSlider').value;
        document.querySelector('#createRoomModal .modal p').textContent = languageStrings[currentLanguage].chooseBet + betVal + languageStrings[currentLanguage].betUnit;
      }
      document.getElementById('confirmCreateRoomBtn').textContent = languageStrings[currentLanguage].confirmCreateRoom;
      document.getElementById('cancelCreateRoomBtn').textContent = languageStrings[currentLanguage].cancel;
      
      if(document.querySelector('#searchRoomModal .modal h2')) {
        document.querySelector('#searchRoomModal .modal h2').textContent = languageStrings[currentLanguage].searchRoomTitle;
      }
      document.getElementById('cancelSearchRoomBtn').textContent = languageStrings[currentLanguage].back;
      
      if(document.querySelector('#insufficientModal .modal h2')) {
        document.querySelector('#insufficientModal .modal h2').textContent = languageStrings[currentLanguage].insufficientTitle;
      }
      if(document.querySelector('#insufficientModal .modal p')) {
        document.querySelector('#insufficientModal .modal p').textContent = languageStrings[currentLanguage].insufficientText;
      }
      if(document.querySelector('#insufficientModal .modal button')) {
        document.querySelector('#insufficientModal .modal button').textContent = languageStrings[currentLanguage].topUp;
      }
    }

    document.getElementById('langToggleBtn').addEventListener('click', function() {
      currentLanguage = currentLanguage === "en" ? "ru" : "en";
      updateLanguageTexts();
    });

    document.getElementById('homeBackBtn').addEventListener('click', function() {
      window.location.href = 'index.html';
    });

    function updateCoinDisplay(coins) {
      document.getElementById('coinButton').innerHTML =
        formatNumber(coins) + ' <img src="https://raw.githubusercontent.com/qnexst/404token/main/token.png" alt="Coins" width="20"/>';
    }

    window.addEventListener('load', () => {
      const firebaseConfig = {
        apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
        authDomain: "test-with-likes.firebaseapp.com",
        databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
        projectId: "test-with-likes",
        storageBucket: "test-with-likes.appspot.com",
        messagingSenderId: "764738820142",
        appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
        measurementId: "G-WJNF0HSN9P"
      };
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      if (!window.currentUser) {
        if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
          const tgUser = Telegram.WebApp.initDataUnsafe.user;
          window.currentUser = {
            username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
            photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
          };
        } else {
          window.currentUser = {
            username: "TestUser",
            photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
          };
        }
      }
      if (window.currentUser && window.currentUser.username) {
        const userRef = firebase.database().ref('users/' + window.currentUser.username);
        userRef.once('value').then(snapshot => {
          if (!snapshot.exists()) {
            userRef.set({
              coins: 0,
              tickets: 0,
              points: 0,
              lastSpinTime: 0
            });
          }
        });
        userRef.on('value', snapshot => {
          const data = snapshot.val() || {};
          const coins = data.coins || 0;
          updateCoinDisplay(coins);
        });
      }
      initSpecialGame1();
      updateLanguageTexts();
    });
  </script>
</body>
</html>

