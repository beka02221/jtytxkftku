<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>

  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* ========= Базовые сбросы ========= */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }
    
    /* ========= Основной стиль страницы ========= */
    body {
      background-color: #0e162e;
      color: #e0e0e0;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }
    
    /* ========= Верхняя панель (Header) с эффектом блюра ========= */
    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px 20px;
      background: rgba(14,22,46,0.6);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: 2px solid #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 2100;
    }
    header button {
      font-size: 12px;
      padding: 8px 16px;
      background: linear-gradient(135deg, #bb86fc, #29b6f6);
      color: #000;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    header button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    header button:active {
      transform: translateY(2px);
    }
    
    /* ========= Canvas для игры ========= */
    #specialGameCanvas {
      display: block;
      margin: 70px auto 0; /* отступ сверху для размещения header */
      background: url('1.jpg') center/cover no-repeat;
    }
    
    /* ========= Экран приветствия (Landing Screen) ========= */
    #landingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0e162e, #1a1a40);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      text-align: center;
      padding: 20px;
    }
    .landingContent {
      max-width: 600px;
      overflow-y: auto;
    }
    .landingContent img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
      border: 2px solid #bb86fc;
      border-radius: 8px;
    }
    .landingContent h1 {
      margin: 10px 0;
      font-size: 28px;
      color: #bb86fc;
      text-transform: uppercase;
    }
    .landingContent p {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 10px;
      text-align: left;
    }
    .collapsed {
      max-height: 100px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .landingContent button {
      margin: 10px;
    }
    
    /* ========= Карточка комнаты ========= */
    .room-card {
      border: 1px solid #bb86fc;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(187, 134, 252, 0.1);
    }
    
    /* ========= Модальные окна ========= */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: rgba(14,22,46,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal {
      background: #0e162e;
      border: 2px solid #3b3b3b;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
    }
    /* Модальное окно для недостатка монет */
    #insufficientModal .modal {
      background-color: #6d4fba;
      border: 2px solid #3b3b3b;
    }
    
    /* ========= Модальное окно поиска комнат (полноэкранное) ========= */
    #searchRoomModal {
      display: none;
      flex-direction: column;
      justify-content: flex-start;
      padding-top: 60px;
    }
    #searchRoomModal.active {
      display: flex;
    }
    #searchRoomModal h2 {
      font-size: 18px;
      margin-bottom: 20px;
      color: #bb86fc;
    }
    #roomList {
      max-height: 60vh;
      overflow-y: auto;
      margin: 20px 0;
    }
    #refreshSearchBtn,
    #cancelSearchRoomBtn {
      margin: 10px;
      padding: 8px 16px;
    }
    
    /* ========= Модальное окно создания комнаты ========= */
    #createRoomModal {
      display: none;
      flex-direction: column;
    }
    #createRoomModal.active {
      display: flex;
    }
    
    /* ========= Кнопка копирования ссылки ========= */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: linear-gradient(135deg, #bb86fc, #29b6f6);
      color: #000;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      cursor: pointer;
      display: none;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #copyButton:hover {
      transform: translateX(-50%) translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    
    /* ========= Модальное окно итогов игры ========= */
    .endgame-backdrop {
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    }
    .endgame-backdrop.active {
      display: flex;
    }
    .endgame-modal {
      background: #0e162e;
      border: 2px solid #3b3b3b;
      border-radius: 4px;
      padding: 16px;
      width: 80%;
      max-width: 360px;
      text-align: center;
      box-shadow: 0 0 15px #0ff;
    }
    .endgame-modal h2 {
      margin-bottom: 10px;
      font-size: 14px;
      color: #bb86fc;
    }
    .endgame-modal p {
      margin-bottom: 16px;
      font-size: 12px;
    }
    
    /* ========= Панель управления и джойстик ========= */
    #controlPanel {
      width: 150px;
      height: 150px;
      margin: 20px auto;
      position: relative;
    }
    #controlPanel .control-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #bb86fc, #29b6f6);
      border: none;
      border-radius: 10px;
      color: #000;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.1s;
    }
    #btn-up {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }
    .control-button:hover {
      transform: scale(1.2);
    }
    .control-button:active {
      transform: translateY(2px) scale(1);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #joystick {
      position: fixed;
      width: 100px;
      height: 100px;
      margin: -50px 0 0 -50px;
      background: rgba(100, 100, 100, 0.3);
      border: 2px solid rgba(200, 200, 200, 0.7);
      border-radius: 50%;
      display: none;
      z-index: 1000;
    }
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      margin: -25px 0 0 -25px;
      background: rgba(200, 200, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      left: 50%;
      top: 50%;
    }
    
    /* ========= Дополнительные настройки дизайна (гамбургер) ========= */
    #design-settings {
      position: fixed;
      top: 20px;
      left: 10px;
      z-index: 1100;
    }
    #design-settings button {
      width: 30px;
      height: 20px;
      background: transparent;
      border: none;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      align-items: center;
      padding: 0;
    }
    #design-settings .hamburger-line {
      width: 80%;
      height: 3px;
      background: #bb86fc;
      border-radius: 2px;
    }
    #design-settings button:hover .hamburger-line {
      background: #ff0037;
    }
    #design-settings button:active {
      transform: translateY(2px);
    }
  </style>
</head>
<body>
  <!-- Верхняя панель (Header) -->
  <header id="topBar">
    <button id="homeBackBtn">Back</button>
    <button id="coinButton" onclick="window.location.href='buy.html'">0 Coins</button>
    <button id="langToggleBtn">RU</button>
  </header>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>

  <!-- Экран приветствия (Landing Screen) -->
  <div id="landingScreen">
    <div class="landingContent">
      <img src="game_preview.jpg" alt="Game Preview">
      <h1 id="landingTitle">Special Snake PvP</h1>
      <p id="landingText" class="collapsed">
        Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!
      </p>
      <button id="toggleDescBtn">▼</button>
      <button id="createRoomBtn">Create Room</button>
      <button id="searchRoomBtn">Search Room</button>
      <button id="playFreeBtn">Play for Free</button>
    </div>
  </div>

  <!-- Модальное окно создания комнаты -->
  <div id="createRoomModal" class="modal-backdrop">
    <div class="modal">
      <h2>Создать комнату</h2>
      <p>Выберите ставку (в миллионах): <span id="betValueDisplay">1 млн</span></p>
      <input type="range" id="betSlider" min="1" max="100" value="1" step="1">
      <div style="margin-top: 20px;">
        <button id="confirmCreateRoomBtn">Создать</button>
        <button id="cancelCreateRoomBtn">Отмена</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно поиска комнат (полноэкранное) -->
  <div id="searchRoomModal" class="modal-backdrop">
    <div class="modal" style="max-width: none; width: 90%; height: 90vh; overflow-y: auto;">
      <h2>Доступные комнаты</h2>
      <div id="roomList">
        <!-- Здесь будут карточки с комнатами -->
      </div>
      <div>
        <button id="refreshSearchBtn">Обновить</button>
        <button id="cancelSearchRoomBtn">Закрыть</button>
      </div>
    </div>
  </div>

  <!-- Кнопка для копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>

  <!-- Модальное окно итогов игры -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>

  <!-- Модальное окно для недостатка монет -->
  <div id="insufficientModal" class="modal-backdrop">
    <div class="modal">
      <h2>Недостаточно монет</h2>
      <p>У вас недостаточно монет для участия в игре.</p>
      <button onclick="window.location.href='buy.html'">Пополнить</button>
    </div>
  </div>

  <!-- Джойстик (для мобильных устройств) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <script>
    /* ================================================
       Special Snake PvP – Основной JavaScript код
       (Создание/поиск комнаты, логика игры, управление, смена языка, обновление баланса и т.д.)
    ================================================ */

    // Глобальные переменные и настройки игры
    let specialGameCanvas;
    let specialCtx;

    const GAME_AREA_X = 50;
    const GAME_AREA_Y = 50;
    const GAME_AREA_WIDTH = 300;
    const GAME_AREA_HEIGHT = 500;

    const gridSize = 20;
    const tileCountX = GAME_AREA_WIDTH / gridSize;
    const tileCountY = GAME_AREA_HEIGHT / gridSize;

    let roomId = null;
    let playerId = null;
    let opponentId = null;
    let gameStateRef = null;

    let localSnake = [];
    let localDirection = 'right';
    let score = 0;

    let previousSnake = [];
    let lastLogicUpdateTime = 0;

    let opponentSnake = [];
    let opponentScore = 0;
    let opponentName = '';

    let previousOpponentSnake = [];
    let lastOpponentUpdateTime = performance.now();

    let applePos = { x: 0, y: 0 };

    let isGameRunning = false;
    let isGameOver = false;
    let countdownValue = 5;
    let showOpponentNameTimeout = null;

    let timerTotal = 60;
    let timerCurrent = 60;

    let logicTimer = null;
    let countdownInterval = null;

    let waitingListener = null;
    let oppListener = null;

    const snakeColors = {
      player1: '#FFFF00',
      player2: '#FF0000'
    };

    const LOGIC_INTERVAL = 150;

    let inviteLink = "";
    let opponentDisconnected = false;

    function interpolateCoordinate(prevVal, currVal, factor, maxVal) {
      let diff = currVal - prevVal;
      if (Math.abs(diff) > maxVal / 2) {
        if (diff > 0) diff -= maxVal;
        else diff += maxVal;
      }
      let interp = prevVal + diff * factor;
      if (interp < 0) interp += maxVal;
      if (interp >= maxVal) interp -= maxVal;
      return interp;
    }

    function initSpecialGame1() {
      specialGameCanvas = document.getElementById('specialGameCanvas');
      specialCtx = specialGameCanvas.getContext('2d');

      resetSpecialGame1();
      drawWaitingScreen();

      setupControlButtons();
    }

    function resetSpecialGame1() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      if (showOpponentNameTimeout) {
        clearTimeout(showOpponentNameTimeout);
        showOpponentNameTimeout = null;
      }
      roomId = null;
      playerId = null;
      opponentId = null;
      gameStateRef = null;
      localSnake = [];
      localDirection = 'right';
      score = 0;
      opponentSnake = [];
      opponentScore = 0;
      opponentName = "";
      applePos = { x: 0, y: 0 };
      isGameRunning = false;
      isGameOver = false;
      countdownValue = 5;
      timerTotal = 60;
      timerCurrent = 60;
      inviteLink = "";

      if (waitingListener && roomId) {
        firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
        waitingListener = null;
      }
      if (oppListener && roomId) {
        firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
        oppListener = null;
      }
      removeSwipeListeners();
    }

    function autoJoinFreeGame() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('bet').equalTo(0).once('value')
        .then(snapshot => {
          let found = false;
          snapshot.forEach(child => {
            const room = child.val();
            if (room.status === 'waiting' && room.creator !== window.currentUser.username) {
              joinRoom(child.key);
              found = true;
              return true;
            }
          });
          if (!found) {
            createRoom(0);
          }
        })
        .catch(err => {
          console.error(err);
          createRoom(0);
        });
    }

    function deductUserCoins(amount) {
      const userRef = firebase.database().ref('users/' + window.currentUser.username);
      return userRef.transaction(function(currentData) {
        if (currentData) {
          if (currentData.coins >= amount) {
            currentData.coins -= amount;
            return currentData;
          } else {
            return;
          }
        }
        return;
      });
    }

    function showInsufficientModal() {
      document.getElementById('insufficientModal').style.display = 'flex';
    }

    function createRoom(bet) {
      if(bet > 0) {
        deductUserCoins(bet).then(function(result) {
          if(!result.committed) {
            showInsufficientModal();
            return;
          } else {
            actuallyCreateRoom(bet);
          }
        }).catch(err => {
          console.error(err);
          showInsufficientModal();
        });
      } else {
        actuallyCreateRoom(bet);
      }
    }

    function actuallyCreateRoom(bet) {
      const queueRef = firebase.database().ref('snakeQueue');
      roomId = queueRef.push().key;
      playerId = 'player1';
      opponentId = 'player2';
      queueRef.child(roomId).set({
        status: 'waiting',
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        creator: window.currentUser.username,
        bet: bet
      }).catch((err) => console.error('Error creating room:', err));
      queueRef.child(roomId).onDisconnect().remove();
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';
      document.getElementById('createRoomModal').style.display = 'none';
      drawWaitingScreen();
      setupGameReferences();
      waitForOpponent();
    }

    function searchRooms() {
      const queueRef = firebase.database().ref('snakeQueue');
      queueRef.orderByChild('status').equalTo('waiting').once('value')
        .then(snapshot => {
          const rooms = snapshot.val();
          const roomListDiv = document.getElementById('roomList');
          roomListDiv.innerHTML = '';
          if (rooms) {
            Object.keys(rooms).forEach(roomKey => {
              const room = rooms[roomKey];
              if (room.creator === window.currentUser.username) return;
              const card = document.createElement('div');
              card.className = 'room-card';
              const detailsDiv = document.createElement('div');
              detailsDiv.style.display = 'flex';
              detailsDiv.style.alignItems = 'center';
              const icon = document.createElement('img');
              icon.src = "https://img.icons8.com/ios-filled/50/00FF00/user.png";
              icon.style.width = '40px';
              icon.style.height = '40px';
              icon.style.borderRadius = '50%';
              icon.style.marginRight = '10px';
              detailsDiv.appendChild(icon);
              const infoDiv = document.createElement('div');
              const usernameP = document.createElement('p');
              usernameP.textContent = "@" + room.creator;
              usernameP.style.margin = '0';
              usernameP.style.color = '#bb86fc';
              const betP = document.createElement('p');
              betP.textContent = room.bet + " млн";
              betP.style.margin = '0';
              betP.style.color = '#bb86fc';
              infoDiv.appendChild(usernameP);
              infoDiv.appendChild(betP);
              detailsDiv.appendChild(infoDiv);
              card.appendChild(detailsDiv);
              const joinBtn = document.createElement('button');
              joinBtn.textContent = 'Присоединиться';
              joinBtn.style.fontSize = '12px';
              joinBtn.style.padding = '5px 10px';
              joinBtn.addEventListener('click', function() {
                 joinRoom(roomKey);
              });
              card.appendChild(joinBtn);
              roomListDiv.appendChild(card);
            });
          } else {
             roomListDiv.innerHTML = '<p style="color: #bb86fc;">Нет доступных комнат</p>';
          }
        })
        .catch(err => console.error('Error searching rooms:', err));
    }

    function joinRoom(roomKey) {
      firebase.database().ref('snakeQueue/' + roomKey).once('value').then(snapshot => {
          const room = snapshot.val();
          const bet = room.bet || 0;
          if(bet > 0) {
              deductUserCoins(bet).then(result => {
                  if(!result.committed) {
                     showInsufficientModal();
                     return;
                  } else {
                     proceedJoin(roomKey);
                  }
              }).catch(err => { console.error(err); showInsufficientModal(); });
          } else {
              proceedJoin(roomKey);
          }
      });
    }

    function proceedJoin(roomKey) {
      roomId = roomKey;
      playerId = 'player2';
      opponentId = 'player1';
      firebase.database().ref('snakeQueue/' + roomId).update({ status: 'ready' })
        .catch(err => console.error('Error updating room status:', err));
      setupGameReferences();
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';
      document.getElementById('searchRoomModal').style.display = 'none';
      drawWaitingScreen();
      waitForOpponent();
    }

    function waitForOpponent() {
      drawSearchScreen();

      const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
      waitingListener = statusRef.on('value', async (snapshot) => {
        const currentStatus = snapshot.val();
        if (currentStatus === 'ready') {
          statusRef.off('value', waitingListener);
          waitingListener = null;
          try {
            const oppSnapshot = await firebase.database()
              .ref('snakeGames/' + roomId + '/players/' + opponentId)
              .once('value');
            const oppData = oppSnapshot.val();
            if (oppData && oppData.username) {
              opponentName = oppData.username;
            }
          } catch(e) {
            console.error("Error reading opponent data: ", e);
          }
          drawOpponentFoundScreen();
          document.getElementById('copyButton').style.display = 'none';
          document.getElementById('topBar').style.display = 'none';
          showOpponentNameTimeout = setTimeout(() => {
            startCountdown();
          }, 2000);
        }
      });

      const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
      oppListener = oppRef.on('value', (snapshot) => {
        const oppData = snapshot.val();
        if (oppData) {
          previousOpponentSnake = opponentSnake.length ? opponentSnake.map(seg => ({...seg})) : (oppData.snake || []);
          opponentSnake = oppData.snake || [];
          opponentScore = oppData.score || 0;
          opponentName  = (oppData.username && oppData.username.trim() !== "") ? oppData.username : 'Player';
          lastOpponentUpdateTime = performance.now();
        } else {
          if (isGameRunning) {
            opponentDisconnected = true;
            setGameOver();
          }
        }
      });
    }

    function setupGameReferences() {
      gameStateRef = firebase.database().ref('snakeGames/' + roomId);
      const playerRef = gameStateRef.child('players').child(playerId);

      playerRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
          let startX, startY;
          if (playerId === 'player1') {
            startX = 3;
            startY = Math.floor(tileCountY / 2);
          } else {
            startX = tileCountX - 4;
            startY = Math.floor(tileCountY / 2);
          }
          const initialSnake = [
            { x: startX,     y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
          ];
          playerRef.set({
            snake: initialSnake,
            direction: 'right',
            score: 0,
            username: (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'Player'
          }).catch((err) => console.error('Error initializing player data:', err));

          playerRef.onDisconnect().remove()
            .then(() => console.log("onDisconnect set for player:", playerId))
            .catch((err) => console.error("Error setting onDisconnect:", err));
        }
      });

      gameStateRef.child('apple').on('value', (snapshot) => {
        const aData = snapshot.val() || {};
        if (typeof aData.x === 'number' && typeof aData.y === 'number') {
          applePos.x = aData.x;
          applePos.y = aData.y;
        }
      });

      gameStateRef.child('gameOver').on('value', (snapshot) => {
        if (snapshot.val() === true && !isGameOver) {
          isGameOver = true;
          endGame();
        }
      });
    }

    function startCountdown() {
      countdownValue = 5;
      countdownInterval = setInterval(() => {
        drawCountdownScreen(countdownValue);
        countdownValue--;
        if (countdownValue < 1) {
          clearInterval(countdownInterval);
          launchGame();
        }
      }, 1000);
    }

    function launchGame() {
      document.getElementById('topBar').style.display = 'none';
      isGameRunning = true;
      isGameOver = false;

      gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
        const data = snapshot.val();
        if (data && data.snake) {
          localSnake = data.snake;
        }
        localDirection = (data && data.direction) ? data.direction : 'right';
        score = (data && data.score) ? data.score : 0;
        
        previousSnake = localSnake.map(seg => ({...seg}));
        lastLogicUpdateTime = performance.now();

        gameStateRef.child('apple').once('value').then((appleSnap) => {
          if (!appleSnap.exists()) {
            spawnApple();
          }
        });

        addSwipeListeners();
        startLogicLoop();
        startTimer();
        requestAnimationFrame(renderLoop);
      });
    }

    function startLogicLoop() {
      logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
    }

    function stopLogicLoop() {
      if (logicTimer) {
        clearInterval(logicTimer);
        logicTimer = null;
      }
    }

    function gameLogicUpdate() {
      if (!isGameRunning || isGameOver) return;

      previousSnake = localSnake.map(seg => ({...seg}));
      moveLocalSnake();
      lastLogicUpdateTime = performance.now();

      if (checkSelfCollision()) {
        setGameOver();
        return;
      }

      const head = localSnake[0];
      if (head.x === applePos.x && head.y === applePos.y) {
        score++;
        updatePlayerState(true);
        spawnApple();
      } else {
        updatePlayerState(false);
      }
    }

    function renderLoop() {
      renderGame();
      if (!isGameOver) {
        requestAnimationFrame(renderLoop);
      }
    }

    function moveLocalSnake() {
      const head = { ...localSnake[0] };
      switch (localDirection) {
        case 'left':  head.x--; break;
        case 'right': head.x++; break;
        case 'up':    head.y--; break;
        case 'down':  head.y++; break;
      }
      if (head.x < 0) head.x = tileCountX - 1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY - 1;
      if (head.y >= tileCountY) head.y = 0;
      localSnake.unshift(head);
      localSnake.pop();
    }

    function checkSelfCollision() {
      return false;
    }

    function updatePlayerState(ateApple) {
      if (ateApple) {
        const lastSegment = localSnake[localSnake.length - 1];
        localSnake.push({ ...lastSegment });
      }
      gameStateRef.child('players').child(playerId).update({
        snake: localSnake,
        direction: localDirection,
        score: score
      }).catch((err) => console.error('Error updating player state:', err));
    }

    function spawnApple() {
      const newApple = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY)
      };
      gameStateRef.child('apple').set(newApple)
        .catch((err) => console.error('Error setting apple:', err));
    }

    function setGameOver() {
      isGameOver = true;
      gameStateRef.update({ gameOver: true })
        .catch((err) => console.error('Error setting gameOver:', err));
      endGame();
    }

    function endGame() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      let resultTitle = '';
      if (opponentDisconnected) {
        resultTitle = (currentLanguage === 'ru') ? 'Противник отключился. ты выиграл' : 'Opponent Disconnected. You Win!';
      } else {
        if (score > opponentScore) {
          resultTitle = (currentLanguage === 'ru') ? 'ты выиграл' : 'You Win!';
        } else if (score < opponentScore) {
          resultTitle = (currentLanguage === 'ru') ? 'ты проиграл' : 'You Lose...';
        } else {
          resultTitle = (currentLanguage === 'ru') ? 'Ничья' : 'Draw';
        }
      }
      const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
      showEndGameModal(resultTitle, msg);
      cleanupRoom();
    }

    function startTimer() {
      timerCurrent = timerTotal;
      const timerInterval = setInterval(() => {
        if (!isGameRunning || isGameOver) {
          clearInterval(timerInterval);
          return;
        }
        timerCurrent--;
        if (timerCurrent <= 0) {
          setGameOver();
          clearInterval(timerInterval);
        }
      }, 1000);
    }

    function renderGame() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00103c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

      drawMatrixGrid();

      let now = performance.now();
      let factor = Math.min((now - lastLogicUpdateTime) / LOGIC_INTERVAL, 1);

      let appleImg = new Image();
      appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
      if (appleImg.complete) {
        specialCtx.drawImage(
          appleImg,
          GAME_AREA_X + applePos.x * gridSize,
          GAME_AREA_Y + applePos.y * gridSize,
          gridSize,
          gridSize
        );
      }

      for (let i = 0; i < localSnake.length; i++) {
        let curr = localSnake[i];
        let prev = previousSnake[i] || curr;
        let interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
        let interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
        let x = GAME_AREA_X + interpX * gridSize;
        let y = GAME_AREA_Y + interpY * gridSize;
        specialCtx.fillStyle = snakeColors[playerId] || '#800080';
        specialCtx.fillRect(x, y, gridSize, gridSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(x, y, gridSize, gridSize);
      }

      let opponentFactor = Math.min((now - lastOpponentUpdateTime) / LOGIC_INTERVAL, 1);
      for (let i = 0; i < opponentSnake.length; i++) {
        let curr = opponentSnake[i];
        let prev = previousOpponentSnake[i] || curr;
        let interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
        let interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
        let x = GAME_AREA_X + interpX * gridSize;
        let y = GAME_AREA_Y + interpY * gridSize;
        specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
        specialCtx.fillRect(x, y, gridSize, gridSize);
        specialCtx.strokeStyle = '#000';
        specialCtx.lineWidth = 2;
        specialCtx.strokeRect(x, y, gridSize, gridSize);
      }

      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '12px "Press Start 2P", sans-serif';
      specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
      specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);

      const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
      specialCtx.fillStyle = '#FF00FF';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
    }

    function drawMatrixGrid() {
      specialCtx.fillStyle = '#433171';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

      specialCtx.strokeStyle = '#00103c';
      for (let i = 0; i <= tileCountX; i++) {
        let x = GAME_AREA_X + i * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(x, GAME_AREA_Y);
        specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
        specialCtx.stroke();
      }
      for (let j = 0; j <= tileCountY; j++) {
        let y = GAME_AREA_Y + j * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(GAME_AREA_X, y);
        specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
        specialCtx.stroke();
      }
      specialCtx.strokeStyle = '#8F509D';
      specialCtx.lineWidth = 2;
      specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
    }

    function drawSearchScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00103c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '15px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(
        'Searching for opponent...',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2
      );
      specialCtx.font = '10px "Press Start 2P", sans-serif';
      specialCtx.fillText(' ', specialGameCanvas.width / 2, specialGameCanvas.height / 2 + 40);
    }

    function drawWaitingScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
    }

    function drawOpponentFoundScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#1f1c2c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

      specialCtx.fillStyle = '#FF00FF';
      specialCtx.font = '16px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText('Opponent found!', specialGameCanvas.width / 2, specialGameCanvas.height / 2);
    }

    function drawCountdownScreen(value) {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#1f1c2c';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '60px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(value.toString(), specialGameCanvas.width / 2, specialGameCanvas.height / 2);
    }

    function addSwipeListeners() {
      function onKeyDown(e) {
        switch (e.key) {
          case 'ArrowLeft':
            if (localDirection !== 'right') localDirection = 'left';
            break;
          case 'ArrowRight':
            if (localDirection !== 'left') localDirection = 'right';
            break;
          case 'ArrowUp':
            if (localDirection !== 'down') localDirection = 'up';
            break;
          case 'ArrowDown':
            if (localDirection !== 'up') localDirection = 'down';
            break;
        }
      }
      window.addEventListener('keydown', onKeyDown);
      window.__joystick_keydown = onKeyDown;

      const canvas = specialGameCanvas;
      const joystick = document.getElementById('joystick');
      const joystickStick = document.getElementById('joystick-stick');
      let joystickActive = false;
      let joystickCenter = { x: 0, y: 0 };
      const maxDistance = 40;

      function handleTouchStart(e) {
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          joystickCenter.x = touch.clientX;
          joystickCenter.y = touch.clientY;
          joystick.style.left = joystickCenter.x + 'px';
          joystick.style.top = joystickCenter.y + 'px';
          joystick.style.display = 'block';
          joystickStick.style.transform = 'translate(0px, 0px)';
          joystickActive = true;
          e.preventDefault();
        }
      }

      function handleTouchMove(e) {
        if (!joystickActive) return;
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          let dx = touch.clientX - joystickCenter.x;
          let dy = touch.clientY - joystickCenter.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > maxDistance) {
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * maxDistance;
            dy = Math.sin(angle) * maxDistance;
          }
          joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && localDirection !== 'left') {
              localDirection = 'right';
            } else if (dx < 0 && localDirection !== 'right') {
              localDirection = 'left';
            }
          } else {
            if (dy > 0 && localDirection !== 'up') {
              localDirection = 'down';
            } else if (dy < 0 && localDirection !== 'down') {
              localDirection = 'up';
            }
          }
          e.preventDefault();
        }
      }

      function handleTouchEnd(e) {
        joystickActive = false;
        joystick.style.display = 'none';
        e.preventDefault();
      }

      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

      window.__joystick_touchstart = handleTouchStart;
      window.__joystick_touchmove = handleTouchMove;
      window.__joystick_touchend = handleTouchEnd;
    }

    function removeSwipeListeners() {
      if (!specialGameCanvas) return;
      specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
      specialGameCanvas.removeEventListener('touchmove', window.__joystick_touchmove);
      specialGameCanvas.removeEventListener('touchend', window.__joystick_touchend);
      window.removeEventListener('keydown', window.__joystick_keydown);
      window.__joystick_touchstart = null;
      window.__joystick_touchmove = null;
      window.__joystick_touchend = null;
      window.__joystick_keydown = null;
    }

    function copyInviteLink() {
      if (!inviteLink) return;
      navigator.clipboard.writeText(inviteLink)
        .then(() => { console.log("Invite link copied:", inviteLink); })
        .catch(err => console.error("Error copying invite link:", err));
    }

    function showEndGameModal(title, message) {
      const modal = document.getElementById('endgameBackdrop');
      const titleEl = document.getElementById('endgameTitle');
      const msgEl = document.getElementById('endgameMessage');
      titleEl.textContent = title;
      msgEl.textContent = message;
      modal.classList.add('active');
    }

    function setupControlButtons() {
      const buttons = document.querySelectorAll('.control-button');
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          const newDirection = button.getAttribute('data-direction');
          if ((localDirection === 'left'  && newDirection === 'right') ||
              (localDirection === 'right' && newDirection === 'left')  ||
              (localDirection === 'up'    && newDirection === 'down')  ||
              (localDirection === 'down'  && newDirection === 'up')) {
            return;
          }
          localDirection = newDirection;
        });
      });
    }

    function cleanupRoom() {
      if (roomId) {
        firebase.database().ref('snakeGames/' + roomId).remove()
          .then(() => console.log("Game room removed from snakeGames."))
          .catch((err) => console.error("Error removing game room:", err));

        firebase.database().ref('snakeQueue/' + roomId).remove()
          .then(() => console.log("Game room removed from snakeQueue."))
          .catch((err) => console.error("Error removing room from snakeQueue:", err));
      }
    }

    window.addEventListener('beforeunload', function() {
      if (roomId && gameStateRef) {
        gameStateRef.child('players').child(playerId).remove();
      }
    });

    function finishGame() {
      document.getElementById('endgameBackdrop').classList.remove('active');
      window.location.href = 'index.html';
    }
    function returnToMain() {
      window.location.href = 'index.html';
    }

    document.getElementById('createRoomBtn').addEventListener('click', function(){
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      document.getElementById('createRoomModal').style.display = 'flex';
    });

    document.getElementById('searchRoomBtn').addEventListener('click', function(){
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      document.getElementById('searchRoomModal').style.display = 'flex';
      searchRooms();
    });

    document.getElementById('playFreeBtn').addEventListener('click', function(){
      document.getElementById('landingScreen').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      autoJoinFreeGame();
    });

    document.getElementById('cancelCreateRoomBtn').addEventListener('click', function(){
      document.getElementById('createRoomModal').style.display = 'none';
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
    });
    document.getElementById('confirmCreateRoomBtn').addEventListener('click', function(){
      let betValue = parseInt(document.getElementById('betSlider').value);
      createRoom(betValue);
    });
    document.getElementById('betSlider').addEventListener('input', function(){
      let value = document.getElementById('betSlider').value;
      document.getElementById('betValueDisplay').textContent = value + " млн";
    });

    document.getElementById('cancelSearchRoomBtn').addEventListener('click', function(){
      document.getElementById('searchRoomModal').style.display = 'none';
      document.getElementById('landingScreen').style.display = 'flex';
      document.getElementById('topBar').style.display = 'flex';
    });
    document.getElementById('refreshSearchBtn').addEventListener('click', function(){
      searchRooms();
    });

    window.addEventListener('load', () => {
      const firebaseConfig = {
        apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
        authDomain: "test-with-likes.firebaseapp.com",
        databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
        projectId: "test-with-likes",
        storageBucket: "test-with-likes.appspot.com",
        messagingSenderId: "764738820142",
        appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
        measurementId: "G-WJNF0HSN9P"
      };
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }

      if (!window.currentUser) {
        if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
          const tgUser = Telegram.WebApp.initDataUnsafe.user;
          window.currentUser = {
            username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
            photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
          };
        } else {
          window.currentUser = {
            username: "TestUser",
            photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
          };
        }
      }
      
      if (window.currentUser && window.currentUser.username) {
        const userRef = firebase.database().ref('users/' + window.currentUser.username);
        userRef.once('value').then(snapshot => {
          if (!snapshot.exists()) {
            userRef.set({
              coins: 0,
              tickets: 0,
              points: 0,
              lastSpinTime: 0
            });
          }
        });
        userRef.on('value', snapshot => {
          const data = snapshot.val() || {};
          const coins = data.coins || 0;
          updateCoinDisplay(coins);
        });
      }
      
      initSpecialGame1();
      updateLanguageTexts();

      const toggleDescBtn = document.getElementById('toggleDescBtn');
      toggleDescBtn.addEventListener('click', function(){
        const landingText = document.getElementById('landingText');
        if (landingText.classList.contains('collapsed')) {
          landingText.classList.remove('collapsed');
          toggleDescBtn.textContent = "▲";
        } else {
          landingText.classList.add('collapsed');
          toggleDescBtn.textContent = "▼";
        }
      });
    });

    function changeDirection(newDir) {
      if (
        (newDir === 'up'    && localDirection === 'down') ||
        (newDir === 'down'  && localDirection === 'up')   ||
        (newDir === 'left'  && localDirection === 'right')||
        (newDir === 'right' && localDirection === 'left')
      ) {
        return;
      }
      localDirection = newDir;
    }

    let currentLanguage = "en";
    const languageStrings = {
      en: {
        landingTitle: "Special Snake PvP",
        landingText: "Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!",
        homeBack: "Back",
        languageToggle: "RU",
        createRoomBtn: "Create Room",
        searchRoomBtn: "Search Room",
        playFreeBtn: "Play for Free",
        win: "You Win!",
        lose: "You Lose...",
        draw: "Draw",
        opponentDisconnected: "Opponent Disconnected. You Win!"
      },
      ru: {
        landingTitle: "Спешл Снейк PvP",
        landingText: "Добро пожаловать в Special Snake PvP – захватывающий мир динамичных PvP-сражений, где скорость, стратегия и рефлексы решают судьбу каждой битвы! Управляйте своей уникальной змеей в ретро-стилистике, с эффектной графикой и атмосферным звуковым сопровождением. Каждая секунда – это борьба за выживание: избегайте столкновений, собирайте бонусы и опережайте противника в лабиринте арены. Играйте с друзьями или случайными противниками в режиме реального времени и докажите, что вы – настоящий мастер змей!",
        homeBack: "Назад",
        languageToggle: "EN",
        createRoomBtn: "Создать рум",
        searchRoomBtn: "Поиск рум",
        playFreeBtn: "Играть бесплатно",
        win: "ты выиграл",
        lose: "ты проиграл",
        draw: "Ничья",
        opponentDisconnected: "Противник отключился. ты выиграл"
      }
    };

    function updateLanguageTexts() {
      document.getElementById('landingTitle').textContent = languageStrings[currentLanguage].landingTitle;
      document.getElementById('landingText').textContent = languageStrings[currentLanguage].landingText;
      document.getElementById('homeBackBtn').textContent = languageStrings[currentLanguage].homeBack;
      document.getElementById('langToggleBtn').textContent = languageStrings[currentLanguage].languageToggle;
      document.getElementById('createRoomBtn').textContent = languageStrings[currentLanguage].createRoomBtn;
      document.getElementById('searchRoomBtn').textContent = languageStrings[currentLanguage].searchRoomBtn;
      document.getElementById('playFreeBtn').textContent = languageStrings[currentLanguage].playFreeBtn;
    }

    document.getElementById('langToggleBtn').addEventListener('click', function() {
      currentLanguage = currentLanguage === "en" ? "ru" : "en";
      updateLanguageTexts();
    });

    document.getElementById('homeBackBtn').addEventListener('click', function() {
      window.location.href = 'index.html';
    });

    function updateCoinDisplay(coins) {
      document.getElementById('coinButton').textContent = coins + " Coins";
    }
  </script>
</body>
</html>
