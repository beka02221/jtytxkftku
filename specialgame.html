<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>

  <!-- Шрифт Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Подключаем стили, совмещённые с дизайном -->
  <style>
    /* ========= Базовые сбросы ========= */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      margin: 0;
      padding: 0;
    }

    /* ========= Основной стиль страницы ========= */
    body {
      display: flex;
      flex-direction: column;
      background-color: #0e162e; /* Тёмный фон */
      color: #e0e0e0;           /* Основной цвет текста */
      font-family: sans-serif;  /* Общий шрифт (заголовки и кнопки отдельно) */
    }
    body.en {
      font-weight: bold;
    }

    /* ========= Заголовки ========= */
    h1, h2, h3, h4 {
      font-family: 'Press Start 2P', monospace;
      text-transform: uppercase;
      color: #bb86fc; /* Неоновый фиолетовый акцент */
    }

    /* ========= Анимация "нажатия" ========= */
    @keyframes press {
      0%   { transform: translateY(0) scale(1); }
      50%  { transform: translateY(2px) scale(0.97); }
      100% { transform: translateY(0) scale(1); }
    }

    /* ========= Кнопки (общий стиль) ========= */
    button {
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: linear-gradient(135deg, #bb86fc, #29b6f6);
      color: #000; /* Чёрный текст */
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    button:active {
      animation: press 0.15s forwards;
    }

    /* ========= Стили топ-бара (замена старого #topBar) ========= */
    #topBar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px;
      background: rgba(14,22,46,0.6); /* полупрозрачный фон */
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: 2px solid #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 2100;
    }

    /* Чтобы кнопки в #topBar были в том же стиле, 
       мы можем ничего отдельного не прописывать —
       общий стиль button уже есть. Если нужна своя 
       ширина/высота, можно добавить правила ниже:
    */
    #topBar button {
      font-size: 10px;
      padding: 5px 10px;
      min-width: 70px;
    }

    /* ========= Canvas для игры ========= */
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background: #150069; /* Можно заменить на нужный фон или картинку */
      margin-top: 80px;    /* отступ, чтобы не перекрывать topBar */
    }

    /* ========= Модальные окна (общая подложка) ========= */
    .modal-backdrop {
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal-backdrop.active {
      display: flex;
    }
    .modal {
      background: #0e162e;
      border: 2px solid #3b3b3b;
      padding: 20px;
      width: 80%;
      max-width: 360px;
      text-align: center;
      border-radius: 10px;
    }
    .modal h2 {
      margin-bottom: 10px;
      font-size: 14px;
    }
    .modal p {
      margin-bottom: 16px;
      font-size: 12px;
    }
    .modal button + button {
      margin-left: 10px;
    }

    /* ========= Модальное окно итогов игры ========= */
    .endgame-backdrop {
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    }
    .endgame-backdrop.active {
      display: flex;
    }
    .endgame-modal {
      background: #0e162e;
      border: 2px solid #3b3b3b;
      border-radius: 4px;
      padding: 16px;
      width: 80%;
      max-width: 360px;
      text-align: center;
      box-shadow: 0 0 15px #0ff;
    }
    .endgame-modal h2 {
      margin-bottom: 10px;
      font-size: 14px;
    }
    .endgame-modal p {
      margin-bottom: 16px;
      font-size: 12px;
    }

    /* ========= Модальное окно недостатка монет ========= */
    #insufficientModal {
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      display: none;
      align-items: center;
      justify-content: center;
    }
    #insufficientModal .modal {
      background-color: #6d4fba;
      border: 2px solid #3b3b3b;
      padding: 20px;
      width: 80%;
      max-width: 360px;
      text-align: center;
      border-radius: 4px;
    }

    /* ========= Кнопка для копирования ссылки ========= */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: linear-gradient(135deg, #bb86fc, #29b6f6);
      color: #000;
      border: none;
      border-radius: 4px;
      box-shadow: 0 3px rgba(0,0,0,0.3);
      cursor: pointer;
      display: none;
      transition: transform 0.2s;
    }
    #copyButton:hover {
      transform: translateX(-50%) scale(1.05);
    }
    #copyButton:active {
      animation: press 0.15s forwards;
    }

    /* ========= Лэндинг-экран (обучающая страница) ========= */
    #landingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0e162e, #150069);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      color: #ff86fc;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    .landingContent {
      max-width: 600px;
      overflow-y: auto;
    }
    .landingContent img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
      border: 2px solid #bb86fc;
      border-radius: 8px;
    }
    .landingContent h1 {
      margin: 10px 0;
      font-size: 18px;
      color: #bb86fc;
    }
    .landingContent p {
      font-size: 12px;
      line-height: 1.4;
      margin-bottom: 10px;
      text-align: left;
      color: #e0e0e0;
    }
    /* Класс для свёрнутого описания */
    .collapsed {
      max-height: 100px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    /* Кнопки внутри лэндинг-экрана */
    .landingContent button {
      margin: 10px;
    }
    /* ========= Кнопка, чтобы сворачивать/разворачивать текст ========= */
    #toggleDescBtn {
      background: transparent;
      border: none;
      color: #bb86fc;
      font-size: 18px;
      cursor: pointer;
      display: block;
      margin: 0 auto 10px;
    }

    /* ========= Карточки комнат при поиске ========= */
    .room-card {
      border: 1px solid #bb86fc;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: #e0e0e0;
      background: rgba(255,255,255,0.1);
    }

    /* ========= Кнопка "Back" во время поиска (можно скрыть/показать) ========= */
    #searchBackBtn {
      position: absolute;
      top: 60px;
      left: 10px;
    }

    /* ========= Управление (стрелки) ========= */
    #controlPanel {
      width: 150px;
      height: 150px;
      margin: 20px auto;
      position: relative;
    }
    .control-button {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 10px;
      color: #000;
      font-size: 24px;
      font-family: 'Press Start 2P', monospace;
      cursor: pointer;
      box-shadow: 0 3px rgba(0,0,0,0.3);
      transition: transform 0.1s ease;
      background: linear-gradient(135deg, #bb86fc, #29b6f6);
    }
    .control-button:hover {
      transform: scale(1.2);
    }
    .control-button:active {
      animation: press 0.15s forwards;
    }
    #btn-up {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }

    /* ========= Джойстик для мобильных ========= */
    #joystick {
      position: fixed;
      width: 100px;
      height: 100px;
      margin: -50px 0 0 -50px;
      background: rgba(100, 100, 100, 0.3);
      border: 2px solid rgba(200, 200, 200, 0.7);
      border-radius: 50%;
      display: none;
      z-index: 1000;
      touch-action: none;
    }
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      margin: -25px 0 0 -25px;
      background: rgba(200, 200, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      touch-action: none;
    }

    /* ========= Полный экран игры (при желании) ========= */
    .game-modal-backdrop {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100vh;
      background: #150069;
      display: none;
      flex-direction: column;
      z-index: 10000;
    }
    .game-modal-backdrop.active {
      display: flex;
    }
    .game-modal-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-top: 0;
    }
    .game-canvas {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

  </style>
</head>
<body>
  <!-- Верхняя панель (fixed) -->
  <div id="topBar">
    <button id="homeBackBtn">Back</button>
    <button id="coinButton" onclick="window.location.href='buy.html'">0 Coins</button>
    <button id="langToggleBtn">RU</button>
  </div>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>

  <!-- Обучающая (landing) страница -->
  <div id="landingScreen">
    <div class="landingContent">
      <img src="game_preview.jpg" alt="Game Preview">
      <h1 id="landingTitle">Special Snake PvP</h1>
      <p id="landingText" class="collapsed">
        Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!
      </p>
      <button id="toggleDescBtn">▼</button>
      <button id="createRoomBtn">Create Room</button>
      <button id="searchRoomBtn">Search Room</button>
      <button id="playFreeBtn">Play for Free</button>
    </div>
  </div>

  <!-- Модальное окно создания комнаты -->
  <div id="createRoomModal" class="modal-backdrop">
    <div class="modal">
      <h2>Создать комнату</h2>
      <p>Выберите ставку (в миллионах): <span id="betValueDisplay">1 млн</span></p>
      <input type="range" id="betSlider" min="1" max="100" value="1" step="1">
      <div style="margin-top: 20px;">
        <button id="confirmCreateRoomBtn">Создать</button>
        <button id="cancelCreateRoomBtn">Отмена</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно поиска комнат -->
  <div id="searchRoomModal" class="modal-backdrop">
    <div class="modal">
      <h2>Поиск комнат</h2>
      <div id="roomList" style="max-height: 60vh; overflow-y: auto; margin: 20px 0;">
        <!-- Здесь будут карточки с комнатами -->
      </div>
      <button id="cancelSearchRoomBtn">Назад</button>
    </div>
  </div>

  <!-- Кнопка "Back" во время поиска -->
  <button id="searchBackBtn" style="display: none;">Back</button>

  <!-- Джойстик (для мобильных устройств) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- Кнопка для копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>

  <!-- Модальное окно окончания игры -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>

  <!-- Модальное окно для недостатка монет -->
  <div id="insufficientModal" class="modal-backdrop">
    <div class="modal">
      <h2>Недостаточно монет</h2>
      <p>У вас недостаточно монет для участия в игре.</p>
      <button onclick="window.location.href='buy.html'">Пополнить</button>
    </div>
  </div>

  <!-- Cкрипт со всей логикой Special Snake PvP -->
  <script>
/* 
============================================================
  Special Snake PvP – Основной скрипт с логикой игры
============================================================
*/
let specialGameCanvas;
let specialCtx;

const GAME_AREA_X = 50;
const GAME_AREA_Y = 50;
const GAME_AREA_WIDTH = 300;
const GAME_AREA_HEIGHT = 500;

// Настройки сетки
const gridSize = 20;
const tileCountX = GAME_AREA_WIDTH / gridSize;
const tileCountY = GAME_AREA_HEIGHT / gridSize; 

let roomId = null;
let playerId = null;
let opponentId = null;
let gameStateRef = null;

// Локальная змейка
let localSnake = [];
let localDirection = 'right';
let score = 0;

// Для плавной анимации
let previousSnake = [];
let lastLogicUpdateTime = 0;

// Змейка оппонента
let opponentSnake = [];
let opponentScore = 0;
let opponentName = '';

// Для плавной анимации противника
let previousOpponentSnake = [];
let lastOpponentUpdateTime = performance.now();

let applePos = { x: 0, y: 0 };

let isGameRunning = false;
let isGameOver = false;
let countdownValue = 5;
let showOpponentNameTimeout = null;

// Таймер (1 минута)
let timerTotal = 60;
let timerCurrent = 60;

// Интервалы
let logicTimer = null;
let countdownInterval = null;

// Слушатели Firebase
let waitingListener = null;
let oppListener = null;

const snakeColors = {
  player1: '#FFFF00',
  player2: '#FF0000'
};

const LOGIC_INTERVAL = 150;
let inviteLink = "";
let opponentDisconnected = false;

/* Интерполяция с учётом wrap-around */
function interpolateCoordinate(prevVal, currVal, factor, maxVal) {
  let diff = currVal - prevVal;
  if (Math.abs(diff) > maxVal / 2) {
    if (diff > 0) diff -= maxVal;
    else diff += maxVal;
  }
  let interp = prevVal + diff * factor;
  if (interp < 0) interp += maxVal;
  if (interp >= maxVal) interp -= maxVal;
  return interp;
}

/* 1. ИНИЦИАЛИЗАЦИЯ ИГРЫ */
function initSpecialGame1() {
  specialGameCanvas = document.getElementById('specialGameCanvas');
  specialCtx = specialGameCanvas.getContext('2d');
  resetSpecialGame1();
  drawWaitingScreen();
  setupControlButtons();
}

function resetSpecialGame1() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  if (showOpponentNameTimeout) {
    clearTimeout(showOpponentNameTimeout);
    showOpponentNameTimeout = null;
  }
  roomId = null;
  playerId = null;
  opponentId = null;
  gameStateRef = null;
  localSnake = [];
  localDirection = 'right';
  score = 0;
  opponentSnake = [];
  opponentScore = 0;
  opponentName = "";
  applePos = { x: 0, y: 0 };
  isGameRunning = false;
  isGameOver = false;
  countdownValue = 5;
  timerTotal = 60;
  timerCurrent = 60;
  inviteLink = "";

  if (waitingListener && roomId) {
    firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
    waitingListener = null;
  }
  if (oppListener && roomId) {
    firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
    oppListener = null;
  }
  removeSwipeListeners();
}

/* 2. АВТО-ПОИСК/СОЗДАНИЕ БЕСПЛАТНОЙ КОМНАТЫ */
function autoJoinFreeGame() {
  const queueRef = firebase.database().ref('snakeQueue');
  queueRef.orderByChild('bet').equalTo(0).once('value')
    .then(snapshot => {
      let found = false;
      snapshot.forEach(child => {
        const room = child.val();
        if (room.status === 'waiting' && room.creator !== window.currentUser.username) {
          joinRoom(child.key);
          found = true;
          return true; // Прерываем
        }
      });
      if (!found) {
        createRoom(0);
      }
    })
    .catch(err => {
      console.error(err);
      createRoom(0);
    });
}

function deductUserCoins(amount) {
  const userRef = firebase.database().ref('users/' + window.currentUser.username);
  return userRef.transaction(function(currentData) {
    if (currentData) {
      if (currentData.coins >= amount) {
        currentData.coins -= amount;
        return currentData;
      } else {
        return;
      }
    }
    return;
  });
}

function showInsufficientModal() {
  document.getElementById('insufficientModal').style.display = 'flex';
}

function createRoom(bet) {
  if (bet > 0) {
    deductUserCoins(bet).then(function(result) {
      if (!result.committed) {
        showInsufficientModal();
        return;
      } else {
        actuallyCreateRoom(bet);
      }
    }).catch(err => {
      console.error(err);
      showInsufficientModal();
    });
  } else {
    actuallyCreateRoom(bet);
  }
}

function actuallyCreateRoom(bet) {
  const queueRef = firebase.database().ref('snakeQueue');
  roomId = queueRef.push().key;
  playerId = 'player1';
  opponentId = 'player2';
  queueRef.child(roomId).set({
    status: 'waiting',
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    creator: window.currentUser.username,
    bet: bet
  }).catch((err) => console.error('Error creating room:', err));
  queueRef.child(roomId).onDisconnect().remove();
  inviteLink = "https://mygame.example.com/invite?room=" + roomId;
  document.getElementById('copyButton').style.display = 'block';
  document.getElementById('createRoomModal').style.display = 'none';
  drawWaitingScreen();
  setupGameReferences();
  waitForOpponent();
}

function searchRooms() {
  const queueRef = firebase.database().ref('snakeQueue');
  queueRef.orderByChild('status').equalTo('waiting').once('value')
    .then(snapshot => {
      const rooms = snapshot.val();
      const roomListDiv = document.getElementById('roomList');
      roomListDiv.innerHTML = '';
      if (rooms) {
        Object.keys(rooms).forEach(roomKey => {
          const room = rooms[roomKey];
          if (room.creator === window.currentUser.username) return;
          const card = document.createElement('div');
          card.className = 'room-card';

          const detailsDiv = document.createElement('div');
          detailsDiv.style.display = 'flex';
          detailsDiv.style.alignItems = 'center';

          const icon = document.createElement('img');
          icon.src = "https://img.icons8.com/ios-filled/50/00FF00/user.png";
          icon.style.width = '40px';
          icon.style.height = '40px';
          icon.style.borderRadius = '50%';
          icon.style.marginRight = '10px';
          detailsDiv.appendChild(icon);

          const infoDiv = document.createElement('div');
          const usernameP = document.createElement('p');
          usernameP.textContent = "@" + room.creator;
          usernameP.style.margin = '0';
          usernameP.style.color = '#bb86fc';

          const betP = document.createElement('p');
          betP.textContent = room.bet + " млн";
          betP.style.margin = '0';
          betP.style.color = '#bb86fc';

          infoDiv.appendChild(usernameP);
          infoDiv.appendChild(betP);
          detailsDiv.appendChild(infoDiv);
          card.appendChild(detailsDiv);

          const joinBtn = document.createElement('button');
          joinBtn.textContent = 'Присоединиться';
          joinBtn.addEventListener('click', function() {
            joinRoom(roomKey);
          });
          card.appendChild(joinBtn);
          roomListDiv.appendChild(card);
        });
      } else {
        roomListDiv.innerHTML = '<p style="color: #bb86fc;">Нет доступных комнат</p>';
      }
    })
    .catch(err => console.error('Error searching rooms:', err));
}

function joinRoom(roomKey) {
  firebase.database().ref('snakeQueue/' + roomKey).once('value').then(snapshot => {
    const room = snapshot.val();
    const bet = room.bet || 0;
    if (bet > 0) {
      deductUserCoins(bet).then(result => {
        if (!result.committed) {
          showInsufficientModal();
          return;
        } else {
          proceedJoin(roomKey);
        }
      }).catch(err => { console.error(err); showInsufficientModal(); });
    } else {
      proceedJoin(roomKey);
    }
  });
}

function proceedJoin(roomKey) {
  roomId = roomKey;
  playerId = 'player2';
  opponentId = 'player1';
  firebase.database().ref('snakeQueue/' + roomId).update({ status: 'ready' })
    .catch(err => console.error('Error updating room status:', err));
  setupGameReferences();
  inviteLink = "https://mygame.example.com/invite?room=" + roomId;
  document.getElementById('copyButton').style.display = 'block';
  document.getElementById('searchRoomModal').style.display = 'none';
  drawWaitingScreen();
  waitForOpponent();
}

/* 3. ОЖИДАНИЕ ПРОТИВНИКА */
function waitForOpponent() {
  drawSearchScreen();
  const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
  waitingListener = statusRef.on('value', async (snapshot) => {
    const currentStatus = snapshot.val();
    if (currentStatus === 'ready') {
      statusRef.off('value', waitingListener);
      waitingListener = null;
      try {
        const oppSnapshot = await firebase.database()
          .ref('snakeGames/' + roomId + '/players/' + opponentId)
          .once('value');
        const oppData = oppSnapshot.val();
        if (oppData && oppData.username) {
          opponentName = oppData.username;
        }
      } catch(e) {
        console.error("Error reading opponent data: ", e);
      }
      drawOpponentFoundScreen();
      document.getElementById('copyButton').style.display = 'none';
      document.getElementById('topBar').style.display = 'none';
      showOpponentNameTimeout = setTimeout(() => {
        startCountdown();
      }, 2000);
    }
  });

  const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
  oppListener = oppRef.on('value', (snapshot) => {
    const oppData = snapshot.val();
    if (oppData) {
      previousOpponentSnake = opponentSnake.length ? opponentSnake.map(seg => ({...seg})) : (oppData.snake || []);
      opponentSnake = oppData.snake || [];
      opponentScore = oppData.score || 0;
      opponentName  = (oppData.username && oppData.username.trim() !== "") ? oppData.username : 'Player';
      lastOpponentUpdateTime = performance.now();
    } else {
      if (isGameRunning) {
        opponentDisconnected = true;
        setGameOver();
      }
    }
  });
}

/* 4. НАСТРОЙКА gameStateRef + СЛУШАТЕЛИ */
function setupGameReferences() {
  gameStateRef = firebase.database().ref('snakeGames/' + roomId);
  const playerRef = gameStateRef.child('players').child(playerId);

  playerRef.once('value').then((snapshot) => {
    if (!snapshot.exists()) {
      let startX, startY;
      if (playerId === 'player1') {
        startX = 3;
        startY = Math.floor(tileCountY / 2);
      } else {
        startX = tileCountX - 4;
        startY = Math.floor(tileCountY / 2);
      }
      const initialSnake = [
        { x: startX,     y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];
      playerRef.set({
        snake: initialSnake,
        direction: 'right',
        score: 0,
        username: (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") 
          ? window.currentUser.username : 'Player'
      }).catch((err) => console.error('Error initializing player data:', err));

      playerRef.onDisconnect().remove()
        .then(() => console.log("onDisconnect set for player:", playerId))
        .catch((err) => console.error("Error setting onDisconnect:", err));
    }
  });

  gameStateRef.child('apple').on('value', (snapshot) => {
    const aData = snapshot.val() || {};
    if (typeof aData.x === 'number' && typeof aData.y === 'number') {
      applePos.x = aData.x;
      applePos.y = aData.y;
    }
  });

  gameStateRef.child('gameOver').on('value', (snapshot) => {
    if (snapshot.val() === true && !isGameOver) {
      isGameOver = true;
      endGame();
    }
  });
}

/* 5. ОБРАТНЫЙ ОТСЧЁТ И СТАРТ ИГРЫ */
function startCountdown() {
  countdownValue = 5;
  countdownInterval = setInterval(() => {
    drawCountdownScreen(countdownValue);
    countdownValue--;
    if (countdownValue < 1) {
      clearInterval(countdownInterval);
      launchGame();
    }
  }, 1000);
}

function launchGame() {
  document.getElementById('topBar').style.display = 'none';
  isGameRunning = true;
  isGameOver = false;

  gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
    const data = snapshot.val();
    if (data && data.snake) {
      localSnake = data.snake;
    }
    localDirection = (data && data.direction) ? data.direction : 'right';
    score = (data && data.score) ? data.score : 0;
    
    previousSnake = localSnake.map(seg => ({...seg}));
    lastLogicUpdateTime = performance.now();

    gameStateRef.child('apple').once('value').then((appleSnap) => {
      if (!appleSnap.exists()) {
        spawnApple();
      }
    });

    addSwipeListeners();
    startLogicLoop();
    startTimer();
    requestAnimationFrame(renderLoop);
  });
}

/* 6. ЛОГИКА ИГРЫ / ОБНОВЛЕНИЕ */
function startLogicLoop() {
  logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
}
function stopLogicLoop() {
  if (logicTimer) {
    clearInterval(logicTimer);
    logicTimer = null;
  }
}

function gameLogicUpdate() {
  if (!isGameRunning || isGameOver) return;

  previousSnake = localSnake.map(seg => ({...seg}));
  moveLocalSnake();
  lastLogicUpdateTime = performance.now();

  if (checkSelfCollision()) {
    setGameOver();
    return;
  }

  const head = localSnake[0];
  if (head.x === applePos.x && head.y === applePos.y) {
    score++;
    updatePlayerState(true);
    spawnApple();
  } else {
    updatePlayerState(false);
  }
}

function renderLoop() {
  renderGame();
  if (!isGameOver) {
    requestAnimationFrame(renderLoop);
  }
}

/* 7. ДВИЖЕНИЕ ЗМЕЙКИ И СТОЛКНОВЕНИЯ */
function moveLocalSnake() {
  const head = { ...localSnake[0] };
  switch (localDirection) {
    case 'left':  head.x--; break;
    case 'right': head.x++; break;
    case 'up':    head.y--; break;
    case 'down':  head.y++; break;
  }
  if (head.x < 0) head.x = tileCountX - 1;
  if (head.x >= tileCountX) head.x = 0;
  if (head.y < 0) head.y = tileCountY - 1;
  if (head.y >= tileCountY) head.y = 0;
  localSnake.unshift(head);
  localSnake.pop();
}

function checkSelfCollision() {
  return false; // при необходимости дописать
}

/* 8. ОБНОВЛЕНИЕ СОСТОЯНИЯ В FIREBASE */
function updatePlayerState(ateApple) {
  if (ateApple) {
    const lastSegment = localSnake[localSnake.length - 1];
    localSnake.push({ ...lastSegment });
  }
  gameStateRef.child('players').child(playerId).update({
    snake: localSnake,
    direction: localDirection,
    score: score
  }).catch((err) => console.error('Error updating player state:', err));
}

function spawnApple() {
  const newApple = {
    x: Math.floor(Math.random() * tileCountX),
    y: Math.floor(Math.random() * tileCountY)
  };
  gameStateRef.child('apple').set(newApple)
    .catch((err) => console.error('Error setting apple:', err));
}

/* 9. КОНЕЦ ИГРЫ */
function setGameOver() {
  isGameOver = true;
  gameStateRef.update({ gameOver: true })
    .catch((err) => console.error('Error setting gameOver:', err));
  endGame();
}

function endGame() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  let resultTitle = '';
  if (opponentDisconnected) {
    resultTitle = (currentLanguage === 'ru')
      ? 'Противник отключился. ты выиграл'
      : 'Opponent Disconnected. You Win!';
  } else {
    if (score > opponentScore) {
      resultTitle = (currentLanguage === 'ru') ? 'ты выиграл' : 'You Win!';
    } else if (score < opponentScore) {
      resultTitle = (currentLanguage === 'ru') ? 'ты проиграл' : 'You Lose...';
    } else {
      resultTitle = (currentLanguage === 'ru') ? 'Ничья' : 'Draw';
    }
  }
  const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
  showEndGameModal(resultTitle, msg);
  cleanupRoom();
}

/* 10. ТАЙМЕР (1 минута) */
function startTimer() {
  timerCurrent = timerTotal;
  const timerInterval = setInterval(() => {
    if (!isGameRunning || isGameOver) {
      clearInterval(timerInterval);
      return;
    }
    timerCurrent--;
    if (timerCurrent <= 0) {
      setGameOver();
      clearInterval(timerInterval);
    }
  }, 1000);
}

/* 11. РЕНДЕР ИГРЫ (с интерполяцией) */
function renderGame() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  // Заливка фона
  specialCtx.fillStyle = '#150069';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  drawMatrixGrid();

  let now = performance.now();
  let factor = Math.min((now - lastLogicUpdateTime) / LOGIC_INTERVAL, 1);

  // Рисуем яблоко (пример со спрайтом)
  let appleImg = new Image();
  appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
  if (appleImg.complete) {
    specialCtx.drawImage(
      appleImg,
      GAME_AREA_X + applePos.x * gridSize,
      GAME_AREA_Y + applePos.y * gridSize,
      gridSize,
      gridSize
    );
  }

  // Локальная змейка
  for (let i = 0; i < localSnake.length; i++) {
    let curr = localSnake[i];
    let prev = previousSnake[i] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
    let x = GAME_AREA_X + interpX * gridSize;
    let y = GAME_AREA_Y + interpY * gridSize;
    specialCtx.fillStyle = snakeColors[playerId] || '#800080';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  }

  // Змейка противника
  let opponentFactor = Math.min((now - lastOpponentUpdateTime) / LOGIC_INTERVAL, 1);
  for (let i = 0; i < opponentSnake.length; i++) {
    let curr = opponentSnake[i];
    let prev = previousOpponentSnake[i] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
    let x = GAME_AREA_X + interpX * gridSize;
    let y = GAME_AREA_Y + interpY * gridSize;
    specialCtx.fillStyle = snakeColors[opponentId]
