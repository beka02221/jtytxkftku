<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>

  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Your CSS (например, st1.css) -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* Общие стили страницы */
    body {
      margin: 0;
      padding: 0;
      background: #00103c;
      color: #FF00FF;
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
      overflow: hidden;
    }

    /* Стили шапки (навигация) – теперь без фиксированного позиционирования */
    #landingHeader {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    #landingHeader button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Кнопка баланса (при нажатии переходит на buy.html) – теперь как обычный элемент шапки */
    #coinButton {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

    /* Canvas для игры */
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background-image: url('1.jpg');
    }

    /* Элемент с никами под игровым полем */
    #usernamesDisplay {
      display: none;
      text-align: center;
      font-family: 'Press Start 2P', sans-serif;
      margin-top: 10px;
    }

    /* Кнопка копирования ссылки */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
      display: none;
    }
    #copyButton:hover {
      transform: scale(1.05);
    }
    #copyButton:active {
      animation: press 0.15s forwards;
      transform: translateY(1px) scale(1.0);
    }

    /* Остальные стили (модальные окна, джойстик, обучающая страница и т.д.) остаются без изменений */
    /* ... (остальной CSS из оригинального кода) ... */

    /* Пример стилей для остальных элементов из вашего исходного кода */
    #joystick {
      position: fixed;
      width: 100px;
      height: 100px;
      margin: -50px 0 0 -50px;
      background: rgba(100, 100, 100, 0.3);
      border: 2px solid rgba(200, 200, 200, 0.7);
      border-radius: 50%;
      display: none;
      z-index: 1000;
      touch-action: none;
    }
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      margin: -25px 0 0 -25px;
      background: rgba(200, 200, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      touch-action: none;
    }
    #landingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #00103c, #0a0a23);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      color: #FF00FF;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    .landingContent {
      max-width: 600px;
      overflow-y: auto;
    }
    .landingContent img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
      border: 2px solid #FF00FF;
      border-radius: 8px;
    }
    .landingContent h1 {
      margin: 10px 0;
      font-size: 28px;
    }
    .landingContent p {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 20px;
      text-align: left;
    }
    .landingContent button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 14px;
      padding: 10px 20px;
      margin: 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
      transition: transform 0.1s ease;
    }
    .landingContent button:hover {
      transform: scale(1.05);
    }
    .landingContent button:active {
      transform: translateY(1px);
    }
  </style>
</head>

<body>
  <!-- Шапка обучающего экрана с кнопками Back, балансом и переключателем языка -->
  <div id="landingHeader">
    <button id="homeBackBtn">Back</button>
    <button id="coinButton" onclick="window.location.href='buy.html'">0 Coins</button>
    <button id="langToggleBtn">RU</button>
  </div>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>
  <!-- Элемент для отображения ников под игровым полем -->
  <div id="usernamesDisplay">
    <span id="opponentUsername"></span>
    <span style="margin: 0 20px;">VS</span>
    <span id="playerUsername"></span>
  </div>

  <!-- Обучающая страница -->
  <div id="landingScreen">
    <div class="landingContent">
      <img src="game_preview.jpg" alt="Game Preview">
      <h1 id="landingTitle">Special Snake PvP</h1>
      <p id="landingText">
        Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!
      </p>
      <!-- Новые кнопки -->
      <button id="createRoomBtn">Создать рум</button>
      <button id="searchRoomBtn">Поиск рум</button>
      <button id="playFreeBtn">Играть бесплатно</button>
    </div>
  </div>

  <!-- Модальные окна и остальные элементы (создание комнаты, поиск, копирование ссылки, джойстик, модальное окно Game Over и т.д.) остаются без изменений -->
  <!-- ... (оставляем HTML из предыдущей версии без изменений) ... -->

  <!-- Пример: Модальное окно для создания комнаты -->
  <div id="createRoomModal" class="modal-backdrop">
    <div class="modal">
      <h2>Создать комнату</h2>
      <p>Выберите ставку (в миллионах): <span id="betValueDisplay">1 млн</span></p>
      <input type="range" id="betSlider" min="1" max="100" value="1" step="1">
      <div style="margin-top: 20px;">
        <button id="confirmCreateRoomBtn">Создать</button>
        <button id="cancelCreateRoomBtn">Отмена</button>
      </div>
    </div>
  </div>

  <!-- Остальные модальные окна и элементы, например, для поиска комнат, копирования ссылки и т.д. -->
  <!-- ... (оставляем остальные блоки без изменений) ... -->

  <script>
/* 
============================================================
  Special Snake PvP – Код игры с изменениями для отображения баланса
============================================================
*/

// Глобальные переменные для canvas и контекста
let specialGameCanvas;
let specialCtx;

// Область игры (центрированная на canvas)
const GAME_AREA_X = 50;
const GAME_AREA_Y = 50;
const GAME_AREA_WIDTH = 300;
const GAME_AREA_HEIGHT = 500;

// Настройки сетки
const gridSize = 20;
const tileCountX = GAME_AREA_WIDTH / gridSize;  
const tileCountY = GAME_AREA_HEIGHT / gridSize; 

// Идентификаторы комнаты и игроков
let roomId = null;
let playerId = null;
let opponentId = null;
let gameStateRef = null;

// Локальное состояние змейки
let localSnake = [];
let localDirection = 'right';
let score = 0;

// Для плавной анимации локальной змейки
let previousSnake = [];
let lastLogicUpdateTime = 0;

// Состояние змейки противника
let opponentSnake = [];
let opponentScore = 0;
let opponentName = '';

// Для плавной анимации змейки противника
let previousOpponentSnake = [];
let lastOpponentUpdateTime = performance.now();

// Позиция яблока
let applePos = { x: 0, y: 0 };

// Флаги игры
let isGameRunning = false;
let isGameOver = false;
let countdownValue = 5;
let showOpponentNameTimeout = null;

// Таймер (1 минута)
let timerTotal = 60;
let timerCurrent = 60;

// Интервалы
let logicTimer = null;
let countdownInterval = null;

// Слушатели Firebase для ожидания
let waitingListener = null;
let oppListener = null;

// Цвета змейки
const snakeColors = {
  player1: '#FFFF00', // желтый
  player2: '#FF0000'  // красный
};

// Логический интервал (мс)
const LOGIC_INTERVAL = 150;

// Пригласительная ссылка
let inviteLink = "";

// Флаг отключения противника (авто-победа)
let opponentDisconnected = false;

/* ======================================
   Функция интерполяции координат
====================================== */
function interpolateCoordinate(prevVal, currVal, factor, maxVal) {
  let diff = currVal - prevVal;
  if (Math.abs(diff) > maxVal / 2) {
    if (diff > 0) diff -= maxVal;
    else diff += maxVal;
  }
  let interp = prevVal + diff * factor;
  if (interp < 0) interp += maxVal;
  if (interp >= maxVal) interp -= maxVal;
  return interp;
}

/* ======================================
   1. Инициализация и сброс
====================================== */
function initSpecialGame1() {
  specialGameCanvas = document.getElementById('specialGameCanvas');
  specialCtx = specialGameCanvas.getContext('2d');

  resetSpecialGame1();
  drawWaitingScreen();

  // Настраиваем слушатели ввода (джойстик + клавиатура)
  setupControlButtons();
}

function resetSpecialGame1() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  if (showOpponentNameTimeout) {
    clearTimeout(showOpponentNameTimeout);
    showOpponentNameTimeout = null;
  }
  roomId = null;
  playerId = null;
  opponentId = null;
  gameStateRef = null;
  localSnake = [];
  localDirection = 'right';
  score = 0;
  opponentSnake = [];
  opponentScore = 0;
  opponentName = "";
  applePos = { x: 0, y: 0 };
  isGameRunning = false;
  isGameOver = false;
  countdownValue = 5;
  timerTotal = 60;
  timerCurrent = 60;
  inviteLink = "";

  if (waitingListener && roomId) {
    firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
    waitingListener = null;
  }
  if (oppListener && roomId) {
    firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
    oppListener = null;
  }
  removeSwipeListeners();
}

/* ======================================
   2. Создание/поиск комнат
====================================== */
function createRoom(bet) {
  const queueRef = firebase.database().ref('snakeQueue');
  roomId = queueRef.push().key;
  playerId = 'player1';
  opponentId = 'player2';
  queueRef.child(roomId).set({
    status: 'waiting',
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    creator: window.currentUser.username,
    bet: bet
  }).catch((err) => console.error('Error creating room:', err));
  queueRef.child(roomId).onDisconnect().remove();
  inviteLink = "https://mygame.example.com/invite?room=" + roomId;
  document.getElementById('copyButton').style.display = 'block';
  document.getElementById('createRoomModal').style.display = 'none';
  drawWaitingScreen();
  setupGameReferences();
  waitForOpponent();
}

function searchRooms() {
  const queueRef = firebase.database().ref('snakeQueue');
  queueRef.orderByChild('status').equalTo('waiting').once('value')
    .then(snapshot => {
      const rooms = snapshot.val();
      const roomListDiv = document.getElementById('roomList');
      roomListDiv.innerHTML = '';
      if (rooms) {
        Object.keys(rooms).forEach(roomKey => {
          const room = rooms[roomKey];
          if (room.creator === window.currentUser.username) return;
          const card = document.createElement('div');
          card.className = 'room-card';
          const detailsDiv = document.createElement('div');
          detailsDiv.style.display = 'flex';
          detailsDiv.style.alignItems = 'center';
          const icon = document.createElement('img');
          icon.src = "https://img.icons8.com/ios-filled/50/00FF00/user.png";
          icon.style.width = '40px';
          icon.style.height = '40px';
          icon.style.borderRadius = '50%';
          icon.style.marginRight = '10px';
          detailsDiv.appendChild(icon);
          const infoDiv = document.createElement('div');
          const usernameP = document.createElement('p');
          usernameP.textContent = "@" + room.creator;
          usernameP.style.margin = '0';
          usernameP.style.color = '#FF00FF';
          const betP = document.createElement('p');
          betP.textContent = room.bet + " млн";
          betP.style.margin = '0';
          betP.style.color = '#FF00FF';
          infoDiv.appendChild(usernameP);
          infoDiv.appendChild(betP);
          detailsDiv.appendChild(infoDiv);
          card.appendChild(detailsDiv);
          const joinBtn = document.createElement('button');
          joinBtn.textContent = 'Присоединиться';
          joinBtn.style.fontFamily = 'Press Start 2P, sans-serif';
          joinBtn.style.fontSize = '12px';
          joinBtn.style.padding = '5px 10px';
          joinBtn.style.background = '#06B6D1';
          joinBtn.style.color = '#262626';
          joinBtn.style.border = 'none';
          joinBtn.style.borderRadius = '4px';
          joinBtn.style.cursor = 'pointer';
          joinBtn.style.boxShadow = '0 3px #6b6b6b';
          joinBtn.addEventListener('click', function() {
             joinRoom(roomKey);
          });
          card.appendChild(joinBtn);
          roomListDiv.appendChild(card);
        });
      } else {
         roomListDiv.innerHTML = '<p style="color: #FF00FF;">Нет доступных комнат</p>';
      }
    })
    .catch(err => console.error('Error searching rooms:', err));
}

function joinRoom(roomKey) {
  roomId = roomKey;
  playerId = 'player2';
  opponentId = 'player1';
  firebase.database().ref('snakeQueue/' + roomId).update({ status: 'ready' })
    .catch(err => console.error('Error updating room status:', err));
  setupGameReferences();
  inviteLink = "https://mygame.example.com/invite?room=" + roomId;
  document.getElementById('copyButton').style.display = 'block';
  document.getElementById('searchRoomModal').style.display = 'none';
  drawWaitingScreen();
  waitForOpponent();
}

/* ======================================
   3. Ожидание противника
====================================== */
function waitForOpponent() {
  drawSearchScreen();

  const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
  waitingListener = statusRef.on('value', async (snapshot) => {
    const currentStatus = snapshot.val();
    if (currentStatus === 'ready') {
      statusRef.off('value', waitingListener);
      waitingListener = null;
      try {
        const oppSnapshot = await firebase.database()
          .ref('snakeGames/' + roomId + '/players/' + opponentId)
          .once('value');
        const oppData = oppSnapshot.val();
        if (oppData && oppData.username) {
          opponentName = oppData.username;
        }
      } catch(e) {
        console.error("Error reading opponent data: ", e);
      }
      drawOpponentFoundScreen();
      document.getElementById('copyButton').style.display = 'none';
      document.getElementById('homeBackBtn').style.display = 'none';
      showOpponentNameTimeout = setTimeout(() => {
        startCountdown();
      }, 2000);
    }
  });

  const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
  oppListener = oppRef.on('value', (snapshot) => {
    const oppData = snapshot.val();
    if (oppData) {
      previousOpponentSnake = opponentSnake.length ? opponentSnake.map(seg => ({...seg})) : (oppData.snake || []);
      opponentSnake = oppData.snake || [];
      opponentScore = oppData.score || 0;
      opponentName  = (oppData.username && oppData.username.trim() !== "") ? oppData.username : 'Player';
      lastOpponentUpdateTime = performance.now();
    } else {
      if (isGameRunning) {
        opponentDisconnected = true;
        setGameOver();
      }
    }
  });
}

/* ======================================
   4. Настройка gameStateRef + слушатели
====================================== */
function setupGameReferences() {
  gameStateRef = firebase.database().ref('snakeGames/' + roomId);
  const playerRef = gameStateRef.child('players').child(playerId);

  playerRef.once('value').then((snapshot) => {
    if (!snapshot.exists()) {
      let startX, startY;
      if (playerId === 'player1') {
        startX = 3;
        startY = Math.floor(tileCountY / 2);
      } else {
        startX = tileCountX - 4;
        startY = Math.floor(tileCountY / 2);
      }
      const initialSnake = [
        { x: startX,     y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];
      playerRef.set({
        snake: initialSnake,
        direction: 'right',
        score: 0,
        username: (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'Player'
      }).catch((err) => console.error('Error initializing player data:', err));

      playerRef.onDisconnect().remove()
        .then(() => console.log("onDisconnect set for player:", playerId))
        .catch((err) => console.error("Error setting onDisconnect:", err));
    }
  });

  gameStateRef.child('apple').on('value', (snapshot) => {
    const aData = snapshot.val() || {};
    if (typeof aData.x === 'number' && typeof aData.y === 'number') {
      applePos.x = aData.x;
      applePos.y = aData.y;
    }
  });

  gameStateRef.child('gameOver').on('value', (snapshot) => {
    if (snapshot.val() === true && !isGameOver) {
      isGameOver = true;
      endGame();
    }
  });
}

/* ======================================
   5. Обратный отсчёт и старт игры
====================================== */
function startCountdown() {
  countdownValue = 5;
  countdownInterval = setInterval(() => {
    drawCountdownScreen(countdownValue);
    countdownValue--;
    if (countdownValue < 1) {
      clearInterval(countdownInterval);
      launchGame();
    }
  }, 1000);
}

function launchGame() {
  isGameRunning = true;
  isGameOver = false;

  gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
    const data = snapshot.val();
    if (data && data.snake) {
      localSnake = data.snake;
    }
    localDirection = (data && data.direction) ? data.direction : 'right';
    score = (data && data.score) ? data.score : 0;
    
    previousSnake = localSnake.map(seg => ({...seg}));
    lastLogicUpdateTime = performance.now();

    gameStateRef.child('apple').once('value').then((appleSnap) => {
      if (!appleSnap.exists()) {
        spawnApple();
      }
    });

    addSwipeListeners();
    startLogicLoop();
    startTimer();
    requestAnimationFrame(renderLoop);
    
    updateUsernamesDisplay();
  });
}

/* ======================================
   6. Логика игры и рендер
====================================== */
function startLogicLoop() {
  logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
}

function stopLogicLoop() {
  if (logicTimer) {
    clearInterval(logicTimer);
    logicTimer = null;
  }
}

function gameLogicUpdate() {
  if (!isGameRunning || isGameOver) return;

  previousSnake = localSnake.map(seg => ({...seg}));
  moveLocalSnake();
  lastLogicUpdateTime = performance.now();

  if (checkSelfCollision()) {
    setGameOver();
    return;
  }

  const head = localSnake[0];
  if (head.x === applePos.x && head.y === applePos.y) {
    score++;
    updatePlayerState(true);
    spawnApple();
  } else {
    updatePlayerState(false);
  }
}

function renderLoop() {
  renderGame();
  if (!isGameOver) {
    requestAnimationFrame(renderLoop);
  }
}

/* ======================================
   7. Движение и столкновения
====================================== */
function moveLocalSnake() {
  const head = { ...localSnake[0] };
  switch (localDirection) {
    case 'left':  head.x--; break;
    case 'right': head.x++; break;
    case 'up':    head.y--; break;
    case 'down':  head.y++; break;
  }
  if (head.x < 0) head.x = tileCountX - 1;
  if (head.x >= tileCountX) head.x = 0;
  if (head.y < 0) head.y = tileCountY - 1;
  if (head.y >= tileCountY) head.y = 0;
  localSnake.unshift(head);
  localSnake.pop();
}

function checkSelfCollision() {
  return false;
}

/* ======================================
   8. Обновление состояния в Firebase
====================================== */
function updatePlayerState(ateApple) {
  if (ateApple) {
    const lastSegment = localSnake[localSnake.length - 1];
    localSnake.push({ ...lastSegment });
  }
  gameStateRef.child('players').child(playerId).update({
    snake: localSnake,
    direction: localDirection,
    score: score
  }).catch((err) => console.error('Error updating player state:', err));
}

function spawnApple() {
  const newApple = {
    x: Math.floor(Math.random() * tileCountX),
    y: Math.floor(Math.random() * tileCountY)
  };
  gameStateRef.child('apple').set(newApple)
    .catch((err) => console.error('Error setting apple:', err));
}

/* ======================================
   9. Конец игры
====================================== */
function setGameOver() {
  isGameOver = true;
  gameStateRef.update({ gameOver: true })
    .catch((err) => console.error('Error setting gameOver:', err));
  endGame();
}

function endGame() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  let resultTitle = 'Game Over';
  if (opponentDisconnected) {
    resultTitle = 'Opponent Disconnected. You Win!';
  } else {
    if (score > opponentScore) {
      resultTitle = 'You Win!';
    } else if (score < opponentScore) {
      resultTitle = 'You Lose...';
    } else {
      resultTitle = 'Draw';
    }
  }
  const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
  showEndGameModal(resultTitle, msg);
  cleanupRoom();
}

/* ======================================
   10. Таймер (1 минута)
====================================== */
function startTimer() {
  timerCurrent = timerTotal;
  const timerInterval = setInterval(() => {
    if (!isGameRunning || isGameOver) {
      clearInterval(timerInterval);
      return;
    }
    timerCurrent--;
    if (timerCurrent <= 0) {
      setGameOver();
      clearInterval(timerInterval);
    }
  }, 1000);
}

/* ======================================
   11. Рендер игры
====================================== */
function renderGame() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  drawMatrixGrid();

  let now = performance.now();
  let factor = Math.min((now - lastLogicUpdateTime) / LOGIC_INTERVAL, 1);

  // Рисуем яблоко
  let appleImg = new Image();
  appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
  if (appleImg.complete) {
    specialCtx.drawImage(
      appleImg,
      GAME_AREA_X + applePos.x * gridSize,
      GAME_AREA_Y + applePos.y * gridSize,
      gridSize,
      gridSize
    );
  }

  // Рисуем локальную змейку
  for (let i = 0; i < localSnake.length; i++) {
    let curr = localSnake[i];
    let prev = previousSnake[i] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
    let x = GAME_AREA_X + interpX * gridSize;
    let y = GAME_AREA_Y + interpY * gridSize;
    specialCtx.fillStyle = snakeColors[playerId] || '#800080';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  }

  // Рисуем змейку противника
  let opponentFactor = Math.min((now - lastOpponentUpdateTime) / LOGIC_INTERVAL, 1);
  for (let i = 0; i < opponentSnake.length; i++) {
    let curr = opponentSnake[i];
    let prev = previousOpponentSnake[i] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
    let x = GAME_AREA_X + interpX * gridSize;
    let y = GAME_AREA_Y + interpY * gridSize;
    specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  }

  // Имена игроков
  if (opponentSnake.length > 0) {
    let curr = opponentSnake[0];
    let prev = previousOpponentSnake[0] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
    specialCtx.fillStyle = "lime";
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    specialCtx.fillText(
      '@' + ((opponentName && opponentName.trim() !== "") ? opponentName : 'Anonymous'),
      GAME_AREA_X + interpX * gridSize,
      GAME_AREA_Y + interpY * gridSize - 5
    );
  }
  if (localSnake.length > 0) {
    let curr = localSnake[0];
    let prev = previousSnake[0] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
    specialCtx.fillStyle = "lime";
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    const myName = (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'You';
    specialCtx.fillText(
      '@' + myName,
      GAME_AREA_X + interpX * gridSize,
      GAME_AREA_Y + interpY * gridSize - 5
    );
  }

  // Счёт и таймер
  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '12px "Press Start 2P", sans-serif';
  specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
  specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);
  const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
  specialCtx.fillStyle = '#FF00FF';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
}

function drawMatrixGrid() {
  specialCtx.fillStyle = '#433171';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

  specialCtx.strokeStyle = '#00103c';
  for (let i = 0; i <= tileCountX; i++) {
    let x = GAME_AREA_X + i * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(x, GAME_AREA_Y);
    specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
    specialCtx.stroke();
  }
  for (let j = 0; j <= tileCountY; j++) {
    let y = GAME_AREA_Y + j * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(GAME_AREA_X, y);
    specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
    specialCtx.stroke();
  }
  specialCtx.strokeStyle = '#8F509D';
  specialCtx.lineWidth = 2;
  specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
}

/* ======================================
   12. Экраны ожидания, поиска, обратного отсчёта
====================================== */
function drawSearchScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '15px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(
    'Searching for opponent...',
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
}

function drawWaitingScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#000';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
}

function drawOpponentFoundScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '16px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  const displayName = (opponentName && opponentName.trim() !== "") ? opponentName : "Anonymous";
  specialCtx.fillText('Opponent: @' + displayName, specialGameCanvas.width / 2, specialGameCanvas.height / 2);
}

function drawCountdownScreen(value) {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '60px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(value.toString(), specialGameCanvas.width / 2, specialGameCanvas.height / 2);
}

/* ======================================
   13. Обработка ввода: джойстик и клавиатура
====================================== */
function addSwipeListeners() {
  function onKeyDown(e) {
    switch (e.key) {
      case 'ArrowLeft':
        if (localDirection !== 'right') localDirection = 'left';
        break;
      case 'ArrowRight':
        if (localDirection !== 'left') localDirection = 'right';
        break;
      case 'ArrowUp':
        if (localDirection !== 'down') localDirection = 'up';
        break;
      case 'ArrowDown':
        if (localDirection !== 'up') localDirection = 'down';
        break;
    }
  }
  window.addEventListener('keydown', onKeyDown);
  window.__joystick_keydown = onKeyDown;

  const canvas = specialGameCanvas;
  const joystick = document.getElementById('joystick');
  const joystickStick = document.getElementById('joystick-stick');
  let joystickActive = false;
  let joystickCenter = { x: 0, y: 0 };
  const maxDistance = 40;

  function handleTouchStart(e) {
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      joystickCenter.x = touch.clientX;
      joystickCenter.y = touch.clientY;
      joystick.style.left = joystickCenter.x + 'px';
      joystick.style.top = joystickCenter.y + 'px';
      joystick.style.display = 'block';
      joystickStick.style.transform = 'translate(0px, 0px)';
      joystickActive = true;
      e.preventDefault();
    }
  }

  function handleTouchMove(e) {
    if (!joystickActive) return;
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      let dx = touch.clientX - joystickCenter.x;
      let dy = touch.clientY - joystickCenter.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDistance;
        dy = Math.sin(angle) * maxDistance;
      }
      joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && localDirection !== 'left') {
          localDirection = 'right';
        } else if (dx < 0 && localDirection !== 'right') {
          localDirection = 'left';
        }
      } else {
        if (dy > 0 && localDirection !== 'up') {
          localDirection = 'down';
        } else if (dy < 0 && localDirection !== 'down') {
          localDirection = 'up';
        }
      }
      e.preventDefault();
    }
  }

  function handleTouchEnd(e) {
    joystickActive = false;
    joystick.style.display = 'none';
    e.preventDefault();
  }

  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

  window.__joystick_touchstart = handleTouchStart;
  window.__joystick_touchmove = handleTouchMove;
  window.__joystick_touchend = handleTouchEnd;
}

function removeSwipeListeners() {
  if (!specialGameCanvas) return;
  specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
  specialGameCanvas.removeEventListener('touchmove', window.__joystick_touchmove);
  specialGameCanvas.removeEventListener('touchend', window.__joystick_touchend);
  window.removeEventListener('keydown', window.__joystick_keydown);
  window.__joystick_touchstart = null;
  window.__joystick_touchmove = null;
  window.__joystick_touchend = null;
  window.__joystick_keydown = null;
}

/* ======================================
   14. Копирование ссылки
====================================== */
function copyInviteLink() {
  if (!inviteLink) return;
  navigator.clipboard.writeText(inviteLink)
    .then(() => { console.log("Invite link copied:", inviteLink); })
    .catch(err => console.error("Error copying invite link:", err));
}

/* ======================================
   15. Модальное окно конца игры
====================================== */
function showEndGameModal(title, message) {
  const modal = document.getElementById('endgameBackdrop');
  const titleEl = document.getElementById('endgameTitle');
  const msgEl = document.getElementById('endgameMessage');
  titleEl.textContent = title;
  msgEl.textContent = message;
  modal.classList.add('active');
}

/* ======================================
   16. Настройка кнопок управления
====================================== */
function setupControlButtons() {
  const buttons = document.querySelectorAll('.control-button');
  buttons.forEach(button => {
    button.addEventListener('click', () => {
      const newDirection = button.getAttribute('data-direction');
      if ((localDirection === 'left'  && newDirection === 'right') ||
          (localDirection === 'right' && newDirection === 'left')  ||
          (localDirection === 'up'    && newDirection === 'down')  ||
          (localDirection === 'down'  && newDirection === 'up')) {
        return;
      }
      localDirection = newDirection;
    });
  });
}

/* ======================================
   17. Уборка комнаты после игры
====================================== */
function cleanupRoom() {
  if (roomId) {
    firebase.database().ref('snakeGames/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeGames."))
      .catch((err) => console.error("Error removing game room:", err));

    firebase.database().ref('snakeQueue/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeQueue."))
      .catch((err) => console.error("Error removing room from snakeQueue:", err));
  }
}

window.addEventListener('beforeunload', function() {
  if (roomId && gameStateRef) {
    gameStateRef.child('players').child(playerId).remove();
  }
});

/* ======================================
   18. Финиш игры и возврат в меню
====================================== */
function finishGame() {
  document.getElementById('endgameBackdrop').classList.remove('active');
  window.location.href = 'index.html';
}
function returnToMain() {
  document.getElementById('noTicketsModal').classList.remove('active');
  window.location.href = 'index.html';
}

/* ======================================
   19. Слушатели кнопок на обучающей странице
====================================== */
document.getElementById('createRoomBtn').addEventListener('click', function(){
  document.getElementById('landingScreen').style.display = 'none';
  document.getElementById('createRoomModal').style.display = 'flex';
});

document.getElementById('searchRoomBtn').addEventListener('click', function(){
  document.getElementById('landingScreen').style.display = 'none';
  document.getElementById('searchRoomModal').style.display = 'flex';
  searchRooms();
});

document.getElementById('playFreeBtn').addEventListener('click', function(){
  document.getElementById('landingScreen').style.display = 'none';
  createRoom(0);
});

document.getElementById('cancelCreateRoomBtn').addEventListener('click', function(){
  document.getElementById('createRoomModal').style.display = 'none';
  document.getElementById('landingScreen').style.display = 'flex';
});
document.getElementById('confirmCreateRoomBtn').addEventListener('click', function(){
  let betValue = parseInt(document.getElementById('betSlider').value);
  createRoom(betValue);
});
document.getElementById('betSlider').addEventListener('input', function(){
  let value = document.getElementById('betSlider').value;
  document.getElementById('betValueDisplay').textContent = value + " млн";
});

document.getElementById('cancelSearchRoomBtn').addEventListener('click', function(){
  document.getElementById('searchRoomModal').style.display = 'none';
  document.getElementById('landingScreen').style.display = 'flex';
});

/* ======================================
   20. Запуск игры при загрузке страницы
====================================== */
window.addEventListener('load', () => {
  const firebaseConfig = {
    apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
    authDomain: "test-with-likes.firebaseapp.com",
    databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
    projectId: "test-with-likes",
    storageBucket: "test-with-likes.appspot.com",
    messagingSenderId: "764738820142",
    appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
    measurementId: "G-WJNF0HSN9P"
  };
  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
  }
  const db = firebase.database();

  // Инициализация пользователя из Telegram WebApp и получение данных о балансе из Firebase
  if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
    const tgUser = Telegram.WebApp.initDataUnsafe.user;
    window.currentUser = {
      username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
      photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
    };
    const userRef = db.ref('users/' + window.currentUser.username);
    userRef.once('value').then(snapshot => {
      if (!snapshot.exists()) {
        userRef.set({ coins: 100 });
      }
    });
    userRef.on('value', snapshot => {
      const data = snapshot.val() || {};
      window.currentUser.coins = data.coins || 0;
      updateCoinDisplay();
    });
  } else {
    window.currentUser = {
      username: "TestUser",
      photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png",
      coins: 100
    };
    updateCoinDisplay();
  }
  
  initSpecialGame1();
  updateLanguageTexts();
});

/* ======================================
   Функция смены направления
====================================== */
function changeDirection(newDir) {
  if (
    (newDir === 'up'    && localDirection === 'down') ||
    (newDir === 'down'  && localDirection === 'up')   ||
    (newDir === 'left'  && localDirection === 'right')||
    (newDir === 'right' && localDirection === 'left')
  ) {
    return;
  }
  localDirection = newDir;
}

/* ======================================
   21. Функции для смены языка
====================================== */
let currentLanguage = "en";
const languageStrings = {
  en: {
    landingTitle: "Special Snake PvP",
    landingText: "Welcome to Special Snake PvP – an exciting world of dynamic PvP battles where speed, strategy, and reflexes determine every fight! Control your unique snake in retro style, with striking graphics and atmospheric sound effects. Every second is a battle for survival: avoid collisions, collect bonuses, and outmaneuver your opponent in the arena maze. Play with friends or random opponents in real-time and prove that you are a true snake master!",
    startSearch: "Start Search",
    homeBack: "Back",
    languageToggle: "RU"
  },
  ru: {
    landingTitle: "Спешл Снейк PvP",
    landingText: "Добро пожаловать в Special Snake PvP – захватывающий мир динамичных PvP-сражений, где скорость, стратегия и рефлексы решают судьбу каждой битвы! Управляйте своей уникальной змеей в ретро-стилистике, с эффектной графикой и атмосферным звуковым сопровождением. Каждая секунда – это борьба за выживание: избегайте столкновений, собирайте бонусы и опережайте противника в лабиринте арены. Играйте с друзьями или случайными противниками в режиме реального времени и докажите, что вы – настоящий мастер змей!",
    startSearch: "Начать поиск",
    homeBack: "Назад",
    languageToggle: "EN"
  }
};

function updateLanguageTexts() {
  document.getElementById('landingTitle').textContent = languageStrings[currentLanguage].landingTitle;
  document.getElementById('landingText').textContent = languageStrings[currentLanguage].landingText;
  document.getElementById('homeBackBtn').textContent = languageStrings[currentLanguage].homeBack;
  document.getElementById('langToggleBtn').textContent = languageStrings[currentLanguage].languageToggle;
}

document.getElementById('langToggleBtn').addEventListener('click', function() {
  currentLanguage = currentLanguage === "en" ? "ru" : "en";
  updateLanguageTexts();
});

document.getElementById('homeBackBtn').addEventListener('click', function() {
  window.location.href = 'index.html';
});

/* ======================================
   22. Обновление отображения ников под игровым полем
====================================== */
function updateUsernamesDisplay() {
  const opponentDisplay = document.getElementById('opponentUsername');
  const playerDisplay = document.getElementById('playerUsername');
  opponentDisplay.textContent = '@' + ((opponentName && opponentName.trim() !== "") ? opponentName : 'Anonymous');
  opponentDisplay.style.color = snakeColors[opponentId] || 'lime';
  const myName = (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'You';
  playerDisplay.textContent = '@' + myName;
  playerDisplay.style.color = snakeColors[playerId] || 'lime';
  document.getElementById('usernamesDisplay').style.display = 'block';
}

/* ======================================
   23. Обновление кнопки баланса (монет)
====================================== */
function updateCoinDisplay() {
  const coinButton = document.getElementById('coinButton');
  if(window.currentUser && typeof window.currentUser.coins !== 'undefined'){
      coinButton.textContent = window.currentUser.coins + " Coins";
  } else {
      coinButton.textContent = "0 Coins";
  }
}
  </script>
</body>
</html>

