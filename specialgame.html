<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>
  
  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Your CSS (e.g., st1.css) -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* Общие стили страницы */
    body {
      margin: 0;
      padding: 0;
      background-color: #00103c;
      color: #FF00FF;
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
    }
    
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background-image: url('1.jpg');
    }
    
    /* Стили для кнопки копирования ссылки */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
    }
    #copyButton:hover {
      transform: scale(1.05);
    }
    #copyButton:active {
      animation: press 0.15s forwards;
      transform: translateY(1px) scale(1.0);
    }
    
    /* Модальное окно итогов */
    .endgame-backdrop, .modal-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .endgame-modal, .modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
    }
    
    /* Анимация мигания для поиска */
    @keyframes blink {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
    .blinking {
      animation: blink 1.2s infinite;
    }
    
    /* Стили для панели управления (если используются клавиши) */
    #controlPanel {
      width: 150px;
      height: 150px;
      margin: 20px auto;
      position: relative;
    }
    #controlPanel .control-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background: #06B6D1;
      border: none;
      border-radius: 10px;
      color: #262626;
      font-size: 24px;
      font-family: 'Press Start 2P', sans-serif;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
      transition: transform 0.1s ease;
    }
    /* Расположение кнопок (не используется, если только клавиатура) */
    #btn-up {
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }
    .control-button:hover {
      transform: scale(1.2);
    }
    .control-button:active {
      transform: translateY(1px) scale(1);
      box-shadow: 0 1px #6b6b6b;
    }
    
    /* ================
       Стили джойстика
       ================ */
    #joystick {
      position: fixed;
      width: 100px;
      height: 100px;
      margin: -50px 0 0 -50px; /* центрирование базы джойстика */
      background: rgba(100, 100, 100, 0.3);
      border: 2px solid rgba(200, 200, 200, 0.7);
      border-radius: 50%;
      display: none;
      z-index: 1000;
      touch-action: none;
    }
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      margin: -25px 0 0 -25px; /* центрирование стика */
      background: rgba(200, 200, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      touch-action: none;
    }
  </style>
</head>

<body>
  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>

  <!-- Убираем старый контейнер D-Pad -->
  <!-- <div class="dpad" id="dpad" style="display: none;">
    <button class="dpad-btn up" onclick="changeDirection('up')">↑</button>
    <button class="dpad-btn left" onclick="changeDirection('left')">←</button>
    <button class="dpad-btn down" onclick="changeDirection('down')">↓</button>
    <button class="dpad-btn right" onclick="changeDirection('right')">→</button>
  </div> -->

  <!-- Джойстик (будет появляться там, где пользователь начнет касание) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- Кнопка для копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>
  
  <!-- Модальное окно итогов -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>
  
  <!-- Модальное окно "Not enough tickets" -->
  <div id="noTicketsModal" class="modal-backdrop">
    <div class="modal">
      <h2>Not enough tickets</h2>
      <p>You do not have enough tickets to join the game.</p>
      <button onclick="returnToMain()">Return</button>
    </div>
  </div>
  
  <script>
/* 
============================================================
  Special Snake PvP – Исправленная версия с джойстиком
============================================================
*/

// Глобальные переменные для canvas и контекста
let specialGameCanvas;
let specialCtx;

// Область игры (центрированная на canvas)
const GAME_AREA_X = 50;
const GAME_AREA_Y = 50;
const GAME_AREA_WIDTH = 300;
const GAME_AREA_HEIGHT = 500;

// Настройки сетки
const gridSize = 20;
const tileCountX = GAME_AREA_WIDTH / gridSize;  
const tileCountY = GAME_AREA_HEIGHT / gridSize; 

// Идентификаторы комнаты и игроков
let roomId = null;
let playerId = null;
let opponentId = null;
let gameStateRef = null;

// Локальное состояние змейки
let localSnake = [];
let localDirection = 'right';
let score = 0;

// Состояние змейки противника
let opponentSnake = [];
let opponentScore = 0;
let opponentName = '';

// Позиция яблока
let applePos = { x: 0, y: 0 };

// Флаги игры
let isGameRunning = false;
let isGameOver = false;
let countdownValue = 5;
let showOpponentNameTimeout = null;

// Таймер (1 минута)
let timerTotal = 60;
let timerCurrent = 60;

// Интервалы
let logicTimer = null;
let countdownInterval = null;

// Цвета змейки
const snakeColors = {
  player1: '#FFFF00', // жёлтый
  player2: '#FF0000'  // красный
};

// Логический интервал (мс)
const LOGIC_INTERVAL = 150;

// Пригласительная ссылка
let inviteLink = "";

// Флаг отключения противника (авто-победа)
let opponentDisconnected = false;

/* ======================================
   1. ИНИЦИАЛИЗАЦИЯ И СБРОС
====================================== */
function initSpecialGame1() {
  specialGameCanvas = document.getElementById('specialGameCanvas');
  specialCtx = specialGameCanvas.getContext('2d');

  resetSpecialGame1();
  drawWaitingScreen();

  findOrCreateRoom();
  // Настраиваем слушатели ввода (джойстик + клавиатура)
  setupControlButtons();
}

function resetSpecialGame1() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  if (showOpponentNameTimeout) {
    clearTimeout(showOpponentNameTimeout);
    showOpponentNameTimeout = null;
  }
  roomId = null;
  playerId = null;
  opponentId = null;
  gameStateRef = null;
  localSnake = [];
  localDirection = 'right';
  score = 0;
  opponentSnake = [];
  opponentScore = 0;
  opponentName = "";
  applePos = { x: 0, y: 0 };
  isGameRunning = false;
  isGameOver = false;
  countdownValue = 5;
  timerTotal = 60;
  timerCurrent = 60;
  inviteLink = "";
  removeSwipeListeners();
  // Больше не используется D-Pad
}

/* ======================================
   2. ПОИСК / СОЗДАНИЕ КОМНАТЫ
====================================== */
function findOrCreateRoom() {
  const queueRef = firebase.database().ref('snakeQueue');

  // Сначала удаляем старую запись для этого пользователя
  queueRef.child(window.currentUser.username).remove().then(() => {
    queueRef.once('value').then((snapshot) => {
      const queueData = snapshot.val() || {};
      let openRoomKey = null;

      // Ищем комнату со статусом "waiting"
      for (const key in queueData) {
        if (key !== window.currentUser.username && queueData[key].status === 'waiting') {
          openRoomKey = key;
          break;
        }
      }
      if (openRoomKey) {
        // Присоединяемся как player2
        roomId = openRoomKey;
        playerId = 'player2';
        opponentId = 'player1';
        firebase.database().ref('snakeQueue/' + roomId)
          .update({ status: 'ready' })
          .catch((err) => console.error('Error updating room status:', err));
        setupGameReferences();
      } else {
        // Создаём новую комнату как player1
        roomId = queueRef.push().key;
        playerId = 'player1';
        opponentId = 'player2';
        queueRef.child(roomId).set({
          status: 'waiting',
          createdAt: firebase.database.ServerValue.TIMESTAMP
        }).catch((err) => console.error('Error creating room:', err));
        setupGameReferences();
      }
      // Генерируем ссылку-приглашение
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';
      waitForOpponent();
    }).catch((err) => console.error('Error reading queue:', err));
  });
}

/* ======================================
   3. ОЖИДАНИЕ ПРОТИВНИКА
====================================== */
function waitForOpponent() {
  drawSearchScreen();
  
  const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
  statusRef.on('value', async (snapshot) => {
    const currentStatus = snapshot.val();
    if (currentStatus === 'ready') {
      // Останавливаем слушание изменений статуса
      statusRef.off();
      
      // Получаем данные противника перед показом экрана
      try {
        const oppSnapshot = await firebase.database()
          .ref('snakeGames/' + roomId + '/players/' + opponentId)
          .once('value');
        const oppData = oppSnapshot.val();
        if (oppData && oppData.username) {
          opponentName = oppData.username;
        }
      } catch(e) {
        console.error("Error reading opponent data: ", e);
      }

      drawOpponentFoundScreen();
      document.getElementById('copyButton').style.display = 'none';

      showOpponentNameTimeout = setTimeout(() => {
        startCountdown();
      }, 2000);
    }
  });

  // Следим за отключением противника
  const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
  oppRef.on('value', (snapshot) => {
    const oppData = snapshot.val();
    if (oppData) {
      opponentSnake = oppData.snake || [];
      opponentScore = oppData.score || 0;
      opponentName  = oppData.username || "";
    } else {
      if (isGameRunning) {
        opponentDisconnected = true;
        setGameOver();
      }
    }
  });
}

/* ======================================
   4. НАСТРОЙКА gameStateRef + СЛУШАТЕЛИ
====================================== */
function setupGameReferences() {
  gameStateRef = firebase.database().ref('snakeGames/' + roomId);
  const playerRef = gameStateRef.child('players').child(playerId);

  playerRef.once('value').then((snapshot) => {
    if (!snapshot.exists()) {
      let startX, startY;
      if (playerId === 'player1') {
        startX = 3;
        startY = Math.floor(tileCountY / 2);
      } else {
        startX = tileCountX - 4;
        startY = Math.floor(tileCountY / 2);
      }
      const initialSnake = [
        { x: startX,     y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];
      playerRef.set({
        snake: initialSnake,
        direction: 'right',
        score: 0,
        username: window.currentUser ? window.currentUser.username : 'Unknown'
      }).catch((err) => console.error('Error initializing player data:', err));

      playerRef.onDisconnect().remove()
        .then(() => console.log("onDisconnect set for player:", playerId))
        .catch((err) => console.error("Error setting onDisconnect:", err));
    }
  });

  gameStateRef.child('apple').on('value', (snapshot) => {
    const aData = snapshot.val() || {};
    if (typeof aData.x === 'number' && typeof aData.y === 'number') {
      applePos.x = aData.x;
      applePos.y = aData.y;
    }
  });

  gameStateRef.child('gameOver').on('value', (snapshot) => {
    if (snapshot.val() === true && !isGameOver) {
      isGameOver = true;
      endGame();
    }
  });
}

/* ======================================
   5. ОБРАТНЫЙ ОТСЧЁТ (5...1) И СТАРТ ИГРЫ
====================================== */
function startCountdown() {
  countdownValue = 5;
  countdownInterval = setInterval(() => {
    drawCountdownScreen(countdownValue);
    countdownValue--;
    if (countdownValue < 1) {
      clearInterval(countdownInterval);
      launchGame();
    }
  }, 1000);
}

function launchGame() {
  isGameRunning = true;
  isGameOver = false;
  // При запуске игры теперь используется джойстик (D-Pad больше не показывается)

  gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
    const data = snapshot.val();
    if (data && data.snake) {
      localSnake = data.snake;
    }
    localDirection = (data && data.direction) ? data.direction : 'right';
    score = (data && data.score) ? data.score : 0;

    gameStateRef.child('apple').once('value').then((appleSnap) => {
      if (!appleSnap.exists()) {
        spawnApple();
      }
    });

    addSwipeListeners();
    startLogicLoop();
    startTimer();
    requestAnimationFrame(renderLoop);
  });
}

/* ======================================
   6. ЛОГИКА ИГРЫ И РЕНДЕР
====================================== */
function startLogicLoop() {
  logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
}

function stopLogicLoop() {
  if (logicTimer) {
    clearInterval(logicTimer);
    logicTimer = null;
  }
}

function gameLogicUpdate() {
  if (!isGameRunning || isGameOver) return;

  moveLocalSnake();

  if (checkSelfCollision()) {
    setGameOver();
    return;
  }

  const head = localSnake[0];
  if (head.x === applePos.x && head.y === applePos.y) {
    score++;
    updatePlayerState(true);
    spawnApple();
  } else {
    updatePlayerState(false);
  }
}

function renderLoop() {
  renderGame();
  if (!isGameOver) {
    requestAnimationFrame(renderLoop);
  }
}

/* ======================================
   7. ДВИЖЕНИЕ И СТОЛКНОВЕНИЯ
====================================== */
function moveLocalSnake() {
  const head = { ...localSnake[0] };
  switch (localDirection) {
    case 'left':  head.x--; break;
    case 'right': head.x++; break;
    case 'up':    head.y--; break;
    case 'down':  head.y++; break;
  }
  // Обход границ
  if (head.x < 0) head.x = tileCountX - 1;
  if (head.x >= tileCountX) head.x = 0;
  if (head.y < 0) head.y = tileCountY - 1;
  if (head.y >= tileCountY) head.y = 0;
  localSnake.unshift(head);
  localSnake.pop();
}

function checkSelfCollision() {
  return false;
}

/* ======================================
   8. ОБНОВЛЕНИЕ СОСТОЯНИЯ В FIREBASE
====================================== */
function updatePlayerState(ateApple) {
  if (ateApple) {
    const lastSegment = localSnake[localSnake.length - 1];
    localSnake.push({ ...lastSegment });
  }
  gameStateRef.child('players').child(playerId).update({
    snake: localSnake,
    direction: localDirection,
    score: score
  }).catch((err) => console.error('Error updating player state:', err));
}

function spawnApple() {
  const newApple = {
    x: Math.floor(Math.random() * tileCountX),
    y: Math.floor(Math.random() * tileCountY)
  };
  gameStateRef.child('apple').set(newApple)
    .catch((err) => console.error('Error setting apple:', err));
}

/* ======================================
   9. КОНЕЦ ИГРЫ
====================================== */
function setGameOver() {
  isGameOver = true;
  gameStateRef.update({ gameOver: true })
    .catch((err) => console.error('Error setting gameOver:', err));
  endGame();
}

function endGame() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  let resultTitle = 'Game Over';
  if (opponentDisconnected) {
    resultTitle = 'Opponent Disconnected. You Win!';
  } else {
    if (score > opponentScore) {
      resultTitle = 'You Win!';
    } else if (score < opponentScore) {
      resultTitle = 'You Lose...';
    } else {
      resultTitle = 'Draw';
    }
  }

  const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
  showEndGameModal(resultTitle, msg);
  cleanupRoom();
}

/* ======================================
   10. ТАЙМЕР (1 минута)
====================================== */
function startTimer() {
  timerCurrent = timerTotal;
  const timerInterval = setInterval(() => {
    if (!isGameRunning || isGameOver) {
      clearInterval(timerInterval);
      return;
    }
    timerCurrent--;
    if (timerCurrent <= 0) {
      setGameOver();
      clearInterval(timerInterval);
    }
  }, 1000);
}

/* ======================================
   11. РЕНДЕР ИГРЫ
====================================== */
function renderGame() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  drawMatrixGrid();

  // Рисуем яблоко
  let appleImg = new Image();
  appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
  if (appleImg.complete) {
    specialCtx.drawImage(
      appleImg,
      GAME_AREA_X + applePos.x * gridSize,
      GAME_AREA_Y + applePos.y * gridSize,
      gridSize,
      gridSize
    );
  }

  // Рисуем локальную змейку
  specialCtx.fillStyle = snakeColors[playerId] || '#800080';
  localSnake.forEach(seg => {
    specialCtx.fillRect(
      GAME_AREA_X + seg.x * gridSize,
      GAME_AREA_Y + seg.y * gridSize,
      gridSize,
      gridSize
    );
  });

  // Рисуем змейку противника
  specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
  opponentSnake.forEach(seg => {
    specialCtx.fillRect(
      GAME_AREA_X + seg.x * gridSize,
      GAME_AREA_Y + seg.y * gridSize,
      gridSize,
      gridSize
    );
  });

  // Имя противника над головой
  if (opponentSnake.length > 0) {
    const oppHead = opponentSnake[0];
    specialCtx.fillStyle = '#FFF';
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    specialCtx.fillText(
      opponentName ? ('@' + opponentName) : '@Anonymous',
      GAME_AREA_X + oppHead.x * gridSize,
      GAME_AREA_Y + oppHead.y * gridSize - 5
    );
  }

  // Имя игрока над головой
  if (localSnake.length > 0) {
    const myHead = localSnake[0];
    specialCtx.fillStyle = '#FFF';
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    const myName = window.currentUser ? window.currentUser.username : 'You';
    specialCtx.fillText(
      '@' + myName,
      GAME_AREA_X + myHead.x * gridSize,
      GAME_AREA_Y + myHead.y * gridSize - 5
    );
  }

  // Счёт
  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '12px "Press Start 2P", sans-serif';
  specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
  specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);

  // Таймер (в виде полоски)
  const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
  specialCtx.fillStyle = '#FF00FF';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
}

function drawMatrixGrid() {
  specialCtx.fillStyle = '#433171';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

  specialCtx.strokeStyle = '#00103c';
  for (let i = 0; i <= tileCountX; i++) {
    let x = GAME_AREA_X + i * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(x, GAME_AREA_Y);
    specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
    specialCtx.stroke();
  }
  for (let j = 0; j <= tileCountY; j++) {
    let y = GAME_AREA_Y + j * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(GAME_AREA_X, y);
    specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
    specialCtx.stroke();
  }
  specialCtx.strokeStyle = '#8F509D';
  specialCtx.lineWidth = 2;
  specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
}

/* ======================================
   12. ЭКРАНЫ: "SEARCHING / WAITING..."
====================================== */
function drawSearchScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '15px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(
    'Searching for opponent...',
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
  specialCtx.font = '10px "Press Start 2P", sans-serif';
  specialCtx.fillText(
    ' ',
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2 + 40
  );

  specialCtx.save();
  specialCtx.globalAlpha = 0;
  specialCtx.fillText(
    inviteLink,
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2 + 60
  );
  specialCtx.restore();

  specialCtx.font = '8px "Press Start 2P", sans-serif';
  specialCtx.fillText(
    ' ',
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2 + 80
  );

  document.getElementById('copyButton').style.display = 'block';
}

function drawWaitingScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#000';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
}

function drawOpponentFoundScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '16px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  const displayName = opponentName ? opponentName : "Anonymous";
  specialCtx.fillText(
    'Opponent: @' + displayName,
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
}

function drawCountdownScreen(value) {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '60px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(
    value.toString(),
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
}

/* ======================================
   13. ОБРАБОТКА ВВОДА: ДЖОЙСТИК + КЛАВИАТУРА
====================================== */
function addSwipeListeners() {
  // Обработчик для клавиатуры (для десктопа)
  function onKeyDown(e) {
    switch (e.key) {
      case 'ArrowLeft':
        if (localDirection !== 'right') localDirection = 'left';
        break;
      case 'ArrowRight':
        if (localDirection !== 'left') localDirection = 'right';
        break;
      case 'ArrowUp':
        if (localDirection !== 'down') localDirection = 'up';
        break;
      case 'ArrowDown':
        if (localDirection !== 'up') localDirection = 'down';
        break;
    }
  }
  window.addEventListener('keydown', onKeyDown);
  window.__joystick_keydown = onKeyDown;
  
  // Для мобильных устройств — джойстик, который появляется там, где начинается касание
  const canvas = specialGameCanvas;
  const joystick = document.getElementById('joystick');
  const joystickStick = document.getElementById('joystick-stick');
  let joystickActive = false;
  let joystickCenter = { x: 0, y: 0 };
  const maxDistance = 40;
  
  function handleTouchStart(e) {
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      joystickCenter.x = touch.clientX;
      joystickCenter.y = touch.clientY;
      joystick.style.left = joystickCenter.x + 'px';
      joystick.style.top = joystickCenter.y + 'px';
      joystick.style.display = 'block';
      joystickStick.style.transform = 'translate(0px, 0px)';
      joystickActive = true;
      e.preventDefault();
    }
  }
  
  function handleTouchMove(e) {
    if (!joystickActive) return;
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      let dx = touch.clientX - joystickCenter.x;
      let dy = touch.clientY - joystickCenter.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDistance;
        dy = Math.sin(angle) * maxDistance;
      }
      joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
      // Определяем направление по наибольшему смещению
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && localDirection !== 'left') {
          localDirection = 'right';
        } else if (dx < 0 && localDirection !== 'right') {
          localDirection = 'left';
        }
      } else {
        if (dy > 0 && localDirection !== 'up') {
          localDirection = 'down';
        } else if (dy < 0 && localDirection !== 'down') {
          localDirection = 'up';
        }
      }
      e.preventDefault();
    }
  }
  
  function handleTouchEnd(e) {
    joystickActive = false;
    joystick.style.display = 'none';
    e.preventDefault();
  }
  
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
  
  window.__joystick_touchstart = handleTouchStart;
  window.__joystick_touchmove = handleTouchMove;
  window.__joystick_touchend = handleTouchEnd;
}

function removeSwipeListeners() {
  if (!specialGameCanvas) return;
  specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
  specialGameCanvas.removeEventListener('touchmove', window.__joystick_touchmove);
  specialGameCanvas.removeEventListener('touchend', window.__joystick_touchend);
  window.removeEventListener('keydown', window.__joystick_keydown);
  window.__joystick_touchstart = null;
  window.__joystick_touchmove = null;
  window.__joystick_touchend = null;
  window.__joystick_keydown = null;
}

/* ======================================
   14. КОПИРОВАНИЕ ССЫЛКИ
====================================== */
function copyInviteLink() {
  if (!inviteLink) return;
  navigator.clipboard.writeText(inviteLink)
    .then(() => { console.log("Invite link copied:", inviteLink); })
    .catch(err => console.error("Error copying invite link:", err));
}

/* ======================================
   15. МОДАЛЬНОЕ ОКНО КОНЦА ИГРЫ
====================================== */
function showEndGameModal(title, message) {
  const modal = document.getElementById('endgameBackdrop');
  const titleEl = document.getElementById('endgameTitle');
  const msgEl = document.getElementById('endgameMessage');
  titleEl.textContent = title;
  msgEl.textContent = message;
  modal.classList.add('active');
}

/* ======================================
   16. НАСТРОЙКА КНОПОК УПРАВЛЕНИЯ (ДЛЯ КЛАВИАТУРЫ)
====================================== */
function setupControlButtons() {
  const buttons = document.querySelectorAll('.control-button');
  buttons.forEach(button => {
    button.addEventListener('click', () => {
      const newDirection = button.getAttribute('data-direction');
      if ((localDirection === 'left'  && newDirection === 'right') ||
          (localDirection === 'right' && newDirection === 'left')  ||
          (localDirection === 'up'    && newDirection === 'down')  ||
          (localDirection === 'down'  && newDirection === 'up')) {
        return;
      }
      localDirection = newDirection;
    });
  });
}

/* ======================================
   17. УБОРКА КОМНАТЫ ПОСЛЕ ИГРЫ
====================================== */
function cleanupRoom() {
  if (roomId) {
    firebase.database().ref('snakeGames/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeGames."))
      .catch((err) => console.error("Error removing game room:", err));

    firebase.database().ref('snakeQueue/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeQueue."))
      .catch((err) => console.error("Error removing room from snakeQueue:", err));
  }
}

window.addEventListener('beforeunload', function() {
  if (roomId && gameStateRef) {
    gameStateRef.child('players').child(playerId).remove();
  }
});

/* ======================================
   18. ФИНИШ ИГРЫ И ВОЗВРАТ В МЕНЮ
====================================== */
function finishGame() {
  document.getElementById('endgameBackdrop').classList.remove('active');
  window.location.href = 'index.html';
}
function returnToMain() {
  document.getElementById('noTicketsModal').classList.remove('active');
  window.location.href = 'index.html';
}

/* ======================================
   19. ЗАПУСК ИГРЫ ПРИ ЗАГРУЗКЕ СТРАНИЦЫ
====================================== */
window.addEventListener('load', () => {
  const firebaseConfig = {
    apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
    authDomain: "test-with-likes.firebaseapp.com",
    databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
    projectId: "test-with-likes",
    storageBucket: "test-with-likes.appspot.com",
    messagingSenderId: "764738820142",
    appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
    measurementId: "G-WJNF0HSN9P"
  };
  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
  }

  if (!window.currentUser) {
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      const tgUser = Telegram.WebApp.initDataUnsafe.user;
      window.currentUser = {
        username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
        photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
      };
    } else {
      window.currentUser = {
        username: "TestUser",
        photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
      };
    }
  }

  initSpecialGame1();
});

function changeDirection(newDir) {
  if (
    (newDir === 'up'    && localDirection === 'down') ||
    (newDir === 'down'  && localDirection === 'up')   ||
    (newDir === 'left'  && localDirection === 'right')||
    (newDir === 'right' && localDirection === 'left')
  ) {
    return;
  }
  localDirection = newDir;
}
  </script>
</body>
</html>
