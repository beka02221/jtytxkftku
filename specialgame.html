<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" 
        content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>
  
  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Your CSS (e.g., st1.css) -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* Общие стили страницы */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0f0;
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
    }
    /* Canvas занимает всю страницу */
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
    /* Кнопка для копирования inviteLink */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background-color: #222;
      border: 2px solid #0f0;
      color: #0f0;
      cursor: pointer;
      border-radius: 8px;
      z-index: 1000;
      display: none;
      transition: background-color 0.3s;
    }
    #copyButton:hover {
      background-color: #333;
    }
    /* Модальное окно итогов */
    .endgame-backdrop, .modal-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .endgame-modal, .modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
    }
    /* Анимация мигания для поиска */
    @keyframes blink {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
    .blinking {
      animation: blink 1.2s infinite;
    }
  </style>
</head>
<body>
  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>
  
  <!-- Кнопка для копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>
  
  <!-- Модальное окно итогов -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>
  
  <!-- Модальное окно "Not enough tickets" -->
  <div id="noTicketsModal" class="modal-backdrop">
    <div class="modal">
      <h2>Not enough tickets</h2>
      <p>You do not have enough tickets to join the game.</p>
      <button onclick="returnToMain()">Return</button>
    </div>
  </div>
  
  <script>
    /* ============================================================
       Special Snake PvP – Optimized Version
       Изменения:
         - После нахождения реального соперника показываются его реальные данные:
             * Имя (username)
             * Фото профиля
         - Затем начинается обратный отсчёт до игры.
         - Во время игры над змеями отображаются реальные юзернеймы.
       ============================================================ */
    
    let specialGameCanvas;
    let specialCtx;
    
    // Game area (centered on canvas)
    const GAME_AREA_X = 50;
    const GAME_AREA_Y = 175;
    const GAME_AREA_WIDTH = 300;
    const GAME_AREA_HEIGHT = 500;
    
    // Grid settings
    const gridSize = 20;
    const tileCountX = GAME_AREA_WIDTH / gridSize;  
    const tileCountY = GAME_AREA_HEIGHT / gridSize; 
    
    // Room and player IDs
    let roomId = null;
    let playerId = null;
    let opponentId = null;
    let gameStateRef = null;
    
    // Local snake state
    let localSnake = [];
    let localDirection = 'right';
    let score = 0;
    
    // Opponent snake state and data
    let opponentSnake = [];
    let opponentScore = 0;
    let opponentName = 'Opponent';
    let opponentPhotoUrl = '';  // Новый параметр для фото профиля соперника
    
    // Apple position
    let applePos = { x: 0, y: 0 };
    
    // Game flags
    let isGameRunning = false;
    let isGameOver = false;
    let countdownValue = 5;
    let showOpponentNameTimeout = null;
    
    // Timer (1 minute)
    let timerTotal = 60;
    let timerCurrent = 60;
    
    // Intervals
    let logicTimer = null;
    let countdownInterval = null;
    
    // Snake colors: player1 - purple, player2 - yellow
    const snakeColors = {
      player1: '#800080',
      player2: '#FFFF00'
    };
    
    // Logic interval (150 ms)
    const LOGIC_INTERVAL = 150;
    
    // Invite link (to be formed)
    let inviteLink = "";
    
    /* ======================================
       1. INITIALIZATION & RESET
    ====================================== */
    function initSpecialGame1() {
      specialGameCanvas = document.getElementById('specialGameCanvas');
      specialCtx = specialGameCanvas.getContext('2d');
    
      resetSpecialGame1();
      drawWaitingScreen();
    
      findOrCreateRoom();
    
      // Set up disconnect handler so that if you disconnect, your entry is removed.
      // (This helps prevent self-matching on re-entry.)
      // Note: This will be set after roomId and playerId are assigned.
    }
    
    function resetSpecialGame1() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      if (showOpponentNameTimeout) {
        clearTimeout(showOpponentNameTimeout);
        showOpponentNameTimeout = null;
      }
      roomId = null;
      playerId = null;
      opponentId = null;
      gameStateRef = null;
      localSnake = [];
      localDirection = 'right';
      score = 0;
      opponentSnake = [];
      opponentScore = 0;
      opponentName = 'Opponent';
      opponentPhotoUrl = '';
      applePos = { x: 0, y: 0 };
      isGameRunning = false;
      isGameOver = false;
      countdownValue = 5;
      timerTotal = 60;
      timerCurrent = 60;
      inviteLink = "";
      removeSwipeListeners();
    }
    
    /* ======================================
       2. ROOM SEARCH / CREATION
       (Prevents self-matching on refresh)
    ====================================== */
    function findOrCreateRoom() {
      const queueRef = firebase.database().ref('snakeQueue');
      // Remove any previous entry for current user
      queueRef.child(currentUser.username).remove().then(() => {
        queueRef.once('value').then((snapshot) => {
          const queueData = snapshot.val() || {};
          let openRoomKey = null;
          for (const key in queueData) {
            if (key !== currentUser.username && queueData[key].status === 'waiting') {
              openRoomKey = key;
              break;
            }
          }
          if (openRoomKey) {
            // Join as player2
            roomId = openRoomKey;
            playerId = 'player2';
            opponentId = 'player1';
            firebase.database().ref('snakeQueue/' + roomId)
              .update({ status: 'ready' })
              .catch((err) => console.error('Error updating room status:', err));
            setupGameReferences();
          } else {
            // Create new room as player1
            roomId = queueRef.push().key;
            playerId = 'player1';
            opponentId = 'player2';
            queueRef.child(roomId).set({
              status: 'waiting',
              createdAt: firebase.database.ServerValue.TIMESTAMP
            }).catch((err) => console.error('Error creating room:', err));
            setupGameReferences();
          }
          // Form invite link (replace with your real address)
          inviteLink = "https://mygame.example.com/invite?room=" + roomId;
          // Show copy button
          document.getElementById('copyButton').style.display = 'block';
          waitForOpponent();
        }).catch((err) => console.error('Error reading queue:', err));
      });
    }
    
    function waitForOpponent() {
      drawSearchScreen();
      const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
      statusRef.on('value', (snapshot) => {
        const currentStatus = snapshot.val();
        if (currentStatus === 'ready') {
          statusRef.off();
          drawOpponentFoundScreen();
          document.getElementById('copyButton').style.display = 'none';
          showOpponentNameTimeout = setTimeout(() => {
            startCountdown();
          }, 2000);
        }
      });
      // Listen for opponent disconnect:
      const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
      oppRef.on('value', (snapshot) => {
        if (!snapshot.exists() && isGameRunning) {
          // Opponent left – end the game immediately
          setGameOver();
        }
      });
    }
    
    /* ======================================
       3. SETUP gameStateRef and listeners
    ====================================== */
    function setupGameReferences() {
      gameStateRef = firebase.database().ref('snakeGames/' + roomId);
      const playerRef = gameStateRef.child('players').child(playerId);
      playerRef.once('value').then((snapshot) => {
        if (!snapshot.exists()) {
          let startX, startY;
          if (playerId === 'player1') {
            startX = 3;
            startY = Math.floor(tileCountY / 2);
          } else {
            startX = tileCountX - 4;
            startY = Math.floor(tileCountY / 2);
          }
          const initialSnake = [
            { x: startX, y: startY },
            { x: startX-1, y: startY },
            { x: startX-2, y: startY }
          ];
          // Сохраняем также photo_url для отображения профиля
          playerRef.set({
            snake: initialSnake,
            direction: 'right',
            score: 0,
            username: window.currentUser ? window.currentUser.username : 'Unknown',
            photo_url: window.currentUser ? window.currentUser.photo_url : ''
          }).catch((err) => console.error('Error initializing player data:', err));
        }
      });
      const oppRef = gameStateRef.child('players').child(opponentId);
      oppRef.on('value', (snapshot) => {
        if (!snapshot.exists() && isGameRunning) {
          // Opponent disconnected – end game
          setGameOver();
          return;
        }
        const oppData = snapshot.val() || {};
        opponentSnake = oppData.snake || [];
        opponentScore = oppData.score || 0;
        opponentName  = oppData.username || 'Opponent';
        opponentPhotoUrl = oppData.photo_url || '';
      });
      gameStateRef.child('apple').on('value', (snapshot) => {
        const aData = snapshot.val() || {};
        if (typeof aData.x === 'number' && typeof aData.y === 'number') {
          applePos.x = aData.x;
          applePos.y = aData.y;
        }
      });
      gameStateRef.child('gameOver').on('value', (snapshot) => {
        if (snapshot.val() === true && !isGameOver) {
          isGameOver = true;
          endGame();
        }
      });
    }
    
    /* ======================================
       4. COUNTDOWN (5...1) and start game
    ====================================== */
    function startCountdown() {
      countdownValue = 5;
      countdownInterval = setInterval(() => {
        drawCountdownScreen(countdownValue);
        countdownValue--;
        if (countdownValue < 1) {
          clearInterval(countdownInterval);
          launchGame();
        }
      }, 1000);
    }
    
    function launchGame() {
      isGameRunning = true;
      isGameOver = false;
      gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
        const data = snapshot.val();
        if (data && data.snake) {
          localSnake = data.snake;
        }
        localDirection = (data && data.direction) ? data.direction : 'right';
        score = (data && data.score) ? data.score : 0;
        gameStateRef.child('apple').once('value').then((appleSnap) => {
          if (!appleSnap.exists()) {
            spawnApple();
          }
        });
        addSwipeListeners();
        startLogicLoop();
        startTimer();
        requestAnimationFrame(renderLoop);
      });
    }
    
    /* ======================================
       5. GAME LOGIC and RENDER
    ====================================== */
    function startLogicLoop() {
      logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
    }
    
    function stopLogicLoop() {
      if (logicTimer) {
        clearInterval(logicTimer);
        logicTimer = null;
      }
    }
    
    function gameLogicUpdate() {
      if (!isGameRunning || isGameOver) return;
      
      moveLocalSnake();
      
      // Only self-collision ends the game.
      if (checkSelfCollision()) {
        setGameOver();
        return;
      }
      
      // Check apple collision
      const head = localSnake[0];
      if (head.x === applePos.x && head.y === applePos.y) {
        score++;
        updatePlayerState(true);
        spawnApple();
      } else {
        updatePlayerState(false);
      }
    }
    
    function renderLoop() {
      renderGame();
      if (!isGameOver) {
        requestAnimationFrame(renderLoop);
      }
    }
    
    /* ======================================
       6. MOVEMENT AND COLLISIONS
    ====================================== */
    function moveLocalSnake() {
      const head = { ...localSnake[0] };
      switch (localDirection) {
        case 'left':  head.x--; break;
        case 'right': head.x++; break;
        case 'up':    head.y--; break;
        case 'down':  head.y++; break;
      }
      // Wrap around the grid
      if (head.x < 0) head.x = tileCountX - 1;
      if (head.x >= tileCountX) head.x = 0;
      if (head.y < 0) head.y = tileCountY - 1;
      if (head.y >= tileCountY) head.y = 0;
      localSnake.unshift(head);
      localSnake.pop();
    }
    
    function checkSelfCollision() {
      const head = localSnake[0];
      for (let i = 1; i < localSnake.length; i++) {
        if (localSnake[i].x === head.x && localSnake[i].y === head.y) {
          return true;
        }
      }
      return false;
    }
    
    /* ======================================
       7. UPDATE STATE IN FIREBASE
    ====================================== */
    function updatePlayerState(ateApple) {
      if (ateApple) {
        const lastSegment = localSnake[localSnake.length - 1];
        localSnake.push({ ...lastSegment });
      }
      gameStateRef.child('players').child(playerId).update({
        snake: localSnake,
        direction: localDirection,
        score: score
      }).catch((err) => console.error('Error updating player state:', err));
    }
    
    function spawnApple() {
      const newApple = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY)
      };
      gameStateRef.child('apple').set(newApple)
        .catch((err) => console.error('Error setting apple:', err));
    }
    
    /* ======================================
       8. GAME OVER
    ====================================== */
    function setGameOver() {
      isGameOver = true;
      gameStateRef.update({ gameOver: true })
        .catch((err) => console.error('Error setting gameOver:', err));
      endGame();
    }
    
    function endGame() {
      stopLogicLoop();
      clearInterval(countdownInterval);
      let resultTitle = 'Game Over';
      if (score > opponentScore) {
        resultTitle = 'You Win!';
      } else if (score < opponentScore) {
        resultTitle = 'You Lose...';
      } else {
        resultTitle = 'Draw';
      }
      const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
      showEndGameModal(resultTitle, msg);
    }
    
    /* ======================================
       9. TIMER (1 minute)
    ====================================== */
    function startTimer() {
      timerCurrent = timerTotal;
      const timerInterval = setInterval(() => {
        if (!isGameRunning || isGameOver) {
          clearInterval(timerInterval);
          return;
        }
        timerCurrent--;
        if (timerCurrent <= 0) {
          setGameOver();
          clearInterval(timerInterval);
        }
      }, 1000);
    }
    
    /* ======================================
       10. RENDER GAME
    ====================================== */
    function renderGame() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = 'rgba(0,0,0,0.8)';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      
      drawMatrixGrid();
      
      // Draw apple (red)
      specialCtx.fillStyle = '#FF0000';
      specialCtx.fillRect(
        GAME_AREA_X + applePos.x * gridSize,
        GAME_AREA_Y + applePos.y * gridSize,
        gridSize,
        gridSize
      );
      
      // Draw our snake
      specialCtx.fillStyle = snakeColors[playerId] || '#800080';
      localSnake.forEach(seg => {
        specialCtx.fillRect(
          GAME_AREA_X + seg.x * gridSize,
          GAME_AREA_Y + seg.y * gridSize,
          gridSize,
          gridSize
        );
      });
      
      // Draw opponent snake
      specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
      opponentSnake.forEach(seg => {
        specialCtx.fillRect(
          GAME_AREA_X + seg.x * gridSize,
          GAME_AREA_Y + seg.y * gridSize,
          gridSize,
          gridSize
        );
      });
      
      // Draw opponent name above head
      if (opponentSnake.length > 0) {
        const oppHead = opponentSnake[0];
        specialCtx.fillStyle = '#00FF00';
        specialCtx.font = '12px "Press Start 2P", sans-serif';
        specialCtx.fillText(
          opponentName,
          GAME_AREA_X + oppHead.x * gridSize,
          GAME_AREA_Y + oppHead.y * gridSize - 5
        );
      }
      
      // Draw our name above head
      if (localSnake.length > 0) {
        const myHead = localSnake[0];
        specialCtx.fillStyle = '#00FF00';
        specialCtx.font = '12px "Press Start 2P", sans-serif';
        const myName = window.currentUser ? window.currentUser.username : 'You';
        specialCtx.fillText(
          myName,
          GAME_AREA_X + myHead.x * gridSize,
          GAME_AREA_Y + myHead.y * gridSize - 5
        );
      }
      
      // Draw scores (top right of game area)
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '12px "Press Start 2P", sans-serif';
      specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 100, GAME_AREA_Y + 15);
      specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 100, GAME_AREA_Y + 30);
      
      // Draw timer bar at top of game area
      const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
      specialCtx.fillStyle = '#00FF00';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
    }
    
    function drawMatrixGrid() {
      specialCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
      
      specialCtx.strokeStyle = 'rgba(0,255,0,0.3)';
      for (let i = 0; i <= tileCountX; i++) {
        let x = GAME_AREA_X + i * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(x, GAME_AREA_Y);
        specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
        specialCtx.stroke();
      }
      for (let j = 0; j <= tileCountY; j++) {
        let y = GAME_AREA_Y + j * gridSize;
        specialCtx.beginPath();
        specialCtx.moveTo(GAME_AREA_X, y);
        specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
        specialCtx.stroke();
      }
      specialCtx.strokeStyle = 'rgb(0,255,0)';
      specialCtx.lineWidth = 2;
      specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
    }
    
    /* ======================================
       11. SCREENS: "SEARCHING / WAITING..."
    ====================================== */
    function drawSearchScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      // Blinking search text
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '16px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(
        'Searching for opponent...',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2
      );
      specialCtx.font = '10px "Press Start 2P", sans-serif';
      specialCtx.fillText(
        'Invite a friend:',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2 + 40
      );
      specialCtx.fillText(
        inviteLink,
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2 + 60
      );
      specialCtx.font = '8px "Press Start 2P", sans-serif';
      specialCtx.fillText(
        'Click to copy',
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2 + 80
      );
      // Show copy button
      document.getElementById('copyButton').style.display = 'block';
    }
    
    function drawWaitingScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
    }
    
    // Отображает экран с данными найденного соперника (его имя и фото профиля)
    function drawOpponentFoundScreen() {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '16px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(
        'Opponent found',
        specialGameCanvas.width / 2,
        100
      );
      specialCtx.fillText(
        opponentName,
        specialGameCanvas.width / 2,
        150
      );
      // Если у соперника есть фото, выводим его
      if(opponentPhotoUrl) {
        let img = new Image();
        img.onload = function() {
          // Рисуем фото по центру (размер 100x100)
          specialCtx.drawImage(img, specialGameCanvas.width/2 - 50, 180, 100, 100);
        };
        img.src = opponentPhotoUrl;
      }
    }
    
    /* ======================================
       12. COUNTDOWN (5...1)
    ====================================== */
    function drawCountdownScreen(value) {
      specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#000';
      specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
      specialCtx.fillStyle = '#00FF00';
      specialCtx.font = '48px "Press Start 2P", sans-serif';
      specialCtx.textAlign = 'center';
      specialCtx.fillText(
        value.toString(),
        specialGameCanvas.width / 2,
        specialGameCanvas.height / 2
      );
    }
    
    /* ======================================
       13. INPUT HANDLING (SWIPE + KEYS)
    ====================================== */
    function addSwipeListeners() {
      let touchStartX = null;
      let touchStartY = null;
      function onTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
      function onTouchMove(e) {
        e.preventDefault();
      }
      function onTouchEnd(e) {
        if (!touchStartX || !touchStartY) return;
        const touch = e.changedTouches[0];
        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0 && localDirection !== 'left') {
            localDirection = 'right';
          } else if (dx < 0 && localDirection !== 'right') {
            localDirection = 'left';
          }
        } else {
          if (dy > 0 && localDirection !== 'up') {
            localDirection = 'down';
          } else if (dy < 0 && localDirection !== 'down') {
            localDirection = 'up';
          }
        }
        touchStartX = null;
        touchStartY = null;
      }
      specialGameCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
      specialGameCanvas.addEventListener('touchmove', onTouchMove, { passive: false });
      specialGameCanvas.addEventListener('touchend', onTouchEnd, { passive: false });
      function onKeyDown(e) {
        switch (e.key) {
          case 'ArrowLeft':
            if (localDirection !== 'right') localDirection = 'left';
            break;
          case 'ArrowRight':
            if (localDirection !== 'left') localDirection = 'right';
            break;
          case 'ArrowUp':
            if (localDirection !== 'down') localDirection = 'up';
            break;
          case 'ArrowDown':
            if (localDirection !== 'up') localDirection = 'down';
            break;
        }
      }
      window.addEventListener('keydown', onKeyDown);
      window.__special_onKeyDown = onKeyDown;
      window.__special_onTouchStart = onTouchStart;
      window.__special_onTouchMove = onTouchMove;
      window.__special_onTouchEnd = onTouchEnd;
    }
    
    function removeSwipeListeners() {
      if (!specialGameCanvas) return;
      specialGameCanvas.removeEventListener('touchstart', window.__special_onTouchStart);
      specialGameCanvas.removeEventListener('touchmove', window.__special_onTouchMove);
      specialGameCanvas.removeEventListener('touchend', window.__special_onTouchEnd);
      window.removeEventListener('keydown', window.__special_onKeyDown);
      window.__special_onTouchStart = null;
      window.__special_onTouchMove = null;
      window.__special_onTouchEnd = null;
      window.__special_onKeyDown = null;
    }
    
    /* ======================================
       14. COPY INVITE LINK
    ====================================== */
    function copyInviteLink() {
      if (!inviteLink) return;
      navigator.clipboard.writeText(inviteLink)
        .then(() => { console.log("Invite link copied:", inviteLink); })
        .catch(err => console.error("Error copying invite link:", err));
    }
    
    /* ======================================
       15. END GAME MODAL
    ====================================== */
    function showEndGameModal(title, message) {
      const modal = document.getElementById('endgameBackdrop');
      const titleEl = document.getElementById('endgameTitle');
      const msgEl = document.getElementById('endgameMessage');
      titleEl.textContent = title;
      msgEl.textContent = message;
      modal.classList.add('active');
    }
    
    /* ============================================================
       End of game code.
       Call initSpecialGame1() below.
    ============================================================ */
  </script>
  
  <script>
    // Functions to finish game and return to main page
    function finishGame() {
      document.getElementById('endgameBackdrop').classList.remove('active');
      window.location.href = 'index.html';
    }
    function returnToMain() {
      document.getElementById('noTicketsModal').classList.remove('active');
      window.location.href = 'index.html';
    }
    
    // Initialize game after page load and Firebase setup
    window.addEventListener('load', () => {
      // Firebase configuration – replace with your actual config values
      const firebaseConfig = {
        apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
        authDomain: "test-with-likes.firebaseapp.com",
        databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
        projectId: "test-with-likes",
        storageBucket: "test-with-likes.appspot.com",
        messagingSenderId: "764738820142",
        appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
        measurementId: "G-WJNF0HSN9P"
      };
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      
      // Ensure window.currentUser is set.
      if (!window.currentUser) {
        // For testing outside Telegram:
        window.currentUser = {
          username: "TestUser",
          photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
        };
      }
      
      initSpecialGame1();
    });
  </script>
</body>
</html>

