
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Special Snake PvP</title>

  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <!-- Ваш CSS -->
  <link id="themeStylesheet" rel="stylesheet" href="st1.css">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* Общие стили */
    body {
      margin: 0;
      padding: 0;
      background: #00103c;
      color: #FF00FF;
      font-family: 'Press Start 2P', sans-serif;
      position: relative;
      overflow: hidden;
    }

    /* Кнопка баланса (всегда наверху) */
    #balanceButton {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 16px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      z-index: 2000;
    }
    #balanceButton img {
      vertical-align: middle;
      margin-right: 6px;
    }

    /* Canvas для игры */
    #specialGameCanvas {
      display: block;
      margin: 0 auto;
      background-image: url('1.jpg'); /* пример */
    }

    /* Элемент с никами */
    #usernamesDisplay {
      display: none;
      text-align: center;
      font-family: 'Press Start 2P', sans-serif;
      margin-top: 10px;
    }

    /* Кнопка копирования ссылки */
    #copyButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      padding: 8px 16px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
      display: none; /* по умолчанию скрыта */
    }
    #copyButton:hover {
      transform: scale(1.05);
    }
    #copyButton:active {
      animation: press 0.15s forwards;
      transform: translateY(1px) scale(1.0);
    }

    /* Модальные окна */
    .endgame-backdrop, .modal-backdrop {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    .endgame-modal, .modal {
      background: #222;
      border: 2px solid #0f0;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      border-radius: 8px;
    }

    /* Анимация мигания */
    @keyframes blink {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
    .blinking {
      animation: blink 1.2s infinite;
    }

    /* Стили обучающей (landing) страницы */
    #landingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #00103c, #0a0a23);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 2000;
      color: #FF00FF;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #landingHeader {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      z-index: 2100;
    }
    #landingHeader button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    .landingContent {
      max-width: 600px;
      overflow-y: auto;
    }
    .landingContent img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
      border: 2px solid #FF00FF;
      border-radius: 8px;
    }
    .landingContent h1 {
      margin: 10px 0;
      font-size: 28px;
    }
    .landingContent p {
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 20px;
      text-align: left;
    }
    .landingContent button {
      font-family: 'Press Start 2P', sans-serif;
      font-size: 14px;
      padding: 10px 20px;
      margin: 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
      transition: transform 0.1s ease;
    }
    .landingContent button:hover {
      transform: scale(1.05);
    }
    .landingContent button:active {
      transform: translateY(1px);
    }

    /* Кнопка "Back" во время поиска */
    #searchBackBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 2100;
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
      display: none; /* по умолчанию скрыта */
    }

    /* Джойстик */
    #joystick {
      position: fixed;
      width: 100px;
      height: 100px;
      margin: -50px 0 0 -50px;
      background: rgba(100, 100, 100, 0.3);
      border: 2px solid rgba(200, 200, 200, 0.7);
      border-radius: 50%;
      display: none;
      z-index: 1000;
      touch-action: none;
    }
    #joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      margin: -25px 0 0 -25px;
      background: rgba(200, 200, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      touch-action: none;
    }

    /* Оверлей "список комнат" на весь экран */
    #roomsOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none; /* по умолчанию скрыто */
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      z-index: 3000;
      padding-top: 60px;
      text-align: center;
    }
    #roomsOverlay h2 {
      color: #FF00FF;
      margin-bottom: 20px;
    }
    #roomsList {
      max-height: 60%;
      overflow-y: auto;
      width: 80%;
      border: 2px solid #FF00FF;
      padding: 10px;
      text-align: left;
      margin: 0 auto;
      color: #fff;
    }
    #roomsOverlay button {
      margin-top: 20px;
    }

    /* Блок с настройкой ставок */
    #betSettings {
      position: absolute;
      top: 150px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #FF00FF;
      padding: 20px;
      border: 2px solid #FF00FF;
      display: none; /* по умолчанию скрыто */
      width: 300px;
      text-align: center;
      border-radius: 8px;
      z-index: 3000;
    }
    #betSettings h3 {
      margin-bottom: 15px;
    }
    #betSlider {
      width: 90%;
      margin: 10px 0;
    }

    /* Стили для кнопок в "Создать комнату" / "Посмотреть комнаты" (если нужно отдельное оформление) */
    #mainMenuButtons {
      position: absolute;
      top: 50px;
      width: 100%;
      text-align: center;
      z-index: 2500;
    }
    #mainMenuButtons button {
      margin: 5px;
      padding: 8px 16px;
      background: #06B6D1;
      color: #262626;
      border: 1px solid #4b4b4b;
      border-radius: 4px;
      box-shadow: 0 3px #6b6b6b;
      cursor: pointer;
      font-family: 'Press Start 2P', sans-serif;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <!-- Кнопка с балансом (иконка + текст) -->
  <button id="balanceButton">
    <img src="coin_icon.png" alt="Coin" width="16" height="16">
    <span id="balanceValue">0M</span> 
  </button>

  <!-- Canvas для игры -->
  <canvas id="specialGameCanvas" width="400" height="700"></canvas>

  <!-- Две кнопки в начале: посмотреть комнаты / создать комнату -->
  <div id="mainMenuButtons">
    <button id="showRoomsBtn">Посмотреть комнаты</button>
    <button id="createRoomBtn">Создать комнату</button>
  </div>

  <!-- Оверлей со списком комнат (на весь экран) -->
  <div id="roomsOverlay">
    <h2>Доступные комнаты</h2>
    <div id="roomsList">
      <!-- Здесь выводите список комнат из БД -->
      <!-- Пример статического вывода (замените на динамику) -->
      <p>Комната #1, ставка: 2 млн</p>
      <p>Комната #2, ставка: 3 млн</p>
      <p>Комната #3, ставка: 5 млн</p>
    </div>
    <button onclick="closeRoomsOverlay()">Закрыть</button>
  </div>

  <!-- Блок настройки ставок (ползунок: 1..10 => 1..10 млн) -->
  <div id="betSettings">
    <h3>Выберите ставку (в млн)</h3>
    <input id="betSlider" type="range" min="1" max="10" step="1" value="1">
    <p id="betValueDisplay">1 млн</p>
    <button id="confirmBetBtn">Подтвердить</button>
  </div>

  <!-- Отображение ников под игровым полем -->
  <div id="usernamesDisplay">
    <span id="opponentUsername"></span>
    <span style="margin: 0 20px;">VS</span>
    <span id="playerUsername"></span>
  </div>

  <!-- Обучающая (landing) страница -->
  <div id="landingScreen">
    <div id="landingHeader">
      <button id="homeBackBtn">Back</button>
      <button id="langToggleBtn">RU</button>
    </div>
    <div class="landingContent">
      <img src="game_preview.jpg" alt="Game Preview">
      <h1 id="landingTitle">Special Snake PvP</h1>

      <!-- ДВА ПАРАГРАФА: короткий + полный текст описания -->
      <p id="landingTextShort">
        Короткое описание: В этой игре вы сражаетесь змейками в PvP. Нажмите "Читать далее", чтобы раскрыть полное описание.
      </p>
      <p id="landingTextFull" style="display: none;">
        Полное описание: Добро пожаловать в Special Snake PvP – захватывающий мир динамичных PvP-сражений, где скорость, 
        стратегия и рефлексы решают судьбу каждой битвы! Управляйте своей змеёй 
        в ретро-стилистике, с эффектной графикой и атмосферным звуковым сопровождением. 
        Каждая секунда – это борьба за выживание: избегайте столкновений, собирайте 
        бонусы и обыгрывайте соперника. Играйте с друзьями или случайными игроками, 
        докажите, что вы – настоящий мастер змей!
      </p>
      <!-- Кнопка переключения описания -->
      <button id="toggleDescriptionBtn">Читать далее</button>

      <!-- Кнопка из оригинального кода (например, запуск «Start Search») -->
      <button id="startSearchBtn">Start Search</button>
    </div>
  </div>

  <!-- Кнопка Back во время поиска (скрыта до начала поиска) -->
  <button id="searchBackBtn">Back</button>

  <!-- Джойстик (для мобильных) -->
  <div id="joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- Кнопка копирования ссылки -->
  <button id="copyButton" onclick="copyInviteLink()">Copy Invite Link</button>

  <!-- Модальное окно результатов игры -->
  <div id="endgameBackdrop" class="endgame-backdrop">
    <div class="endgame-modal">
      <h2 id="endgameTitle">Game Over!</h2>
      <p id="endgameMessage"></p>
      <button onclick="finishGame()">Continue</button>
    </div>
  </div>

  <!-- Модальное окно "Not enough tickets" -->
  <div id="noTicketsModal" class="modal-backdrop">
    <div class="modal">
      <h2>Not enough tickets</h2>
      <p>You do not have enough tickets to join the game.</p>
      <button onclick="returnToMain()">Return</button>
    </div>
  </div>

<script>
/* 
============================================================
  НИЖЕ ИДЁТ ВЕСЬ КОД ВАШЕЙ ИГРЫ, дополненный нужными правками
============================================================
*/

/* === Пример переменных для баланса, текущей ставки, ссылки-приглашения === */
let userBalance = 10;   // например, 10 млн (заглушка)
let currentBet  = 1;    // ставка по умолчанию = 1 млн
let inviteLink  = "";   // будет формироваться при создании комнаты

/* Пример обновления UI баланса */
function updateBalanceUI() {
  document.getElementById('balanceValue').textContent = userBalance + 'M';
}
/* Переход на buy.html по клику на баланс */
document.getElementById('balanceButton').addEventListener('click', function(){
  window.location.href = 'buy.html';
});

/* === Логика переключения короткого и полного описания === */
let isShortDescription = true;
const landingTextShort = document.getElementById('landingTextShort');
const landingTextFull  = document.getElementById('landingTextFull');
const toggleDescBtn    = document.getElementById('toggleDescriptionBtn');
toggleDescBtn.addEventListener('click', function(){
  isShortDescription = !isShortDescription;
  if (isShortDescription) {
    landingTextShort.style.display = 'block';
    landingTextFull.style.display  = 'none';
    this.textContent = 'Читать далее';
  } else {
    landingTextShort.style.display = 'none';
    landingTextFull.style.display  = 'block';
    this.textContent = 'Свернуть';
  }
});

/* === Оверлей со списком комнат (показ/скрытие) === */
const roomsOverlay = document.getElementById('roomsOverlay');
document.getElementById('showRoomsBtn').addEventListener('click', function(){
  // Здесь можно подгрузить список из БД, обновить #roomsList
  roomsOverlay.style.display = 'flex';
});
function closeRoomsOverlay() {
  roomsOverlay.style.display = 'none';
}

/* === Окно с настройкой ставки === */
const betSettings = document.getElementById('betSettings');
const betSlider   = document.getElementById('betSlider');
const betValueDisplay = document.getElementById('betValueDisplay');

document.getElementById('createRoomBtn').addEventListener('click', function(){
  // Показываем настройки ставки
  betSettings.style.display = 'block';
});

betSlider.addEventListener('input', function(){
  currentBet = parseInt(this.value, 10);
  betValueDisplay.textContent = currentBet + ' млн';
});

document.getElementById('confirmBetBtn').addEventListener('click', function(){
  // Закрываем окно
  betSettings.style.display = 'none';
  // Создаём комнату, записываем ставку = currentBet
  // и показываем «Waiting for opponent»
  findOrCreateRoomWithBet(currentBet);
});

/* === Ваш исходный код игры (адаптированный) === */
/* Ниже он объединён с упрощённой функцией findOrCreateRoomWithBet() */

let specialGameCanvas;
let specialCtx;

const GAME_AREA_X = 50;
const GAME_AREA_Y = 50;
const GAME_AREA_WIDTH = 300;
const GAME_AREA_HEIGHT = 500;

const gridSize = 20;
const tileCountX = GAME_AREA_WIDTH / gridSize;  
const tileCountY = GAME_AREA_HEIGHT / gridSize; 

let roomId = null;
let playerId = null;
let opponentId = null;
let gameStateRef = null;

let localSnake = [];
let localDirection = 'right';
let score = 0;

let previousSnake = [];
let lastLogicUpdateTime = 0;

let opponentSnake = [];
let opponentScore = 0;
let opponentName = '';

let previousOpponentSnake = [];
let lastOpponentUpdateTime = performance.now();

let applePos = { x: 0, y: 0 };

let isGameRunning = false;
let isGameOver    = false;
let countdownValue = 5;
let showOpponentNameTimeout = null;

let timerTotal = 60;
let timerCurrent = 60;

let logicTimer = null;
let countdownInterval = null;

let waitingListener = null;
let oppListener     = null;

const snakeColors = {
  player1: '#FFFF00',
  player2: '#FF0000'
};

const LOGIC_INTERVAL = 150;

// Флаг если противник отключился
let opponentDisconnected = false;

// === Инициализация Firebase и прочее ===
window.addEventListener('load', () => {
  // Инициализируем Firebase
  const firebaseConfig = {
    // ВАШИ КЛЮЧИ Firebase
    apiKey: "AIzaSy..............",
    authDomain: "...",
    databaseURL: "...",
    projectId: "...",
    storageBucket: "...",
    messagingSenderId: "...",
    appId: "...",
    measurementId: "..."
  };
  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
  }

  // Пример получения Telegram-пользователя
  if (!window.currentUser) {
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      const tgUser = Telegram.WebApp.initDataUnsafe.user;
      window.currentUser = {
        username: tgUser.username ? tgUser.username : (tgUser.first_name ? tgUser.first_name : "Anonymous"),
        photo_url: tgUser.photo_url || "https://img.icons8.com/ios-filled/50/00FF00/user.png"
      };
    } else {
      window.currentUser = {
        username: "TestUser",
        photo_url: "https://img.icons8.com/ios-filled/50/00FF00/user.png"
      };
    }
  }

  // Обновляем UI баланса
  updateBalanceUI();

  // Инициализация игры
  initSpecialGame1();
  updateLanguageTexts(); // из вашего кода (для переключения языков)
});

/* === Функция findOrCreateRoom (теперь с учётом currentBet) === */
function findOrCreateRoomWithBet(bet) {
  const queueRef = firebase.database().ref('snakeQueue');

  // Удаляем старые комнаты, созданные этим же пользователем
  queueRef.orderByChild('creator').equalTo(window.currentUser.username).once('value')
    .then(snapshot => {
      snapshot.forEach(childSnapshot => {
        childSnapshot.ref.remove();
      });
      return queueRef.once('value');
    })
    .then((snapshot) => {
      const queueData = snapshot.val() || {};
      let openRoomKey = null;
      // Ищем «ждущую» комнату с той же ставкой (по желанию)
      for (const key in queueData) {
        if (queueData[key].status === 'waiting' && queueData[key].creator !== window.currentUser.username) {
          // Можно ещё проверить queueData[key].bet === bet, если хотите подбирать только по одинаковой ставке
          openRoomKey = key;
          break;
        }
      }
      if (openRoomKey) {
        roomId = openRoomKey;
        playerId = 'player2';
        opponentId = 'player1';
        firebase.database().ref('snakeQueue/' + roomId)
          .update({ status: 'ready' })
          .catch((err) => console.error('Error updating room status:', err));
      } else {
        // Создаём новую комнату
        roomId = queueRef.push().key;
        playerId = 'player1';
        opponentId = 'player2';
        queueRef.child(roomId).set({
          status: 'waiting',
          createdAt: firebase.database.ServerValue.TIMESTAMP,
          creator: window.currentUser.username,
          bet: bet // записываем ставку
        }).catch((err) => console.error('Error creating room:', err));

        // Если создатель выйдет -> onDisconnect удаляем комнату
        queueRef.child(roomId).onDisconnect().remove();
      }
      // Устанавливаем ссылки в snakeGames
      setupGameReferences();

      // Формируем пригласительную ссылку
      inviteLink = "https://mygame.example.com/invite?room=" + roomId;
      document.getElementById('copyButton').style.display = 'block';

      // Теперь «ждём противника»
      waitForOpponent();
    })
    .catch((err) => console.error('Error in findOrCreateRoom:', err));
}

/* === Остальная логика та же, что и в исходном коде === */
function initSpecialGame1() {
  specialGameCanvas = document.getElementById('specialGameCanvas');
  specialCtx = specialGameCanvas.getContext('2d');
  resetSpecialGame1();
  drawWaitingScreen();
  setupControlButtons();
}
function resetSpecialGame1() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  if (showOpponentNameTimeout) {
    clearTimeout(showOpponentNameTimeout);
    showOpponentNameTimeout = null;
  }
  roomId = null;
  playerId = null;
  opponentId = null;
  gameStateRef = null;
  localSnake = [];
  localDirection = 'right';
  score = 0;
  opponentSnake = [];
  opponentScore = 0;
  opponentName = "";
  applePos = { x: 0, y: 0 };
  isGameRunning = false;
  isGameOver = false;
  countdownValue = 5;
  timerTotal = 60;
  timerCurrent = 60;
  inviteLink = "";

  if (waitingListener && roomId) {
    firebase.database().ref('snakeQueue/' + roomId + '/status').off('value', waitingListener);
    waitingListener = null;
  }
  if (oppListener && roomId) {
    firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId).off('value', oppListener);
    oppListener = null;
  }
  removeSwipeListeners();
}
function waitForOpponent() {
  drawSearchScreen();

  const statusRef = firebase.database().ref('snakeQueue/' + roomId + '/status');
  waitingListener = statusRef.on('value', async (snapshot) => {
    const currentStatus = snapshot.val();
    if (currentStatus === 'ready') {
      statusRef.off('value', waitingListener);
      waitingListener = null;
      try {
        const oppSnapshot = await firebase.database()
          .ref('snakeGames/' + roomId + '/players/' + opponentId)
          .once('value');
        const oppData = oppSnapshot.val();
        if (oppData && oppData.username) {
          opponentName = oppData.username;
        }
      } catch(e) {
        console.error("Error reading opponent data: ", e);
      }
      drawOpponentFoundScreen();
      document.getElementById('copyButton').style.display = 'none';
      document.getElementById('homeBackBtn').style.display = 'none';
      showOpponentNameTimeout = setTimeout(() => {
        startCountdown();
      }, 2000);
    }
  });

  const oppRef = firebase.database().ref('snakeGames/' + roomId + '/players/' + opponentId);
  oppListener = oppRef.on('value', (snapshot) => {
    const oppData = snapshot.val();
    if (oppData) {
      previousOpponentSnake = opponentSnake.length ? opponentSnake.map(seg => ({...seg})) : (oppData.snake || []);
      opponentSnake = oppData.snake || [];
      opponentScore = oppData.score || 0;
      opponentName  = (oppData.username && oppData.username.trim() !== "") ? oppData.username : 'Player';
      lastOpponentUpdateTime = performance.now();
    } else {
      if (isGameRunning) {
        opponentDisconnected = true;
        setGameOver();
      }
    }
  });
}
function setupGameReferences() {
  gameStateRef = firebase.database().ref('snakeGames/' + roomId);
  const playerRef = gameStateRef.child('players').child(playerId);

  playerRef.once('value').then((snapshot) => {
    if (!snapshot.exists()) {
      let startX, startY;
      if (playerId === 'player1') {
        startX = 3;
        startY = Math.floor(tileCountY / 2);
      } else {
        startX = tileCountX - 4;
        startY = Math.floor(tileCountY / 2);
      }
      const initialSnake = [
        { x: startX,     y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];
      playerRef.set({
        snake: initialSnake,
        direction: 'right',
        score: 0,
        username: (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'Player'
      }).catch((err) => console.error('Error initializing player data:', err));

      playerRef.onDisconnect().remove()
        .then(() => console.log("onDisconnect set for player:", playerId))
        .catch((err) => console.error("Error setting onDisconnect:", err));
    }
  });

  gameStateRef.child('apple').on('value', (snapshot) => {
    const aData = snapshot.val() || {};
    if (typeof aData.x === 'number' && typeof aData.y === 'number') {
      applePos.x = aData.x;
      applePos.y = aData.y;
    }
  });

  gameStateRef.child('gameOver').on('value', (snapshot) => {
    if (snapshot.val() === true && !isGameOver) {
      isGameOver = true;
      endGame();
    }
  });
}
function startCountdown() {
  countdownValue = 5;
  countdownInterval = setInterval(() => {
    drawCountdownScreen(countdownValue);
    countdownValue--;
    if (countdownValue < 1) {
      clearInterval(countdownInterval);
      launchGame();
    }
  }, 1000);
}
function launchGame() {
  isGameRunning = true;
  isGameOver    = false;

  gameStateRef.child('players').child(playerId).once('value').then((snapshot) => {
    const data = snapshot.val();
    if (data && data.snake) {
      localSnake = data.snake;
    }
    localDirection = (data && data.direction) ? data.direction : 'right';
    score = (data && data.score) ? data.score : 0;
    
    previousSnake = localSnake.map(seg => ({...seg}));
    lastLogicUpdateTime = performance.now();

    gameStateRef.child('apple').once('value').then((appleSnap) => {
      if (!appleSnap.exists()) {
        spawnApple();
      }
    });

    addSwipeListeners();
    startLogicLoop();
    startTimer();
    requestAnimationFrame(renderLoop);

    // Отображаем ники
    updateUsernamesDisplay();
  });
}
function startLogicLoop() {
  logicTimer = setInterval(gameLogicUpdate, LOGIC_INTERVAL);
}
function stopLogicLoop() {
  if (logicTimer) {
    clearInterval(logicTimer);
    logicTimer = null;
  }
}
function gameLogicUpdate() {
  if (!isGameRunning || isGameOver) return;
  previousSnake = localSnake.map(seg => ({...seg}));
  moveLocalSnake();
  lastLogicUpdateTime = performance.now();
  if (checkSelfCollision()) {
    setGameOver();
    return;
  }
  const head = localSnake[0];
  if (head.x === applePos.x && head.y === applePos.y) {
    score++;
    updatePlayerState(true);
    spawnApple();
  } else {
    updatePlayerState(false);
  }
}
function renderLoop() {
  renderGame();
  if (!isGameOver) {
    requestAnimationFrame(renderLoop);
  }
}
function moveLocalSnake() {
  const head = { ...localSnake[0] };
  switch (localDirection) {
    case 'left':  head.x--; break;
    case 'right': head.x++; break;
    case 'up':    head.y--; break;
    case 'down':  head.y++; break;
  }
  if (head.x < 0) head.x = tileCountX - 1;
  if (head.x >= tileCountX) head.x = 0;
  if (head.y < 0) head.y = tileCountY - 1;
  if (head.y >= tileCountY) head.y = 0;
  localSnake.unshift(head);
  localSnake.pop();
}
function checkSelfCollision() {
  // Можно реализовать проверку, если нужно
  return false;
}
function updatePlayerState(ateApple) {
  if (ateApple) {
    const lastSegment = localSnake[localSnake.length - 1];
    localSnake.push({ ...lastSegment });
  }
  gameStateRef.child('players').child(playerId).update({
    snake: localSnake,
    direction: localDirection,
    score: score
  }).catch((err) => console.error('Error updating player state:', err));
}
function spawnApple() {
  const newApple = {
    x: Math.floor(Math.random() * tileCountX),
    y: Math.floor(Math.random() * tileCountY)
  };
  gameStateRef.child('apple').set(newApple)
    .catch((err) => console.error('Error setting apple:', err));
}
function setGameOver() {
  isGameOver = true;
  gameStateRef.update({ gameOver: true })
    .catch((err) => console.error('Error setting gameOver:', err));
  endGame();
}
function endGame() {
  stopLogicLoop();
  clearInterval(countdownInterval);
  let resultTitle = 'Game Over';
  if (opponentDisconnected) {
    resultTitle = 'Opponent Disconnected. You Win!';
  } else {
    if (score > opponentScore) {
      resultTitle = 'You Win!';
    } else if (score < opponentScore) {
      resultTitle = 'You Lose...';
    } else {
      resultTitle = 'Draw';
    }
  }
  const msg = `Your score: ${score} | Opponent: ${opponentScore}`;
  showEndGameModal(resultTitle, msg);
  cleanupRoom();
}
function startTimer() {
  timerCurrent = timerTotal;
  const timerInterval = setInterval(() => {
    if (!isGameRunning || isGameOver) {
      clearInterval(timerInterval);
      return;
    }
    timerCurrent--;
    if (timerCurrent <= 0) {
      setGameOver();
      clearInterval(timerInterval);
    }
  }, 1000);
}
function renderGame() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  drawMatrixGrid();

  let now = performance.now();
  let factor = Math.min((now - lastLogicUpdateTime) / LOGIC_INTERVAL, 1);

  // Яблоко (звёздочка)
  let appleImg = new Image();
  appleImg.src = 'https://www.pngkit.com/png/full/784-7843310_christmas-star-star-pixel-art.png';
  if (appleImg.complete) {
    specialCtx.drawImage(
      appleImg,
      GAME_AREA_X + applePos.x * gridSize,
      GAME_AREA_Y + applePos.y * gridSize,
      gridSize,
      gridSize
    );
  }

  // Локальная змейка
  for (let i = 0; i < localSnake.length; i++) {
    let curr = localSnake[i];
    let prev = previousSnake[i] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
    let x = GAME_AREA_X + interpX * gridSize;
    let y = GAME_AREA_Y + interpY * gridSize;
    specialCtx.fillStyle = snakeColors[playerId] || '#800080';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  }

  // Змейка противника
  let opponentFactor = Math.min((now - lastOpponentUpdateTime) / LOGIC_INTERVAL, 1);
  for (let i = 0; i < opponentSnake.length; i++) {
    let curr = opponentSnake[i];
    let prev = previousOpponentSnake[i] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
    let x = GAME_AREA_X + interpX * gridSize;
    let y = GAME_AREA_Y + interpY * gridSize;
    specialCtx.fillStyle = snakeColors[opponentId] || '#FFFF00';
    specialCtx.fillRect(x, y, gridSize, gridSize);
    specialCtx.strokeStyle = '#000';
    specialCtx.lineWidth = 2;
    specialCtx.strokeRect(x, y, gridSize, gridSize);
  }

  // Имя противника над головой
  if (opponentSnake.length > 0) {
    let curr = opponentSnake[0];
    let prev = previousOpponentSnake[0] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, opponentFactor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, opponentFactor, tileCountY);
    specialCtx.fillStyle = "lime";
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    specialCtx.fillText(
      '@' + ((opponentName && opponentName.trim() !== "") ? opponentName : 'Anonymous'),
      GAME_AREA_X + interpX * gridSize,
      GAME_AREA_Y + interpY * gridSize - 5
    );
  }

  // Имя игрока над головой
  if (localSnake.length > 0) {
    let curr = localSnake[0];
    let prev = previousSnake[0] || curr;
    let interpX = interpolateCoordinate(prev.x, curr.x, factor, tileCountX);
    let interpY = interpolateCoordinate(prev.y, curr.y, factor, tileCountY);
    specialCtx.fillStyle = "lime";
    specialCtx.font = '12px "Press Start 2P", sans-serif';
    const myName = (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'You';
    specialCtx.fillText(
      '@' + myName,
      GAME_AREA_X + interpX * gridSize,
      GAME_AREA_Y + interpY * gridSize - 5
    );
  }

  // Счёт
  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '12px "Press Start 2P", sans-serif';
  specialCtx.fillText(`Score: ${score}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 30);
  specialCtx.fillText(`Opp: ${opponentScore}`, GAME_AREA_X + GAME_AREA_WIDTH - 140, GAME_AREA_Y - 15);

  // Таймер (полоска)
  const barWidth = (timerCurrent / timerTotal) * GAME_AREA_WIDTH;
  specialCtx.fillStyle = '#FF00FF';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y - 5, barWidth, 4);
}
function drawMatrixGrid() {
  specialCtx.fillStyle = '#433171';
  specialCtx.fillRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);

  specialCtx.strokeStyle = '#00103c';
  for (let i = 0; i <= tileCountX; i++) {
    let x = GAME_AREA_X + i * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(x, GAME_AREA_Y);
    specialCtx.lineTo(x, GAME_AREA_Y + GAME_AREA_HEIGHT);
    specialCtx.stroke();
  }
  for (let j = 0; j <= tileCountY; j++) {
    let y = GAME_AREA_Y + j * gridSize;
    specialCtx.beginPath();
    specialCtx.moveTo(GAME_AREA_X, y);
    specialCtx.lineTo(GAME_AREA_X + GAME_AREA_WIDTH, y);
    specialCtx.stroke();
  }
  specialCtx.strokeStyle = '#8F509D';
  specialCtx.lineWidth = 2;
  specialCtx.strokeRect(GAME_AREA_X, GAME_AREA_Y, GAME_AREA_WIDTH, GAME_AREA_HEIGHT);
}
function drawWaitingScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#000';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
}
function drawSearchScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#00103c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '15px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(
    'Searching for opponent...',
    specialGameCanvas.width / 2,
    specialGameCanvas.height / 2
  );
}
function drawOpponentFoundScreen() {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#FF00FF';
  specialCtx.font = '16px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  const displayName = (opponentName && opponentName.trim() !== "") ? opponentName : "Anonymous";
  specialCtx.fillText('Opponent: @' + displayName, specialGameCanvas.width / 2, specialGameCanvas.height / 2);
}
function drawCountdownScreen(value) {
  specialCtx.clearRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);
  specialCtx.fillStyle = '#1f1c2c';
  specialCtx.fillRect(0, 0, specialGameCanvas.width, specialGameCanvas.height);

  specialCtx.fillStyle = '#00FF00';
  specialCtx.font = '60px "Press Start 2P", sans-serif';
  specialCtx.textAlign = 'center';
  specialCtx.fillText(value.toString(), specialGameCanvas.width / 2, specialGameCanvas.height / 2);
}
function interpolateCoordinate(prevVal, currVal, factor, maxVal) {
  let diff = currVal - prevVal;
  if (Math.abs(diff) > maxVal / 2) {
    if (diff > 0) diff -= maxVal;
    else diff += maxVal;
  }
  let interp = prevVal + diff * factor;
  if (interp < 0) interp += maxVal;
  if (interp >= maxVal) interp -= maxVal;
  return interp;
}

/* === Джойстик + клавиатура === */
function addSwipeListeners() {
  function onKeyDown(e) {
    switch (e.key) {
      case 'ArrowLeft':
        if (localDirection !== 'right') localDirection = 'left';
        break;
      case 'ArrowRight':
        if (localDirection !== 'left') localDirection = 'right';
        break;
      case 'ArrowUp':
        if (localDirection !== 'down') localDirection = 'up';
        break;
      case 'ArrowDown':
        if (localDirection !== 'up') localDirection = 'down';
        break;
    }
  }
  window.addEventListener('keydown', onKeyDown);
  window.__joystick_keydown = onKeyDown;

  const canvas = specialGameCanvas;
  const joystick = document.getElementById('joystick');
  const joystickStick = document.getElementById('joystick-stick');
  let joystickActive = false;
  let joystickCenter = { x: 0, y: 0 };
  const maxDistance = 40;

  function handleTouchStart(e) {
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      joystickCenter.x = touch.clientX;
      joystickCenter.y = touch.clientY;
      joystick.style.left = joystickCenter.x + 'px';
      joystick.style.top = joystickCenter.y + 'px';
      joystick.style.display = 'block';
      joystickStick.style.transform = 'translate(0px, 0px)';
      joystickActive = true;
      e.preventDefault();
    }
  }

  function handleTouchMove(e) {
    if (!joystickActive) return;
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      let dx = touch.clientX - joystickCenter.x;
      let dy = touch.clientY - joystickCenter.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        dx = Math.cos(angle) * maxDistance;
        dy = Math.sin(angle) * maxDistance;
      }
      joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && localDirection !== 'left') {
          localDirection = 'right';
        } else if (dx < 0 && localDirection !== 'right') {
          localDirection = 'left';
        }
      } else {
        if (dy > 0 && localDirection !== 'up') {
          localDirection = 'down';
        } else if (dy < 0 && localDirection !== 'down') {
          localDirection = 'up';
        }
      }
      e.preventDefault();
    }
  }
  function handleTouchEnd(e) {
    joystickActive = false;
    joystick.style.display = 'none';
    e.preventDefault();
  }
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove,  { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd,    { passive: false });
  window.__joystick_touchstart = handleTouchStart;
  window.__joystick_touchmove  = handleTouchMove;
  window.__joystick_touchend   = handleTouchEnd;
}
function removeSwipeListeners() {
  if (!specialGameCanvas) return;
  specialGameCanvas.removeEventListener('touchstart', window.__joystick_touchstart);
  specialGameCanvas.removeEventListener('touchmove',  window.__joystick_touchmove);
  specialGameCanvas.removeEventListener('touchend',   window.__joystick_touchend);
  window.removeEventListener('keydown', window.__joystick_keydown);
  window.__joystick_touchstart = null;
  window.__joystick_touchmove  = null;
  window.__joystick_touchend   = null;
  window.__joystick_keydown    = null;
}

/* === Копирование ссылки === */
function copyInviteLink() {
  if (!inviteLink) return;
  navigator.clipboard.writeText(inviteLink)
    .then(() => console.log("Invite link copied:", inviteLink))
    .catch(err => console.error("Error copying invite link:", err));
}

/* === Модальное окно конца игры === */
function showEndGameModal(title, message) {
  const modal = document.getElementById('endgameBackdrop');
  const titleEl = document.getElementById('endgameTitle');
  const msgEl   = document.getElementById('endgameMessage');
  titleEl.textContent = title;
  msgEl.textContent   = message;
  modal.style.display = 'flex';
}
function finishGame() {
  document.getElementById('endgameBackdrop').style.display = 'none';
  window.location.href = 'index.html';
}
function returnToMain() {
  document.getElementById('noTicketsModal').style.display = 'none';
  window.location.href = 'index.html';
}

/* === Настройка кнопок управления (если есть) === */
function setupControlButtons() {
  const buttons = document.querySelectorAll('.control-button');
  buttons.forEach(button => {
    button.addEventListener('click', () => {
      const newDirection = button.getAttribute('data-direction');
      if ((localDirection === 'left'  && newDirection === 'right') ||
          (localDirection === 'right' && newDirection === 'left')  ||
          (localDirection === 'up'    && newDirection === 'down')  ||
          (localDirection === 'down'  && newDirection === 'up')) {
        return;
      }
      localDirection = newDirection;
    });
  });
}

/* === Уборка комнаты после игры === */
function cleanupRoom() {
  if (roomId) {
    firebase.database().ref('snakeGames/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeGames."))
      .catch((err) => console.error("Error removing game room:", err));

    firebase.database().ref('snakeQueue/' + roomId).remove()
      .then(() => console.log("Game room removed from snakeQueue."))
      .catch((err) => console.error("Error removing room from snakeQueue:", err));
  }
}
window.addEventListener('beforeunload', function() {
  if (roomId && gameStateRef) {
    gameStateRef.child('players').child(playerId).remove();
  }
});

/* === Кнопки на обучающей странице (пример) === */
document.getElementById('startSearchBtn').addEventListener('click', function(){
  document.getElementById('landingScreen').style.display = 'none';
  document.getElementById('searchBackBtn').style.display = 'block';
  findOrCreateRoom(); // если вам нужно искать комнату без ставки
  // или можно вызвать findOrCreateRoomWithBet(currentBet), если нужна именно механика ставок
});
document.getElementById('searchBackBtn').addEventListener('click', function(){
  window.location.reload();
});
document.getElementById('homeBackBtn').addEventListener('click', function() {
  window.location.href = 'index.html';
});

/* === Функция смены направления (для примера) === */
function changeDirection(newDir) {
  if (
    (newDir === 'up'    && localDirection === 'down') ||
    (newDir === 'down'  && localDirection === 'up')   ||
    (newDir === 'left'  && localDirection === 'right')||
    (newDir === 'right' && localDirection === 'left')
  ) {
    return;
  }
  localDirection = newDir;
}

/* === Смена языка (пример) === */
let currentLanguage = "en";
const languageStrings = {
  en: {
    landingTitle: "Special Snake PvP",
    landingText: "Welcome to Special Snake PvP ...",
    startSearch: "Start Search",
    homeBack: "Back",
    languageToggle: "RU"
  },
  ru: {
    landingTitle: "Спешл Снейк PvP",
    landingText: "Добро пожаловать в Special Snake PvP ...",
    startSearch: "Начать поиск",
    homeBack: "Назад",
    languageToggle: "EN"
  }
};
function updateLanguageTexts() {
  // Пример перевода
  // document.getElementById('landingTitle').textContent = languageStrings[currentLanguage].landingTitle;
  // ...
}
document.getElementById('langToggleBtn').addEventListener('click', function() {
  currentLanguage = currentLanguage === "en" ? "ru" : "en";
  updateLanguageTexts();
});

/* === Обновление ников под игрой === */
function updateUsernamesDisplay() {
  const opponentDisplay = document.getElementById('opponentUsername');
  const playerDisplay   = document.getElementById('playerUsername');
  opponentDisplay.textContent = '@' + ((opponentName && opponentName.trim() !== "") ? opponentName : 'Anonymous');
  opponentDisplay.style.color = snakeColors[opponentId] || 'lime';
  const myName = (window.currentUser && window.currentUser.username && window.currentUser.username.trim() !== "") ? window.currentUser.username : 'You';
  playerDisplay.textContent = '@' + myName;
  playerDisplay.style.color = snakeColors[playerId] || 'lime';
  document.getElementById('usernamesDisplay').style.display = 'block';
}
</script>
</body>
</html>
