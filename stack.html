<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>The Stack Game + Menu</title>
  <meta name="viewport" content="width=device-width, user-scalable=no">
  
  <!-- Font: Press Start 2P (или Comfortaa, как в исходном stack.css) -->
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API (если требуется) -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- THREE.js и GSAP (для Stack-игры) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js"></script>

  <style>
    /* ---------- Общие стили меню/логики (Firebase + Telegram) ---------- */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #00103c; /* общий фон */
      font-family: 'Comfortaa', sans-serif;
    }
    #container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    /* Header с информацией о пользователе (Telegram) */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      color: #fff;
      align-items: center;
      font-size: 10px;
    }
    #info span {
      white-space: nowrap;
    }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img {
      width: 16px;
      height: 16px;
    }
    /* Кнопка Back */
    #backContainer {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

    /* ---------- Стили для Stack Game (из stack.css) ---------- */
    #game {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
    #score {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 10vh;
      transition: transform 0.5s ease;
      color: #333344;
      transform: translateY(-200px) scale(1);
    }
    #instructions {
      position: absolute;
      width: 100%;
      top: 16vh;
      left: 0;
      text-align: center;
      transition: opacity 0.5s ease, transform 0.5s ease;
      opacity: 0;
    }
    #instructions.hide {
      opacity: 0 !important;
    }
    .game-over {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 85%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .game-over * {
      transition: opacity 0.5s ease, transform 0.5s ease;
      opacity: 0; transform: translateY(-50px);
      color: #333344;
    }
    .game-over h2 {
      margin: 0; padding: 0; font-size: 40px;
    }
    .game-ready {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: space-around;
    }
    .game-ready #start-button {
      transition: opacity 0.5s ease, transform 0.5s ease;
      opacity: 0; transform: translateY(-50px);
      border: 3px solid #333344;
      padding: 10px 20px;
      background-color: transparent;
      color: #333344;
      font-size: 30px;
      cursor: pointer;
    }

    /* Состояния (классы добавляются в коде JS StackGame) */
    #container.playing #score { transform: translateY(0px) scale(1); }
    #container.playing #instructions { opacity: 1; }
    #container.ready .game-ready #start-button { opacity: 1; transform: translateY(0); }
    #container.ended #score { transform: translateY(6vh) scale(1.5); }
    #container.ended .game-over * {
      opacity: 1; transform: translateY(0);
    }
    #container.ended .game-over p { transition-delay: 0.3s; }

    /* Модальное окно, если нет билетов/данные не загружены */
    #modalNoTickets {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      visibility: hidden;
    }
    #modalNoTickets.active { visibility: visible; }
    #modalNoTickets .modal-content {
      background: #222;
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 20px;
      width: 80%; max-width: 400px;
      text-align: center;
      color: #FF00FF;
      font-size: 14px;
    }
    #modalNoTickets .modal-content button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

  </style>
</head>

<body>
  <div id="container">
    <!-- Шапка (Telegram user info, билеты) -->
    <div id="header">
      <div id="info">
        <span id="username">@User</span>
        <div class="balance">
          <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
          <span id="ticketCount">0</span>
        </div>
        <div class="balance">
          <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
          <span id="pointCount">0</span>
        </div>
      </div>
    </div>

    <!-- Кнопка Back -->
    <div id="backContainer">
      <button id="backBtn">Back</button>
    </div>

    <!-- Модальное окно, если нет билетов -->
    <div id="modalNoTickets">
      <div class="modal-content">
        <h3>Not enough tickets!</h3>
        <p>Please come back later.</p>
        <button id="closeNoTickets">OK</button>
      </div>
    </div>

    <!-- Основная игра (The Stack) -->
    <div id="game"></div>
    <div id="score">0</div>
    <div id="instructions">Click (or press space) to place the block</div>
    <div class="game-over">
      <h2>Game Over</h2>
      <p>You did great, you're the best.</p>
      <p>Click or spacebar to start again</p>
    </div>
    <div class="game-ready">
      <div id="start-button">Start</div>
      <div></div>
    </div>
  </div>

  <!-- Звуки (пример, если нужны) -->
  <audio id="bgSound" src="background.mp3" loop></audio>
  <audio id="moveSound" src="move.mp3"></audio>
  <audio id="deathSound" src="death.mp3"></audio>

  <script>
    /* ---------- ЛОГИКА FIREBASE + TICKETS + TELEGRAM ---------- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let tgApp = null;
    if (window.Telegram && window.Telegram.WebApp) {
      tgApp = window.Telegram.WebApp;
      tgApp.expand();
    }

    let currentUser = null;
    let userRef = null;
    let localUserData = {
      tickets: 0,
      points: 0
    };

    // Флаг, что данные успешно загрузились (иначе не даём начать)
    let dataLoaded = false;
    setTimeout(() => { dataLoaded = true; }, 3000); // 3 секунды на всякий случай

    const usernameElem = document.getElementById('username');
    const ticketCountElem = document.getElementById('ticketCount');
    const pointCountElem = document.getElementById('pointCount');
    const modalNoTickets = document.getElementById('modalNoTickets');
    const modalNoTicketsClose = document.getElementById('closeNoTickets');
    modalNoTicketsClose.addEventListener('click', () => {
      modalNoTickets.classList.remove('active');
    });

    // Back button
    document.getElementById('backBtn').addEventListener('click', () => {
      window.location.href = 'index.html';
    });

    // Инициализация Telegram WebApp, Firebase user
    if (tgApp && tgApp.initDataUnsafe && tgApp.initDataUnsafe.user) {
      currentUser = tgApp.initDataUnsafe.user;
      usernameElem.textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({
            tickets: 5,
            points: 0
          });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    } else {
      // Тестовый пользователь
      currentUser = { username: 'TestUser' };
      usernameElem.textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({
            tickets: 5,
            points: 0
          });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    }

    function updateHeader() {
      ticketCountElem.textContent = localUserData.tickets;
      pointCountElem.textContent = localUserData.points;
    }

    /* ---------- ЛОГИКА “The Stack” (адаптировано под билеты) ---------- */
    const containerElem = document.getElementById('container');
    const startBtn = document.getElementById('start-button');

    // При клике на Start:
    startBtn.addEventListener('click', () => {
      if (!dataLoaded || localUserData.tickets < 1) {
        // нет данных или нет билетов
        showNoTicketsModal();
        return;
      }
      // уменьшаем на 1 билет, пишем в Firebase
      localUserData.tickets--;
      if (userRef) userRef.update({ tickets: localUserData.tickets });
      updateHeader();
      // Запускаем игру (убираем game-ready, показываем playing)
      startStackGame();
    });

    function showNoTicketsModal() {
      modalType = "noTickets";
      modalNoTickets.classList.add('active');
    }

    // --------------------- КОД ИГРЫ “THE STACK” ---------------------
    let gameState = "READY"; // READY, PLAYING, ENDED
    let mainScoreElem = document.getElementById('score');
    let instructionsElem = document.getElementById('instructions');
    let gameOverElem = document.querySelector('.game-over');
    let gameReadyElem = document.querySelector('.game-ready');

    // Первичная инициализация показа
    mainScoreElem.innerHTML = "0";
    containerElem.classList.add("ready");
    instructionsElem.classList.add("hide");

    // Класс Stage (из Stack)
    class Stage {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor("#D0CBC7", 1);
        document.getElementById("game").appendChild(this.renderer.domElement);

        this.scene = new THREE.Scene();

        let aspect = window.innerWidth / window.innerHeight;
        let d = 20;
        this.camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, -100, 1000);
        this.camera.position.set(2, 2, 2);
        this.camera.lookAt(new THREE.Vector3(0,0,0));

        this.light = new THREE.DirectionalLight(0xffffff, 0.5);
        this.light.position.set(0, 499, 0);
        this.scene.add(this.light);

        this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(this.softLight);

        window.addEventListener("resize", () => this.onResize());
        this.onResize();
      }
      render() {
        this.renderer.render(this.scene, this.camera);
      }
      add(elem) {
        this.scene.add(elem);
      }
      remove(elem) {
        this.scene.remove(elem);
      }
      setCamera(y, speed=0.3) {
        TweenLite.to(this.camera.position, speed, { y: y+4, ease: Power1.easeInOut });
        let lookAt = this.camera.lookAt;
        // "lookAt" это метод, но нам нужно менять target, сделаем "camera.lookAtVector"
        // Для упрощения - просто TweenLite.to({}, speed,...). 
      }
      onResize() {
        let viewSize = 30;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.left = window.innerWidth / -viewSize;
        this.camera.right = window.innerWidth / viewSize;
        this.camera.top = window.innerHeight / viewSize;
        this.camera.bottom = window.innerHeight / -viewSize;
        this.camera.updateProjectionMatrix();
      }
    }

    // Класс Block (из Stack)
    class Block {
      constructor(block) {
        this.STATES = { ACTIVE: "active", STOPPED: "stopped", MISSED: "missed" };
        this.MOVE_AMOUNT = 12;
        this.dimension = { width: 0, height: 0, depth: 0 };
        this.position = { x: 0, y: 0, z: 0 };
        this.targetBlock = block;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 ? "x" : "z";
        this.workingDimension = this.index % 2 ? "width" : "depth";
        // размеры
        this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
        this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
        this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;

        // позиция
        this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
        this.position.y = this.dimension.height * this.index;
        this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;

        // цвет
        this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random()*100);
        if (!this.targetBlock) {
          this.color = 0x333344;
        } else {
          let offset = this.index + this.colorOffset;
          let r = Math.sin(0.3*offset)*55 + 200;
          let g = Math.sin(0.3*offset+2)*55 + 200;
          let b = Math.sin(0.3*offset+4)*55 + 200;
          this.color = new THREE.Color(r/255, g/255, b/255);
        }

        // state
        this.state = (this.index > 1) ? this.STATES.ACTIVE : this.STATES.STOPPED;
        this.speed = -0.1 - this.index * 0.005;
        if (this.speed < -4) this.speed = -4;
        this.direction = this.speed;

        // создаём mesh
        let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2));
        this.material = new THREE.MeshToonMaterial({ color: this.color });
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.set(this.position.x, this.position.y, this.position.z);

        if (this.state == this.STATES.ACTIVE) {
          this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
        }
      }

      reverseDirection() {
        this.direction = this.direction>0 ? this.speed : Math.abs(this.speed);
      }
      place() {
        this.state = this.STATES.STOPPED;
        let overlap = this.targetBlock.dimension[this.workingDimension] -
          Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
        let blocksToReturn = { plane: this.workingPlane, direction: this.direction };
        if (this.dimension[this.workingDimension] - overlap < 0.3) {
          overlap = this.dimension[this.workingDimension];
          blocksToReturn.bonus = true;
          this.position.x = this.targetBlock.position.x;
          this.position.z = this.targetBlock.position.z;
          this.dimension.width = this.targetBlock.dimension.width;
          this.dimension.depth = this.targetBlock.dimension.depth;
        }
        if (overlap > 0) {
          let choppedDimensions = {
            width: this.dimension.width,
            height: this.dimension.height,
            depth: this.dimension.depth
          };
          choppedDimensions[this.workingDimension] -= overlap;
          this.dimension[this.workingDimension] = overlap;

          let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
          placedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width/2,this.dimension.height/2,this.dimension.depth/2));
          let placedMesh = new THREE.Mesh(placedGeometry,this.material);

          let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width,choppedDimensions.height,choppedDimensions.depth);
          choppedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(choppedDimensions.width/2,choppedDimensions.height/2,choppedDimensions.depth/2));
          let choppedMesh = new THREE.Mesh(choppedGeometry,this.material);

          let choppedPosition = { x: this.position.x, y: this.position.y, z: this.position.z };
          if (this.position[this.workingPlane]< this.targetBlock.position[this.workingPlane]) {
            this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane];
          } else {
            choppedPosition[this.workingPlane]+=overlap;
          }
          placedMesh.position.set(this.position.x,this.position.y,this.position.z);
          choppedMesh.position.set(choppedPosition.x,choppedPosition.y,choppedPosition.z);

          blocksToReturn.placed = placedMesh;
          if (!blocksToReturn.bonus) blocksToReturn.chopped = choppedMesh;
        } else {
          this.state = this.STATES.MISSED;
        }
        this.dimension[this.workingDimension] = overlap;
        return blocksToReturn;
      }
      tick() {
        if (this.state==this.STATES.ACTIVE) {
          let value = this.position[this.workingPlane];
          if (value> this.MOVE_AMOUNT || value< -this.MOVE_AMOUNT)
            this.reverseDirection();
          this.position[this.workingPlane]+=this.direction;
          this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
        }
      }
    }

    // Главный класс StackGame
    class StackGame {
      constructor() {
        // элементы
        this.containerElem = document.getElementById('container');
        this.scoreElem = document.getElementById('score');
        this.instructionsElem = document.getElementById('instructions');
        this.gameOverElem = document.querySelector('.game-over');
        this.gameReadyElem = document.querySelector('.game-ready');
        this.startButtonElem = document.getElementById('start-button');

        // группы блоков
        this.newBlocksGroup = new THREE.Group();
        this.placedBlocksGroup = new THREE.Group();
        this.choppedBlocksGroup = new THREE.Group();

        // основные структуры
        this.stage = new Stage();
        this.stage.add(this.newBlocksGroup);
        this.stage.add(this.placedBlocksGroup);
        this.stage.add(this.choppedBlocksGroup);

        // массив всех блоков
        this.blocks = [];

        // состояние
        this.state = "READY"; // READY, PLAYING, ENDED
        this.scoreElem.innerHTML = "0";

        // при загрузке создаём начальный блок
        this.addBlock();

        // слушатели на Space и Click
        document.addEventListener('keydown', e => {
          if (e.keyCode==32) this.onAction();
        });
        document.addEventListener('click', e => {
          this.onAction();
        });
        document.addEventListener('touchstart', e => {
          e.preventDefault();
        });

        // запускаем рендер
        this.tick();
      }

      onAction() {
        if (this.state=="READY") {
          // ещё ничего, игра начнётся отдельной кнопкой (мы уже делаем Start).
        } else if (this.state=="PLAYING") {
          this.placeBlock();
        } else if (this.state=="ENDED") {
          // При Game Over написано "Click or spacebar to start again"
          this.restartGame();
        }
      }

      startPlaying() {
        // реальный старт
        this.state="PLAYING";
        this.scoreElem.innerHTML = "0";
      }

      restartGame() {
        // очищаем (как в stack.js)
        this.state="RESETTING";
        let oldBlocks = this.placedBlocksGroup.children;
        let removeSpeed = 0.2;
        let delayAmt = 0.02;
        for (let i=0; i<oldBlocks.length; i++) {
          TweenLite.to(oldBlocks[i].scale, removeSpeed, {
            x:0,y:0,z:0,
            delay: (oldBlocks.length-i)*delayAmt,
            ease: Power1.easeIn,
            onComplete: ()=> this.placedBlocksGroup.remove(oldBlocks[i])
          });
          TweenLite.to(oldBlocks[i].rotation, removeSpeed, {
            y:0.5,
            delay: (oldBlocks.length-i)*delayAmt,
            ease: Power1.easeIn
          });
        }
        let totalDelay = removeSpeed*2 + oldBlocks.length*delayAmt;
        this.blocks=this.blocks.slice(0,1);

        setTimeout(()=>{
          this.scoreElem.innerHTML="0";
          this.state="PLAYING";
          this.addBlock();
        }, totalDelay*1000);
      }

      placeBlock() {
        let currentBlock = this.blocks[this.blocks.length-1];
        let newBlocks = currentBlock.place();
        this.newBlocksGroup.remove(currentBlock.mesh);
        if (newBlocks.placed) this.placedBlocksGroup.add(newBlocks.placed);
        if (newBlocks.chopped) {
          this.choppedBlocksGroup.add(newBlocks.chopped);
          let posParams = {
            y:"-=30", ease: Power1.easeIn,
            onComplete: ()=> this.choppedBlocksGroup.remove(newBlocks.chopped)
          };
          let rotateParams = { delay:0.05, x:0.1, z:0.1, y: Math.random()*0.1 };
          if (newBlocks.plane=="z") rotateParams.x = Math.random()*10 -5;
          if (newBlocks.plane=="x") rotateParams.z = Math.random()*10 -5;

          if (newBlocks.chopped.position[newBlocks.plane]> newBlocks.placed.position[newBlocks.plane]) {
            posParams[newBlocks.plane] = "+=" + 40*Math.abs(newBlocks.direction);
          } else {
            posParams[newBlocks.plane] = "-=" + 40*Math.abs(newBlocks.direction);
          }
          TweenLite.to(newBlocks.chopped.position,1,posParams);
          TweenLite.to(newBlocks.chopped.rotation,1,rotateParams);
        }
        if (currentBlock.state==currentBlock.STATES.MISSED) {
          // Промахнулись
          return this.endGame();
        } else {
          // Иначе ставим новый блок
          this.addBlock();
        }
        this.scoreElem.innerHTML = String(this.blocks.length-1);
      }

      addBlock() {
        let lastBlock = this.blocks[this.blocks.length-1];
        if (lastBlock && lastBlock.state==lastBlock.STATES.MISSED) {
          return this.endGame();
        }
        let newBlock = new Block(lastBlock);
        this.newBlocksGroup.add(newBlock.mesh);
        this.blocks.push(newBlock);
      }

      endGame() {
        this.state="ENDED";
        this.containerElem.classList.add("ended");
      }

      tick() {
        if (this.blocks.length>0) {
          this.blocks[this.blocks.length-1].tick();
        }
        this.stage.render();
        requestAnimationFrame(()=>this.tick());
      }
    }

    // Создаём экземпляр игры
    let stackGame = new StackGame();

    // Функция, которая вызывается, когда мы нажимаем кнопку Start
    function startStackGame() {
      // Убираем класс ready, ставим playing
      containerElem.classList.remove("ready");
      containerElem.classList.add("playing");
      instructionsElem.classList.remove("hide");
      // Сбрасываем игру
      stackGame.restartGame();
      // Переводим game в PLAYING
      stackGame.startPlaying();
      // Ставим gameStartTime
      gameStartTime = performance.now();
      // Показываем timeBarContainer
      document.getElementById('timeBarContainer').style.display = 'block';
    }
  </script>
</body>
</html>

