<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>The Stack Game</title>
  <meta name="viewport" content="width=device-width, user-scalable=no">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- THREE.js и GSAP (для игры The Stack) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js"></script>

  <style>
    /* Общие стили */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #00103c;
      font-family: "Press Start 2P", monospace;
    }
    #container {
      position: relative;
      width: 100%; height: 100%;
    }

    /* Header (Telegram user info, билеты, очки) */
    #header {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 50px;
      background: #6d4fba;
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex; gap: 20px; align-items: center;
      color: #fff; font-size: 10px;
    }
    .balance {
      display: flex; align-items: center; gap: 4px;
    }
    .balance img {
      width: 16px; height: 16px;
    }

    /* Кнопка Back */
    #backContainer {
      position: absolute;
      top: 50px; left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1; color: #262626;
      border: none; border-radius: 4px;
      cursor: pointer; box-shadow: 0 3px #6b6b6b;
    }

    /* Кнопка Start */
    #start-button {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      padding: 10px 20px;
      background: #06B6D1; color: #262626;
      border: none; border-radius: 4px;
      cursor: pointer; box-shadow: 0 3px #6b6b6b;
      z-index: 1100;
    }

    /* Canvas с игрой */
    #game {
      position: absolute;
      top: 0; right: 0; bottom: 0; left: 0;
      display: none;
    }

    /* Счётчик (пиксельный) в углу */
    #pixelScore {
      position: absolute;
      top: 10px; right: 10px;
      font-family: "Press Start 2P", monospace;
      color: #fff;
      font-size: 16px;
      z-index: 1500;
      display: none;
    }

    /* Модальное окно после проигрыша */
    #modalGameOver {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.7);
      z-index: 2000;
      visibility: hidden;
    }
    #modalGameOver.active {
      visibility: visible;
    }
    #modalGameOver .modal-content {
      background: #222;
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 20px;
      width: 80%; max-width: 400px;
      text-align: center;
      color: #FF00FF;
      font-size: 14px;
    }
    #modalGameOver .modal-content button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Header -->
    <div id="header">
      <div id="info">
        <span id="username">@User</span>
        <div class="balance">
          <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
          <span id="ticketCount">0</span>
        </div>
        <div class="balance">
          <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
          <span id="pointCount">0</span>
        </div>
      </div>
    </div>

    <!-- Кнопка Back -->
    <div id="backContainer">
      <button id="backBtn">Back</button>
    </div>

    <!-- Кнопка Start (1 Ticket) -->
    <button id="start-button">Start (1 Ticket)</button>

    <!-- Canvas The Stack -->
    <div id="game"></div>

    <!-- Счётчик (пиксельный) -->
    <div id="pixelScore">0</div>

    <!-- Модальное окно "Game Over" -->
    <div id="modalGameOver">
      <div class="modal-content">
        <h3 id="gameOverTitle">Game Over!</h3>
        <p id="gameOverScore">Your Score: 0</p>
        <button id="gameOverOk">OK</button>
      </div>
    </div>
  </div>

  <!-- Звуки (если нужны) -->
  <audio id="bgSound" src="background.mp3" loop></audio>
  <audio id="moveSound" src="move.mp3"></audio>
  <audio id="deathSound" src="death.mp3"></audio>

  <script>
    /* ----- Firebase и Telegram Setup ----- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);

    let tgApp = null;
    if (window.Telegram && window.Telegram.WebApp) {
      tgApp = window.Telegram.WebApp;
      tgApp.expand();
    }

    let currentUser = null;
    let userRef = null;
    let localUserData = { tickets: 0, points: 0 };
    let dataLoaded = false;

    setTimeout(() => { dataLoaded = true; }, 3000);

    const usernameElem = document.getElementById('username');
    const ticketCountElem = document.getElementById('ticketCount');
    const pointCountElem = document.getElementById('pointCount');

    // Back button
    document.getElementById('backBtn').addEventListener('click', () => {
      window.location.href = 'index.html';
    });

    // Инициализация
    if (tgApp && tgApp.initDataUnsafe && tgApp.initDataUnsafe.user) {
      currentUser = tgApp.initDataUnsafe.user;
      usernameElem.textContent = '@' + currentUser.username;
      userRef = firebase.database().ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', (snapshot) => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    } else {
      // Тест
      currentUser = { username: 'TestUser' };
      usernameElem.textContent = '@TestUser';
      userRef = firebase.database().ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    }

    function updateHeader() {
      ticketCountElem.textContent = localUserData.tickets;
      pointCountElem.textContent = localUserData.points;
    }

    // Модальное окно Game Over
    const modalGameOver = document.getElementById('modalGameOver');
    const gameOverOkBtn = document.getElementById('gameOverOk');
    const gameOverScoreElem = document.getElementById('gameOverScore');
    gameOverOkBtn.addEventListener('click', () => {
      // после проигрыша отправляем на index.html
      window.location.href = 'index.html';
    });

    // Start Button
    const startBtn = document.getElementById('start-button');
    startBtn.addEventListener('click', () => {
      if (!dataLoaded || localUserData.tickets < 1) {
        // нет билетов или ещё данные не загружены
        alert("Not enough tickets or data not loaded yet!"); // или своё модальное окно
        return;
      }
      // списываем билет
      localUserData.tickets--;
      if (userRef) userRef.update({ tickets: localUserData.tickets });
      updateHeader();
      // Запускаем игру
      startStackGame();
    });

    // Фоновая музыка (по желанию)
    document.body.addEventListener('click', () => {
      const bgSound = document.getElementById('bgSound');
      if (bgSound.paused) {
        bgSound.play().catch(err => console.log(err));
      }
    }, { once: true });


    /* ============== САМ STACK ============== */
    class Stage {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor("#D0CBC7", 1);
        document.getElementById("game").appendChild(this.renderer.domElement);
        this.scene = new THREE.Scene();
        let aspect = window.innerWidth / window.innerHeight;
        let d = 20;
        this.camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, -100, 1000);
        this.camera.position.set(2, 2, 2);
        this.camera.lookAt(new THREE.Vector3(0,0,0));

        this.light = new THREE.DirectionalLight(0xffffff, 0.5);
        this.light.position.set(0, 499, 0);
        this.scene.add(this.light);

        this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(this.softLight);

        window.addEventListener('resize', () => this.onResize());
        this.onResize();
      }
      render() {
        this.renderer.render(this.scene, this.camera);
      }
      add(elem) { this.scene.add(elem); }
      remove(elem) { this.scene.remove(elem); }
      onResize() {
        let viewSize = 30;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.left = window.innerWidth / -viewSize;
        this.camera.right = window.innerWidth / viewSize;
        this.camera.top = window.innerHeight / viewSize;
        this.camera.bottom = window.innerHeight / -viewSize;
        this.camera.updateProjectionMatrix();
      }
    }

    class Block {
      constructor(block) {
        this.STATES = { ACTIVE: "active", STOPPED: "stopped", MISSED: "missed" };
        this.MOVE_AMOUNT = 12;
        this.dimension = { width: 0, height: 0, depth: 0 };
        this.position = { x: 0, y: 0, z: 0 };
        this.targetBlock = block;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 ? "x" : "z";
        this.workingDimension = this.index % 2 ? "width" : "depth";

        this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
        this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
        this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
        this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
        this.position.y = this.dimension.height * this.index;
        this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;
        this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random()*100);

        if (!this.targetBlock) {
          this.color = 0x333344;
        } else {
          let offset = this.index + this.colorOffset;
          let r = Math.sin(0.3*offset)*55+200;
          let g = Math.sin(0.3*offset+2)*55+200;
          let b = Math.sin(0.3*offset+4)*55+200;
          this.color = new THREE.Color(r/255, g/255, b/255);
        }

        this.state = (this.index>1)? this.STATES.ACTIVE : this.STATES.STOPPED;
        this.speed = -0.1 - this.index*0.005;
        if (this.speed< -4) this.speed = -4;
        this.direction = this.speed;

        let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width/2,this.dimension.height/2,this.dimension.depth/2));
        this.material = new THREE.MeshToonMaterial({ color: this.color });
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.set(this.position.x,this.position.y,this.position.z);

        if (this.state==this.STATES.ACTIVE) {
          this.position[this.workingPlane] = Math.random()>0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
        }
      }
      reverseDirection() {
        this.direction = this.direction>0 ? this.speed : Math.abs(this.speed);
      }
      place() {
        this.state = this.STATES.STOPPED;
        let overlap = this.targetBlock.dimension[this.workingDimension] -
          Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
        let blocksToReturn = { plane: this.workingPlane, direction: this.direction };

        if (this.dimension[this.workingDimension]-overlap<0.3) {
          overlap = this.dimension[this.workingDimension];
          blocksToReturn.bonus = true;
          this.position.x = this.targetBlock.position.x;
          this.position.z = this.targetBlock.position.z;
          this.dimension.width = this.targetBlock.dimension.width;
          this.dimension.depth = this.targetBlock.dimension.depth;
        }
        if (overlap>0) {
          let choppedDims = {
            width: this.dimension.width, height: this.dimension.height, depth: this.dimension.depth
          };
          choppedDims[this.workingDimension]-=overlap;
          this.dimension[this.workingDimension] = overlap;

          let placedGeometry = new THREE.BoxGeometry(this.dimension.width,this.dimension.height,this.dimension.depth);
          placedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width/2,this.dimension.height/2,this.dimension.depth/2));
          let placedMesh = new THREE.Mesh(placedGeometry,this.material);

          let choppedGeometry = new THREE.BoxGeometry(choppedDims.width,choppedDims.height,choppedDims.depth);
          choppedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(choppedDims.width/2,choppedDims.height/2,choppedDims.depth/2));
          let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);

          let choppedPos = { x:this.position.x, y:this.position.y, z:this.position.z };
          if (this.position[this.workingPlane]< this.targetBlock.position[this.workingPlane]) {
            this.position[this.workingPlane]= this.targetBlock.position[this.workingPlane];
          } else {
            choppedPos[this.workingPlane]+=overlap;
          }
          placedMesh.position.set(this.position.x,this.position.y,this.position.z);
          choppedMesh.position.set(choppedPos.x,choppedPos.y,choppedPos.z);
          blocksToReturn.placed = placedMesh;
          if (!blocksToReturn.bonus) blocksToReturn.chopped = choppedMesh;
        } else {
          this.state = this.STATES.MISSED;
        }
        this.dimension[this.workingDimension] = overlap;
        return blocksToReturn;
      }
      tick() {
        if (this.state==this.STATES.ACTIVE) {
          let val = this.position[this.workingPlane];
          if (val> this.MOVE_AMOUNT || val< -this.MOVE_AMOUNT) this.reverseDirection();
          this.position[this.workingPlane]+=this.direction;
          this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
        }
      }
    }

    class StackGame {
      constructor() {
        this.stage = new Stage();
        this.newBlocksGroup = new THREE.Group();
        this.placedBlocksGroup = new THREE.Group();
        this.choppedBlocksGroup = new THREE.Group();
        this.stage.add(this.newBlocksGroup);
        this.stage.add(this.placedBlocksGroup);
        this.stage.add(this.choppedBlocksGroup);
        this.blocks=[];
        this.state="READY";
        this.score=0;
        this.pixelScoreElem = document.getElementById('pixelScore');
        this.pixelScoreElem.innerHTML="0";

        this.addBlock();
        this.tick();

        document.addEventListener('keydown', e => {
          if (e.keyCode==32) this.onAction();
        });
        document.addEventListener('click', e => {
          this.onAction();
        });
      }
      onAction() {
        if (this.state=="PLAYING") {
          this.placeBlock();
        } else if (this.state=="ENDED") {
          // уже end
        }
      }
      startGame() {
        this.state="PLAYING";
        this.score=0;
        this.pixelScoreElem.innerHTML="0";
      }
      placeBlock() {
        let currentBlock = this.blocks[this.blocks.length-1];
        let result = currentBlock.place();
        this.newBlocksGroup.remove(currentBlock.mesh);
        if (result.placed) this.placedBlocksGroup.add(result.placed);
        if (result.chopped) {
          this.choppedBlocksGroup.add(result.chopped);
          let posParams={ y:"-=30", ease:Power1.easeIn, onComplete:()=>this.choppedBlocksGroup.remove(result.chopped) };
          let rotateParams={ delay:0.05, x:0.1, z:0.1, y:Math.random()*0.1 };
          if (result.plane=="z") rotateParams.x=Math.random()*10-5;
          if (result.plane=="x") rotateParams.z=Math.random()*10-5;
          if (result.chopped.position[result.plane]> result.placed.position[result.plane]) {
            posParams[result.plane] = "+="+40*Math.abs(result.direction);
          } else {
            posParams[result.plane] = "-="+40*Math.abs(result.direction);
          }
          TweenLite.to(result.chopped.position,1,posParams);
          TweenLite.to(result.chopped.rotation,1,rotateParams);
        }
        if (currentBlock.state==currentBlock.STATES.MISSED) {
          this.endGame();
        } else {
          this.addBlock();
          this.score++;
          this.pixelScoreElem.innerHTML= String(this.score);
        }
      }
      addBlock() {
        let lastBlock = this.blocks[this.blocks.length-1];
        if (lastBlock && lastBlock.state==lastBlock.STATES.MISSED) {
          return this.endGame();
        }
        let newBlock = new Block(lastBlock);
        this.newBlocksGroup.add(newBlock.mesh);
        this.blocks.push(newBlock);
      }
      endGame() {
        this.state="ENDED";
        // Запишем очки в Firebase
        localUserData.points += this.score;
        if (userRef) userRef.update({ points: localUserData.points });
        // Включаем модальное окно
        document.getElementById('gameOverScore').textContent = "Your score: "+this.score;
        document.getElementById('modalGameOver').classList.add('active');
        // Звук смерти
        const deathSound = document.getElementById('deathSound');
        deathSound.play().catch(err=>console.log(err));
      }
      restartGame() {
        // если хотим
      }
      tick() {
        if (this.blocks.length>0) {
          this.blocks[this.blocks.length-1].tick();
        }
        this.stage.render();
        requestAnimationFrame(()=>this.tick());
      }
    }

    let stackGame = null;

    function startStackGame() {
      // Скрываем header, back, start
      document.getElementById('header').style.display='none';
      document.getElementById('backContainer').style.display='none';
      document.getElementById('start-button').style.display='none';
      // Показываем canvas игры, счёт
      document.getElementById('game').style.display='block';
      document.getElementById('pixelScore').style.display='block';
      // Создаем игру, запускаем
      stackGame = new StackGame();
      stackGame.startGame();
    }

    // Фоновая музыка (один раз)
    document.body.addEventListener('click', () => {
      const bg = document.getElementById('bgSound');
      if (bg.paused) {
        bg.play().catch(err=>console.log(err));
      }
    }, { once:true });
  </script>
</body>
</html>
