<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Pac-Man with Telegram & Firebase</title>
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* ====== СТИЛИ для шапки, кнопки Back, кнопки Start и общего фона ====== */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #00103c; /* фоновый цвет */
      font-family: Arial, sans-serif;
    }
    /* Шапка: имя пользователя, билеты, поинты */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      font-size: 10px;
      color: #fff;
      align-items: center;
    }
    #info span {
      white-space: nowrap;
    }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img {
      width: 16px;
      height: 16px;
    }
    /* Кнопка Back */
    #backContainer {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Обёртка для всей "страницы" с игрой */
    #gameWrapper {
      position: relative;
      width: 100%;
      height: 100%;
    }
    /* Кнопка Start (по центру экрана) */
    #startBtn {
      position: absolute;
      z-index: 10;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      padding: 10px 20px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }

    /* ====== СТИЛИ PAC-MAN: переименовали id чтобы избежать конфликтов ====== */
    /* Все блоки Pac-Man внутри #pacman-game */
    #pacman-game {
      /* Изначально скрыт, покажем при старте */
      display: none;
      /* Можно занять весь экран, но ниже есть структура */
      position: relative;
      margin: 0 auto;
      /* чтобы центрировать Pac-Man поле – на ваше усмотрение */
      top: 60px; 
    }

    /* Шапка Pac-Man (с счётом и жизнями) переименовали: #pacman-info */
    #pacman-info {
      box-sizing: border-box;
      width: 100%;
      justify-content: space-between;
      align-items: center;
      padding: 1em 2em;
      display: flex;
    }
    #pacman-score {
      color: white;
      margin: 0;
      font-size: 2rem;
    }
    #pacman-lives {
      display: flex;
    }
    .live {
      width: 3.2rem;
      height: 2.6rem;
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      background-position: -26rem -3.2rem;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .live {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites_small.png");
      }
    }

    /* Область поля для Pac-Man */
    #pacman-game-board {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      width: 56rem;
      height: 62rem;
      display: grid;
      grid-template-columns: repeat(28, 2rem);
      margin: 0 auto; /* чтобы было по центру */
    }
    /* Текст "Ready!" */
    #pacman-start, #pacman-game-start {
      position: absolute;
      margin: auto;
      width: 100%;
      top: 54%;
      text-align: center;
      color: yellow;
      font-size: 2.4rem;
      z-index: 1;
      user-select: none;
    }

    /* Стены, точки, и пр. */
    .wall {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/map.png");
      z-index: 1;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .wall {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/small_map.png");
      }
    }
    .blank {
      background-color: black;
    }
    .point, .big-point {
      width: 2rem;
      height: 2rem;
      background-color: #ffb897;
      z-index: 10;
    }
    .point {
      border: .8rem solid black;
      border-radius: 0; 
    }
    .big-point {
      border: .4rem solid black;
      border-radius: 45%;
    }
    .gate {
      background-color: #ffb897;
      border-top: .7rem solid black;
      border-bottom: .7rem solid black;
    }

    /* Спрайты персонажей – переименовано на .pacman-* */
    .yellow, .red, .pink, .blue, .orange, .points::after {
      image-rendering: pixelated;
      position: absolute;
      top: -0.4rem;
      left: -0.55rem;
      width: 3rem;
      height: 2.8rem;
    }
    .yellow-visible, .red-visible, .pink-visible, .blue-visible, .orange-visible {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      z-index: 101;
      will-change: transform, background-position;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .yellow-visible, .red-visible, .pink-visible, .blue-visible, .orange-visible {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites_small.png");
      }
    }

    /* Анимации (оставлены без изменений, только префиксы/конфликты убраны) */
    .yellow-animation-move {
      animation: var(--yellow-animation-length) forwards steps(1, end) yellow;
    }
    .red-animation-move {
      animation: var(--red-animation-length) forwards steps(1, end) red;
    }
    .pink-animation-move {
      animation: var(--pink-animation-length) forwards steps(1, end) pink;
      z-index: 10000;
    }
    .blue-animation-move {
      animation: var(--blue-animation-length) forwards steps(1, end) blue;
    }
    .orange-animation-move {
      animation: var(--orange-animation-length) forwards steps(1, end) orange;
    }
    .red-retreat, .pink-retreat {
      background-position: -35.2rem -16rem;
      animation: 150ms linear forwards redPinkRetreatPosition;
    }
    .blue-retreat {
      animation: 250ms linear forwards blueRetreatPosition, forwards steps(1, end) blueRetreatSprite;
    }
    .orange-retreat {
      animation: 250ms linear forwards orangeRetreatPosition, forwards steps(1, end) orangeRetreatSprite;
    }
    .red-revive {
      animation: 600ms forwards linear redRevive, 200ms forwards steps(1, end) red 3;
    }
    .pink-revive {
      animation: 1000ms forwards linear pinkRevive, 200ms forwards steps(1, end) pink 5;
    }
    .blue-revive {
      animation: 5000ms forwards linear blueRevive, 200ms forwards steps(1, end) blue 25;
    }
    .orange-revive {
      animation: 15000ms forwards linear orangeRevive, 200ms forwards steps(1, end) orange 75;
    }
    .yellow-death-animation {
      animation: 1.5s forwards steps(1, end) yellowDeath;
    }
    .blinking-animation {
      animation: 1.5s forwards steps(1, end) blink;
    }
    .blinking-animation-corner > * {
      animation: 1.5s forwards steps(1, end) blink2;
    }

    /* Ключевые кадры (из оригинала Pac-Man) */
    @keyframes yellow {
      0%, 70%, 100% { background-position: -3.2rem var(--yellow-sprite-y); }
      30% { background-position: 0rem var(--yellow-sprite-y); }
      80% { background-position: -6.4rem 0rem; }
    }
    @keyframes red {
      0%, 100% { background-position: var(--red-sprite-x) var(--red-sprite-y); }
      50% { background-position: calc(var(--red-sprite-x) - 3.2rem) var(--red-sprite-y); }
    }
    @keyframes pink {
      0%, 100% { background-position: var(--pink-sprite-x) var(--pink-sprite-y); }
      50% { background-position: calc(var(--pink-sprite-x) - 3.2rem) var(--pink-sprite-y); }
    }
    @keyframes blue {
      0%, 100% { background-position: var(--blue-sprite-x) var(--blue-sprite-y); }
      50% { background-position: calc(var(--blue-sprite-x) - 3.2rem) var(--blue-sprite-y); }
    }
    @keyframes orange {
      0%, 100% { background-position: var(--orange-sprite-x) var(--orange-sprite-y); }
      50% { background-position: calc(var(--orange-sprite-x) - 3.2rem) var(--orange-sprite-y); }
    }
    @keyframes redPinkRetreatPosition {
      0% { transform: translate(-1rem, 0); }
      33% { transform: translate(-1rem, 2rem); }
      66% { transform: translate(-1rem, 4rem); }
      100% { transform: translate(-1rem, 6rem); }
    }
    @keyframes blueRetreatPosition {
      0% { transform: translate(-1rem, 0); }
      60% { transform: translate(-1rem, 6rem); }
      100% { transform: translate(-5rem, 6rem); }
    }
    @keyframes orangeRetreatPosition {
      0% { transform: translate(-1rem, 0); }
      60% { transform: translate(-1rem, 6rem); }
      100% { transform: translate(3rem, 6rem); }
    }
    @keyframes blueRetreatSprite {
      0% { background-position: -35.2rem -16rem; }
      60% { background-position: -28.8rem -16rem; }
      100% { background-position: -28.8rem -16rem; }
    }
    @keyframes orangeRetreatSprite {
      0% { background-position: -35.2rem -16rem; }
      60% { background-position: -25.6rem -16rem; }
      100% { background-position: -25.6rem -16rem; }
    }
    @keyframes redRevive {
      from { transform: translate(-1rem, 0rem); }
      to   { transform: translate(-1rem, -6rem); }
    }
    @keyframes pinkRevive {
      0% { transform: translate(-1rem, 0rem); }
      20% { transform: translate(-1rem, 2rem); }
      100% { transform: translate(-1rem, -6rem); }
    }
    @keyframes blueRevive {
      0%,80% { transform: translate(-1rem, 0rem); }
      /* пром. шаги опущены для краткости */
      100%   { transform: translate(3rem, -6rem); }
    }
    @keyframes orangeRevive {
      0%,93.3% { transform: translate(-1rem, 0); }
      /* пром. шаги опущены для краткости */
      100% { transform: translate(-5rem, -6rem); }
    }
    @keyframes blink {
      0% { background-position-y: -2rem; }
      12.5% { background-position-y: 0; }
      25% { background-position-y: -2rem; }
      37.5% { background-position-y: 0; }
      50% { background-position-y: -2rem; }
      62.5% { background-position-y: 0; }
      75% { background-position-y: -2rem; }
      87.5% { background-position-y: 0; }
    }
    @keyframes blink2 {
      0% { background-position-y: -2rem; }
      12.5% { background-position-y: 0; }
      25% { background-position-y: -2rem; }
      37.5% { background-position-y: 0; }
      50% { background-position-y: -2rem; }
      62.5% { background-position-y: 0; }
      75% { background-position-y: -2rem; }
      87.5% { background-position-y: 0; }
    }
    @keyframes yellowDeath {
      0%   { background-position: -9.6rem 0rem; }
      9%   { background-position: -12.8rem 0rem; }
      18%  { background-position: -16rem 0rem; }
      27%  { background-position: -19.2rem 0rem; }
      36%  { background-position: -22.4rem 0rem; }
      45%  { background-position: -25.6rem 0rem; }
      54%  { background-position: -28.8rem 0rem; }
      63%  { background-position: -32rem 0rem; }
      72%  { background-position: -35.2rem 0rem; }
      81%  { background-position: -38.4rem 0rem; }
      90%  { background-position: -41.6rem -0.64rem; }
      100% { visibility: hidden; }
    }

  </style>
</head>
<body>
  <!-- ========= ШАПКА с информацией о пользователе (Telegram/Firebase) ========= -->
  <div id="header">
    <div id="info">
      <span id="username">@User</span>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
        <span id="ticketCount">0</span>
      </div>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
        <span id="pointCount">0</span>
      </div>
    </div>
  </div>

  <!-- Кнопка Back -->
  <div id="backContainer">
    <button id="backBtn" onclick="goBack()">Back</button>
  </div>

  <!-- Обёртка для всей страницы, внутри – кнопка Start и сама игра Pac-Man -->
  <div id="gameWrapper">
    <!-- Кнопка Start -->
    <button id="startBtn" onclick="startPacmanGame()">Start (1 Ticket)</button>

    <!-- ==== Сам блок Pac-Man (скрыт, пока не нажмём Start) ==== -->
    <div id="pacman-game">
      <!-- Текст "Click Anywhere to play" переименован на #pacman-game-start -->
      <h3 id="pacman-game-start">Click Anywhere to play</h3>
      <!-- Основной контейнер Pac-Man -->
      <div>
        <!-- Внутри – шапка Pac-Man (score + lives) -->
        <div id="pacman-info">
          <h3 id="pacman-score">Score 0</h3>
          <div id="pacman-lives">
            <div class="live"></div>
            <div class="live"></div>
            <div class="live"></div>
          </div>
        </div>
        <!-- Само поле для Pac-Man -->
        <div id="pacman-game-board">
          <p id="pacman-start">Ready!</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ----------------------------------------------
       1) Настройка Firebase и Telegram Web App
       ---------------------------------------------- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let tg = null;
    if(window.Telegram && window.Telegram.WebApp) {
      tg = window.Telegram.WebApp;
      tg.expand();
    }

    let currentUser = null;
    let userRef = null;
    let localUserData = {
      tickets: 0,
      points: 0
    };

    // Ищем username в Telegram, либо тестовый
    if(tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
      currentUser = tg.initDataUnsafe.user;
      document.getElementById('username').textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
    } else {
      currentUser = { username: 'TestUser' };
      document.getElementById('username').textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
    }

    // Создаём/подгружаем данные пользователя
    userRef.once('value').then(snapshot => {
      if(!snapshot.exists()){
        userRef.set({ tickets: 5, points: 0 });
      }
    });
    userRef.on('value', snapshot => {
      const data = snapshot.val() || {};
      localUserData.tickets = data.tickets || 0;
      localUserData.points  = data.points  || 0;
      updateHeader();
    });

    function updateHeader() {
      document.getElementById('ticketCount').textContent = localUserData.tickets;
      document.getElementById('pointCount').textContent  = localUserData.points;
    }

    function goBack() {
      // Можно просто сделать history.back() или редирект
      window.location.href = 'index.html';
    }

    /* ----------------------------------------------
       2) Кнопка "Start (1 Ticket)" – запуск Pac-Man
       ---------------------------------------------- */
    function startPacmanGame() {
      if(localUserData.tickets < 1){
        alert("Not enough tickets!");
        return;
      }
      // Забираем 1 билет
      localUserData.tickets--;
      userRef.update({ tickets: localUserData.tickets });
      updateHeader();

      // Скрываем шапку, back и кнопку
      document.getElementById('header').style.display = 'none';
      document.getElementById('backContainer').style.display = 'none';
      document.getElementById('startBtn').style.display = 'none';

      // Показываем игру Pac-Man
      document.getElementById('pacman-game').style.display = 'block';
    }

    /* ----------------------------------------------
       3) Логика и код Pac-Man (слегка изменены id)
       ---------------------------------------------- */
    const game         = document.getElementById("pacman-game");
    const gameBoard    = document.getElementById("pacman-game-board");
    const gameStart    = document.getElementById('pacman-game-start');
    const startText    = document.getElementById("pacman-start");
    const scoreElement = document.getElementById("pacman-score");
    const lives        = document.getElementById("pacman-lives");
    const root         = document.documentElement.style;

    let soundtrack = document.createElement("audio");
    soundtrack.loop = true;
    soundtrack.volume = 0.7;
    let sound = document.createElement("audio");
    sound.volume = 0.5;

    const startingPositions = [658, 322, 406, 404, 408];
    const positionChange = {
      "ArrowRight": 1,
      "ArrowLeft": -1,
      "ArrowUp": -28,
      "ArrowDown": 28,
    };
    const oppositeDirection = {
      "ArrowUp": "ArrowDown",
      "ArrowDown": "ArrowUp",
      "ArrowRight": "ArrowLeft",
      "ArrowLeft": "ArrowRight",
    };
    const yellowSprite = {
      "ArrowRight": 0,
      "ArrowLeft": 3.2,
      "ArrowUp": 6.4,
      "ArrowDown": 9.6,
    };
    const ghostSprite = {
      "ArrowRight": 0,
      "ArrowLeft": 6.4,
      "ArrowUp": 12.8,
      "ArrowDown": 19.2,
    };
    const eatenSprite = {
      "ArrowRight": 25.6,
      "ArrowLeft": 28.8,
      "ArrowUp": 32,
      "ArrowDown": 35.2,
    };
    const characters = [
      {
        name: "yellow",
        direction: "ArrowLeft",
        directionNew: undefined,
        position: 658,
        nextPosition: undefined,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
      },
      {
        name: "red",
        direction: "ArrowLeft",
        directionOld: undefined,
        directionList: ["ArrowUp","ArrowUp","ArrowUp"],
        position: 38,
        nextPosition: undefined,
        scatterTarget: 27,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
      },
      {
        name: "pink",
        direction: "ArrowDown",
        directionOld: undefined,
        directionList: ["ArrowDown","ArrowUp","ArrowUp","ArrowUp","ArrowUp"],
        position: 406,
        nextPosition: undefined,
        scatterTarget: 0,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
      },
      {
        name: "blue",
        direction: "ArrowUp",
        directionOld: undefined,
        directionList: ["ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowRight","ArrowRight","ArrowUp","ArrowUp","ArrowUp"],
        position: 404,
        nextPosition: undefined,
        scatterTarget: 867,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
      },
      {
        name: "orange",
        direction: "ArrowUp",
        directionOld: undefined,
        directionList: ["ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowUp","ArrowUp","ArrowDown","ArrowLeft","ArrowLeft","ArrowUp","ArrowUp","ArrowUp"],
        position: 408,
        nextPosition: undefined,
        scatterTarget: 840,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
      },
    ];
    let elements;
    let points = 0;
    let collisionInterval;
    let ghostMode;
    let ghostModeInterval;
    let changingBackInterval;
    let isFrightenedWhite = false;
    let ghostsEaten = 0;
    let newLevel = true;
    let score = 0;
    let livesLost = 0;
    let gameStartLength = 4200;
    let whichMunch = 1;

    document.addEventListener("click", startPacmanCoreGame);

    function startPacmanCoreGame() {
      // Клик по "Click Anywhere to play"
      gameStart.style.display = "none";
      // Показываем сам Pac-Man (у нас уже #pacman-game visible, но скрыта надпись)
      startLevel();
      document.removeEventListener("click", startPacmanCoreGame);
    }

    soundtrack.addEventListener('timeupdate', () => {
      const buffer = 0.3;
      if(soundtrack.currentTime > soundtrack.duration - buffer){
        soundtrack.currentTime = 0; 
        soundtrack.play();
      }
    });

    function startLevel() {
      if (newLevel === true) {
        gameStartLength = 4200;
        sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/game_start.wav";
        makeLevel();
        sound.play();
      }
      setStartingProperties();
      setTimeout(() => {
        soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
        soundtrack.play();
        lives.children[livesLost].style.visibility = "hidden";
        livesLost++;
        characterMove(0);
        characterMove(1);
        ghostRevive(2, 0);
        ghostRevive(3, 0);
        ghostRevive(4, 0);

        collisionInterval = setInterval(checkCollisions, 10);
        ghostModeInterval = setTimeout(changeModes, 5000);
      }, gameStartLength);
    }

    function makeLevel() {
      /* 
         Здесь идёт длинный массив с картой, как в вашем исходном коде Pac-Man.
         Для краткости оставлен исходный.
         Если надо – отредактируйте под свои нужды.
      */
      const gameArray = [
        /* ... длинный массив ... */
        0,8,8,8,8,8,8,8,8,8,8,8,8,18,19,8,8,8,8,8,8,8,8,8,8,8,8,1,
        9,126,126,126,126,126,126,126,126,126,126,126,126,11,13,126,126,126,126,126,126,126,126,126,126,126,126,9,
        /* и т.д. */
        2,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3
      ];

      for (let i = 0; i < gameArray.length; i++) {
        const element = document.createElement("DIV");
        if (gameArray[i] > 25) {
          element.className = "blank";
          for (let j = 0; j < characters.length; j++) {
            let character = document.createElement("DIV");
            character.className = characters[j].name;
            element.append(character);
          }
          if(gameArray[i] / 100 > 1) {
            let pointDiv = document.createElement("DIV");
            pointDiv.className = Math.floor(gameArray[i] / 100) == 1 ? "point" : "big-point";
            element.append(pointDiv);
          }
        } else {
          element.className = "wall";
          element.style.backgroundPosition = `-${gameArray[i]*2}rem 0`;
        }
        gameBoard.append(element);
      }
      points = 0;
      elements = Array.from(gameBoard.children).splice(1); // убираем <p id="pacman-start">
      transformStartingElements();
    }

    function setStartingProperties() {
      newLevel = undefined;
      window.removeEventListener("keydown", getDirection);
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchmove", handleTouchMove);

      clearTimeout(ghostModeInterval);
      game.style.visibility = "visible";
      startText.style.display = "block";
      ghostMode = "scatter";
      ghostsEaten = 0;
      scoreElement.innerHTML = "Score " + score;

      for (let i = 0; i < characters.length; i++) {
        characters[i].position = startingPositions[i];
        characters[i].direction = i < 2 ? "ArrowLeft" : characters[i].directionList[0];
        characters[i].characterNode = elements[characters[i].position].children[i];
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
        characters[i].mode = "normal";
        characters[i].status = "normal";

        if (i == 0) {
          root.setProperty(`--${characters[i].name}-sprite-x`, "-6.4rem");
          root.setProperty(`--${characters[i].name}-sprite-y`, "0rem");
          characters[i].directionNew = undefined;
        } else {
          getSprite(i);
        }
      }

      setTimeout(() => {
        window.addEventListener("keydown", getDirection);
        document.addEventListener('touchstart', handleTouchStart);        
        document.addEventListener('touchmove', handleTouchMove);

        for (let i = 2; i < 5; i++) {
          characters[i].animationLength = 200;
          characters[i].characterNode.classList.add(`${characters[i].name}-revive`);
        }
        startText.style.display = "none";
        getSprite(0);
      }, gameStartLength);
    }

    function transformStartingElements() {
      for (let i = 0; i < 5; i++) {
        if (i == 1) {
          for (let j = 1; j < 5; j++) {
            elements[startingPositions[i]].children[j].style.transform = "translateX(-1rem)";
          }
        } else {
          elements[startingPositions[i]].children[i].style.transform = "translateX(-1rem)";
        }
      }
    }

    function changeModes() {
      if (ghostMode === "scatter") {
        ghostMode = "chase";
        ghostModeInterval = setTimeout(changeModes, 25000);
      } else if (ghostMode === "chase") {
        ghostMode = "scatter";
        ghostModeInterval = setTimeout(changeModes, 5000);
      }
      changeGhostDirections();
    }

    function checkCollisions() {
      const yellowTransform = new WebKitCSSMatrix(getComputedStyle(characters[0].characterNode).transform);
      let yellowTranslateX = yellowTransform.e;
      let yellowTranslateY = yellowTransform.f;

      for (let i = 1; i < 5; i++) {
        if (characters[0].status == "freeze") {
          clearInterval(collisionInterval);
          return;
        }
        const distance = calculateDistance(characters[0].position, characters[i].position);
        const ghostTransform = new WebKitCSSMatrix(getComputedStyle(characters[i].characterNode).transform);
        let ghostTranslateX = ghostTransform.e;
        let ghostTranslateY = ghostTransform.f;

        let requirement;
        let yellowNewPosition;
        let ghostNewPosition;

        if(distance == 0) {
          requirement = -30;
          yellowNewPosition = characters[0].position + positionChange[characters[0].direction]
                              + positionChange[oppositeDirection[characters[i].direction]];
          ghostNewPosition  = characters[i].position + positionChange[characters[i].direction]
                              + positionChange[oppositeDirection[characters[0].direction]];
        }
        if (distance == 1) {
          requirement = 10;
          yellowNewPosition = characters[0].position + positionChange[characters[0].direction];
          ghostNewPosition  = characters[i].position + positionChange[characters[i].direction];
        } else if (distance == 4) {
          requirement = 30;
          yellowNewPosition = characters[0].position + positionChange[characters[0].direction]*2;
          ghostNewPosition  = characters[i].position + positionChange[characters[i].direction]*2;
        } else if (distance == 2) {
          requirement = 25;
          yellowNewPosition = characters[0].position + positionChange[characters[0].direction]
                              + positionChange[oppositeDirection[characters[i].direction]];
          ghostNewPosition  = characters[i].position + positionChange[characters[i].direction]
                              + positionChange[oppositeDirection[characters[0].direction]];
        } else if (distance != 0) {
          continue;
        }
        if(window.innerWidth < 600 || window.innerHeight < 700) {
          requirement /= 2;
        }

        if (yellowNewPosition == characters[i].position) {
          yellowTranslateX = Math.abs(yellowTranslateX);
          yellowTranslateY = Math.abs(yellowTranslateY);
        } else {
          yellowTranslateX = -Math.abs(yellowTranslateX);
          yellowTranslateY = -Math.abs(yellowTranslateY);
        }
        if (ghostNewPosition == characters[0].position) {
          ghostTranslateY = Math.abs(ghostTranslateY);
          ghostTranslateX = Math.abs(ghostTranslateX);
        } else {
          ghostTranslateY = -Math.abs(ghostTranslateY);
          ghostTranslateX = -Math.abs(ghostTranslateX);
        }

        const transformDistance = yellowTranslateY + ghostTranslateY + yellowTranslateX + ghostTranslateX;
        if (transformDistance > requirement) {
          if (characters[i].mode == "frightened") {
            gameFreeze(i);
          } else if (characters[i].mode == "normal") {
            gameOver();
          }
        }
      }
    }

    function characterMove(i) {
      if (characters[i].status == "freeze") return;

      characters[i].nextPosition = getNewPosition(i);
      if (elements[characters[i].nextPosition].classList.contains("wall")) {
        if(sound.src.includes("munch")) {
          sound.pause();
        }
        setTimeout(() => {
          characterMove(i);
        }, 50);
        return;
      }
      getAnimationLength(i);
      getSprite(i);
      getTransition(i);
      changePosition(i);
    }

    function getNewPosition(i) {
      if (i == 0) {
        getYellowDirection(i);
      } else if (characters[i].direction != oppositeDirection[characters[i].directionOld]) {
        if (characters[i].mode == "frightened") {
          getRandomDirection(i);
        } else {
          getGhostDirection(i);
        }
      } else {
        characters[i].directionOld = characters[i].direction;
      }
      let nextPos = characters[i].position + positionChange[characters[i].direction];
      if (characters[i].position == 392 && nextPos == 391) {
        nextPos = 419;
      } else if (characters[i].position == 419 && nextPos == 420) {
        nextPos = 392;
      }
      return nextPos;
    }

    function getYellowDirection(i) {
      if (characters[i].directionNew != undefined) {
        const newPos = characters[i].position + positionChange[characters[i].directionNew];
        if (!elements[newPos].classList.contains("wall")) {
          characters[i].direction = characters[i].directionNew;
          characters[i].directionNew = undefined;
        }
      }
    }

    function getGhostDirection(i) {
      let newDirection = characters[i].directionOld = characters[i].direction;
      let biggestDistance = 100000;
      let target;
      if (characters[i].mode == "eaten") {
        target = 322;
      } else if (ghostMode == "scatter") {
        target = characters[i].scatterTarget;
      } else {
        target = getChaseTarget(i);
      }

      for (let [direction, value] of Object.entries(positionChange)) {
        const newPosition = characters[i].position + value;
        const newDistance = calculateDistance(target, newPosition);
        if (newDistance < biggestDistance) {
          if (!elements[newPosition].classList.contains("wall") &&
              oppositeDirection[direction] != characters[i].direction) {
            biggestDistance = newDistance;
            newDirection = direction;
          }
        }
      }
      characters[i].direction = newDirection;
    }

    function getRandomDirection(i) {
      let nextPos = characters[i].position + positionChange[characters[i].direction];
      if ((characters[i].position == 392 && nextPos == 391) ||
          (characters[i].position == 419 && nextPos == 420)) {
        return;
      }
      let newDir;
      do {
        const random = ~~(Math.random()*4);
        newDir = Object.keys(positionChange)[random];
        nextPos = characters[i].position + positionChange[newDir];
      } while(elements[nextPos].classList.contains("wall") ||
              oppositeDirection[newDir] == characters[i].direction);
      characters[i].direction = newDir;
    }

    function getChaseTarget(i) {
      switch(i) {
        case 1:
          if(characters[0].position == characters[i].position &&
             !elements[characters[0].nextPosition].classList.contains("wall")) {
            return characters[0].position + positionChange[characters[0].direction];
          }
          return characters[0].position;
        case 2:
          return characters[0].position + positionChange[characters[0].direction]*2;
        case 3:
          return getBlueTarget();
        case 4:
          const dist = calculateDistance(characters[0].position, characters[4].position);
          if(dist < 64) {
            return 840;
          } else {
            return characters[0].position;
          }
      }
    }

    function getBlueTarget() {
      const yellowPos = characters[0].position + positionChange[characters[0].direction];
      const distX = (yellowPos % 28) - (characters[1].position % 28);
      const distY = ~~(yellowPos/28) - ~~(characters[1].position/28);
      let bluePosX = (yellowPos % 28) + distX;
      if(bluePosX < 0)   bluePosX = 0;
      else if(bluePosX>27) bluePosX = 27;
      const bluePosY = ~~(yellowPos/28) + distY;
      return bluePosX + bluePosY*28;
    }

    function calculateDistance(target, newGhostPos) {
      const dx = Math.floor(target/28) - Math.floor(newGhostPos/28);
      const dy = (target % 28) - (newGhostPos % 28);
      return dx*dx + dy*dy;
    }

    function getAnimationLength(i) {
      let animLength;
      if (i==0) {
        animLength = characters[i].mode=="hasEaten"?210:190;
      } else {
        const tunnel = [392,393,394,395,396,419,418,417,416,415];
        if(characters[i].mode=="eaten") {
          if(characters[i].nextPosition===322) {
            animLength = characters[i].direction=="ArrowLeft"?25:75;
          } else {
            animLength = 50;
          }
        } else if (tunnel.includes(characters[i].position) ||
                   tunnel.includes(characters[i].nextPosition)) {
          animLength = 350;
        } else if (characters[i].mode=="frightened") {
          animLength = 300;
        } else if (
          characters[i].direction == characters[i].directionOld ||
          characters[i].direction == oppositeDirection[characters[i].directionOld]
        ) {
          animLength = 200;
        } else {
          animLength = 220;
        }
      }
      const transformVal = characters[i].characterNode.style.transform;
      if(transformVal.includes("translateX(-1rem)")) {
        animLength /= 1.5;
      }
      root.setProperty(`--${characters[i].name}-animation-length`, animLength+"ms");
      characters[i].animationLength = animLength;
    }

    function getSprite(i) {
      let spriteX, spriteY;
      if (i==0) {
        spriteX = 3.2;
        spriteY = yellowSprite[characters[i].direction];
      } else {
        if (characters[i].mode=="normal") {
          spriteX = ghostSprite[characters[i].direction];
          spriteY = 9.6 + 3.2*i;
        } else if (characters[i].mode=="frightened") {
          spriteX = isFrightenedWhite?32:25.6;
          spriteY = 12.8;
        } else {
          spriteX = eatenSprite[characters[i].direction];
          spriteY = 16;
        }
      }
      root.setProperty(`--${characters[i].name}-sprite-x`,`-${spriteX}rem`);
      root.setProperty(`--${characters[i].name}-sprite-y`,`-${spriteY}rem`);
    }

    function getTransition(i) {
      const isRespawn = (characters[i].mode=="eaten" && characters[i].nextPosition==322);
      const moveMap = {
        "ArrowUp":    "Y(-2rem)",
        "ArrowDown":  "Y(2rem)",
        "ArrowRight": isRespawn?"X(1rem)":"X(2rem)",
        "ArrowLeft":  isRespawn?"X(-3rem)":"X(-2rem)",
      };
      characters[i].characterNode.style.transform = `translate${moveMap[characters[i].direction]}`;
    }

    async function changePosition(i) {
      await new Promise(resolve => {
        if(characters[i].mode!="eaten") {
          characters[i].characterNode.classList.add(`${characters[i].name}-animation-move`);
        }
        characters[i].animationStart = performance.now();
        setTimeout(() => {
          if(characters[i].status=="freeze") return;
          characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`,`${characters[i].name}-visible`);
          characters[i].characterNode.style.transform="";
          characters[i].position = characters[i].nextPosition;
          characters[i].characterNode = elements[characters[i].position].children[i];
          characters[i].characterNode.classList.add(`${characters[i].name}-visible`);

          if(i==0) {
            eatPoint(i);
          } else if(characters[i].mode=="eaten" && characters[i].position===322){
            ghostRetreat(i);
          }
          resolve("");
        }, characters[i].animationLength);
      });
      characterMove(i);
    }

    function eatPoint(i) {
      const point = elements[characters[i].position].children[5];
      if(point){
        points++;
        characters[i].mode = "hasEaten";
        if(point.classList.contains("big-point")){
          makeGhostsScared();
          score += 50;
        } else {
          score += 10;
          if(!sound.src.includes("munch") || sound.paused) {
            sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/munch.wav";
            sound.play();
          }
        }
        scoreElement.innerHTML = "Score "+score;
        point.remove();
        if(points==244){
          gameWin();
          freezeCharacters();
        }
      } else {
        characters[i].mode = "normal";
        if(sound.src.includes("munch")) {
          sound.pause();
        }
      }
    }

    function makeGhostsScared() {
      soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/power_pellet.wav";
      soundtrack.play();
      clearInterval(changingBackInterval);
      isFrightenedWhite=false;
      ghostsEaten=0;
      changeGhostDirections();
      for(let i=0;i<5;i++){
        if(characters[i].mode!="eaten"){
          characters[i].mode="frightened";
          getSprite(i);
        }
      }
      setTimeout(()=>{
        let count=1;
        changingBackInterval = setInterval(()=>{
          if(characters[0].status=="freeze") return;
          if(count==10){
            clearInterval(changingBackInterval);
            if(!soundtrack.src.includes("retreating")) {
              soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
              soundtrack.play();
            }
            for(let i=0;i<characters.length;i++){
              if(characters[i].mode!="eaten"){
                characters[i].mode="normal";
              }
            }
          }
          isFrightenedWhite = (count%2==1);
          for(let i=0;i<5;i++){
            getSprite(i);
          }
          count++;
        },300);
      },800);
    }

    function changeGhostDirections() {
      for(let i=1;i<5;i++){
        if(characters[i].mode=="normal" &&
           !characters[i].characterNode.className.includes("revive")){
          characters[i].directionOld=characters[i].direction;
          characters[i].direction=oppositeDirection[characters[i].direction];
        }
      }
    }

    function gameFreeze(i) {
      sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/eat_ghost.wav";
      sound.play();
      const animStop = performance.now();
      stopAnimations("stop");
      clearTimeout(ghostModeInterval);

      characters[i].mode="eaten";
      characters[0].characterNode.classList.remove("yellow-visible");
      characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`);
      root.setProperty(`--${characters[i].name}-sprite-x`,`-${(ghostsEaten*32)/10}rem`);
      root.setProperty(`--${characters[i].name}-sprite-y`,"-25.6rem");

      for(let j=0;j<5;j++){
        characters[j].animationLength = characters[j].animationLength-(animStop-characters[j].animationStart);
        if(j==i){
          characters[j].animationLength/=6;
        }
        root.setProperty(`--${characters[j].name}-animation-length`, characters[j].animationLength+"ms");
      }

      setTimeout(()=>{
        soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/retreating.wav";
        soundtrack.play();
        characters[0].characterNode.classList.add("yellow-visible");
        getSprite(i);

        for(let j=0;j<5;j++){
          characters[j].characterNode.style.removeProperty("transition");
          if(characters[j].status=="freeze"){
            characters[j].status="normal";
            if(!characters[j].characterNode.className.includes("revive")){
              if(j==0 && elements[characters[j].nextPosition].classList.contains("wall")){
                characterMove(j);
              } else {
                getTransition(j);
                changePosition(j);
              }
            }
            characters[j].characterNode.style.animationPlayState="running";
          }
        }
        collisionInterval = setInterval(checkCollisions,10);
        ghostModeInterval = setTimeout(changeModes,5000);
      },1000);

      ghostsEaten++;
      score += (2 ** ghostsEaten)*100;
      scoreElement.innerHTML="Score "+score;
    }

    function ghostRetreat(i){
      characters[i].status="freeze";
      characters[i].characterNode.classList.add(`${characters[i].name}-retreat`);
      setTimeout(()=>{
        if(characters.some(ch=>ch.mode=="frightened")){
          soundtrack.src="https://dominikgorczyca.github.io/Pac-Man/audio/power_pellet.wav";
        } else {
          soundtrack.src="https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
        }
        soundtrack.play();
        characters[i].position=(i==1?406:startingPositions[i]);
        characters[i].characterNode.classList.remove(`${characters[i].name}-visible`, `${characters[i].name}-animation-move`, `${characters[i].name}-retreat`);
        characters[i].characterNode.style.transform="translateX(-1rem)";
        characters[i].characterNode=elements[characters[i].position].children[i];
        characters[i].animationLength=200;
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`, `${characters[i].name}-revive`);
        characters[i].mode="normal";
        characters[i].animationLength=200;
        ghostRevive(i,0);
      }, (i>2?250:150));
    }

    function ghostRevive(i, progress){
      if(characters[i].direction!=characters[i].directionList[progress] &&
         characters[i].directionList[progress]!=undefined &&
         characters[i].mode!="frightened"){
        characters[i].direction=characters[i].directionList[progress];
        getSprite(i);
      }
      if(progress!=characters[i].directionList.length && newLevel==undefined){
        if(characters[0].status=="freeze"){
          characters[i].characterNode.style.animationPlayState="paused";
        } else {
          characters[i].characterNode.style.animationPlayState="running";
        }
        setTimeout(()=>{
          characters[i].animationStart=performance.now();
          if(characters[0].status!="freeze"){
            progress++;
            characters[i].animationLength=200;
          }
          ghostRevive(i, progress);
        }, characters[i].animationLength);
      } else if(newLevel==undefined){
        characters[i].characterNode.classList.remove(`${characters[i].name}-visible`, `${characters[i].name}-revive`);
        characters[i].position=322;
        characters[i].characterNode=elements[characters[i].position].children[i];
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
        characters[i].status="normal";
        characters[i].direction="ArrowLeft";
        getSprite(i);
        characterMove(i);
      }
    }

    function gameOver(){
      stopAnimations();
      setTimeout(()=>{
        for(let i=1;i<5;i++){
          characters[i].characterNode.classList.remove(`${characters[i].name}-visible`);
        }
        characters[0].characterNode.classList.add("yellow-death-animation");
        sound.src="https://dominikgorczyca.github.io/Pac-Man/audio/death_1.wav";
        sound.play();
        setTimeout(()=>{
          sound.src="https://dominikgorczyca.github.io/Pac-Man/audio/death_2.wav";
          sound.play();
        },1400);

        if(livesLost==3){
          newLevel=true;
          setTimeout(()=>{
            startText.innerHTML="Game&nbsp; Over";
            startText.style.display="block";
            startText.style.color="red";
            // Обновляем очки в Firebase (если нужно) – раскомментируйте
            // userRef.update({ points: localUserData.points + score });

            setTimeout(()=>{
              startText.style.display="none";
              startText.style.color="yellow";
              startText.innerHTML="READY!";
              hardReset();
              deleteGameBoard();
              game.style.visibility="hidden";
              setTimeout(startLevel,500);
            },1500);
          },1500);
        } else {
          newLevel=false;
          gameStartLength=2000;
          setTimeout(()=>{
            game.style.visibility="hidden";
            deleteClasses();
            // Обновляем очки в Firebase (если нужно)
            // userRef.update({ points: localUserData.points + score });
            setTimeout(startLevel,500);
          },2000);
        }
      },1000);
    }

    function gameWin(){
      stopAnimations();
      newLevel=true;
      sound.src="https://dominikgorczyca.github.io/Pac-Man/audio/extend.wav";
      sound.play();
      // Обновляем очки в Firebase (если нужно)
      // userRef.update({ points: localUserData.points + score });

      setTimeout(()=>{
        for(let elem of elements){
          if(elem.classList.contains("wall")){
            elem.classList.add("blinking-animation");
            elem.style.backgroundColor="black";
          } else if(elem.classList.contains("wall-empty")){
            elem.classList.add("blinking-animation-corner");
          }
        }
        setTimeout(()=>{
          game.style.visibility="hidden";
          deleteGameBoard();
          setTimeout(startLevel,500);
        },1500);
      },2000);
    }

    function stopAnimations(stop){
      freezeCharacters(stop);
      for(let i=0;i<5;i++){
        const t = new WebKitCSSMatrix(getComputedStyle(characters[i].characterNode).transform);
        if(stop=="stop" && characters[i].mode=="eaten"){
          continue;
        }
        characters[i].characterNode.style.transition="none";
        characters[i].characterNode.style.transform=`translate(${parseInt(t.e)}px,${parseInt(t.f)}px)`;
        if(stop!="stop"){
          soundtrack.pause();
          sound.pause();
          if(i!=0){
            characters[i].characterNode.style.animationPlayState="paused";
          }
          characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`);
        } else {
          characters[i].characterNode.style.animationPlayState="paused";
        }
      }
    }

    function deleteGameBoard(){
      for(let elem of elements){
        elem.remove();
      }
    }

    function deleteClasses(){
      for(let i=0;i<5;i++){
        if(characters[i].characterNode){
          characters[i].characterNode.className=characters[i].name;
          characters[i].characterNode.removeAttribute("style");
        }
        transformStartingElements();
      }
    }

    function hardReset(){
      livesLost=0;
      score=0;
      setTimeout(()=>{
        for(let i=0;i<3;i++){
          lives.children[i].removeAttribute("style");
        }
      },500);
    }

    function freezeCharacters(stop){
      for(let i=0;i<5;i++){
        if(stop=="stop" && characters[i].mode=="eaten") {
          continue;
        }
        characters[i].status="freeze";
      }
    }

    function getDirection(e){
      switch(e.key){
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowRight":
        case "ArrowLeft":
          characters[0].directionNew=e.key;
      }
    }

    let xDown=null, yDown=null;
    function handleTouchStart(e){
      const firstTouch=e.touches[0];
      xDown=firstTouch.clientX;
      yDown=firstTouch.clientY;
    }
    function handleTouchMove(e){
      if(!xDown || !yDown) return;
      let xMove=e.touches[0].clientX;
      let yMove=e.touches[0].clientY;
      let xDiff=xDown-xMove;
      let yDiff=yDown-yMove;
      if(Math.abs(xDiff)>Math.abs(yDiff)){
        if(xDiff>0) characters[0].directionNew="ArrowLeft";
        else        characters[0].directionNew="ArrowRight";
      } else {
        if(yDiff>0) characters[0].directionNew="ArrowUp";
        else        characters[0].directionNew="ArrowDown";
      }
      xDown=null;
      yDown=null;
    }
  </script>
</body>
</html>
