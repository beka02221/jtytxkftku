<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- For mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pac-Man with Menu</title>
  
  <!-- Font: Press Start 2P -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* ------------------ Global & Menu Styles ------------------ */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      /* Menu background: dark blue */
      background: #00103c;
      font-family: 'Press Start 2P', monospace;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    /* Header with user info */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      font-size: 10px;
      color: #fff;
      align-items: center;
    }
    #info span { white-space: nowrap; }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img { width: 16px; height: 16px; }
    /* Back button */
    #backContainer {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Wrapper for game (menu + game) */
    #gameWrapper {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    /* Start button in menu */
    #startBtn {
      position: absolute;
      z-index: 10;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      padding: 10px 20px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    
    /* ------------------ Modal Windows ------------------ */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .modal-backdrop.active {
      display: flex;
    }
    .modal {
      background: #000;
      border: 2px solid #fff;
      border-radius: 8px;
      padding: 20px;
      max-width: 400px;
      text-align: center;
      color: #fff;
    }
    .modal button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    
    /* ------------------ Pac-Man Game Styles ------------------ */
    :root {
      --yellow-sprite-x: ;
      --yellow-sprite-y: ;
      --red-sprite-x: ;
      --red-sprite-y: ;
      --pink-sprite-x: ;
      --pink-sprite-y: ;
      --blue-sprite-x: ;
      --blue-sprite-y: ;
      --orange-sprite-x: ;
      --orange-sprite-y: ;
      --yellow-animation-length: 190ms;
      --red-animation-length: 200ms;
      --pink-animation-length: 200ms;
      --blue-animation-length: 200ms;
      --orange-animation-length: 200ms;
    }
    html { font-size: 0.625em; }
    @media (max-width: 600px), (max-height: 700px) {
      html { font-size: 0.3125em; }
    }
    
    /* Game container – hidden until start; scaled up */
    #game { 
      flex-direction: column; 
      display: none;
      transform: scale(1.3);
      transform-origin: center center;
    }
    
    /* In-game info */
    #game #info {
      box-sizing: border-box;
      width: 100%;
      justify-content: space-between;
      align-items: center;
      padding: 1em 2em;
    }
    #score {
      color: white;
      margin: 0;
      font-size: 2rem;
    }
    .live {
      width: 3.2rem;
      height: 2.6rem;
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      background-position: -26rem -3.2rem;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .live { background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites_small.png"); }
    }
    
    /* Game board – centered, with black background */
    #game-board {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      width: 56rem;
      height: 62rem;
      margin: auto;
      background-color: black;
      display: grid;
      grid-template-columns: repeat(28, 2rem);
    }
    #game-board > * {
      position: relative;
      box-sizing: border-box;
      width: 2rem;
      height: 2rem;
    }
    
    /* Remove extra text ("Click Anywhere to play") */
    
    /* Game objects */
    .wall {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/map.png");
      z-index: 1;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .wall { background-image: url("https://dominikgorczyca.github.io/Pac-Man/small_map.png"); }
    }
    .blank { background-color: black; }
    .wall > * {
      box-sizing: border-box;
      background-color: black;
      display: block;
      position: relative;
      width: 1.5rem;
      height: 1.5rem;
      border: .2rem solid #161693;
      border-radius: 80%;
      z-index: 1;
    }
    .point,
    .big-point {
      box-sizing: border-box;
      width: 2rem;
      height: 2rem;
      background-color: #ffb897;
      border-radius: 0;
      z-index: 10;
    }
    .point { border: .8rem solid black; }
    .big-point {
      border: .4rem solid black;
      border-radius: 45%;
      background-color: #ffb897;
    }
    .gate {
      background-color: #ffb897;
      border-top: .7rem solid black;
      border-bottom: .7rem solid black;
    }
    .yellow,
    .red,
    .pink,
    .blue,
    .orange,
    .points::after {
      image-rendering: pixelated;
      position: absolute;
      top: -0.4rem;
      left: -0.55rem;
      width: 3rem;
      height: 2.8rem;
    }
    .points::after {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      background-position: var(--yellow-sprite-x) var(--yellow-sprite-y);
    }
    .yellow-visible,
    .red-visible,
    .pink-visible,
    .blue-visible,
    .orange-visible {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      z-index: 101;
      will-change: transform, background-position;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .points::after,
      .yellow-visible,
      .red-visible,
      .pink-visible,
      .blue-visible,
      .orange-visible {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites_small.png");
      }
    }
    .yellow-visible {
      background-position: var(--yellow-sprite-x) var(--yellow-sprite-y);
      transition: transform var(--yellow-animation-length) linear;
      z-index: 100;
    }
    .red-visible {
      background-position: var(--red-sprite-x) var(--red-sprite-y);
      transition: transform var(--red-animation-length) linear;
      z-index: 104;
    }
    .pink-visible {
      background-position: var(--pink-sprite-x) var(--pink-sprite-y);
      transition: transform var(--pink-animation-length) linear;
      z-index: 103;
    }
    .blue-visible {
      background-position: var(--blue-sprite-x) var(--blue-sprite-y);
      transition: transform var(--blue-animation-length) linear;
      z-index: 102;
    }
    .orange-visible {
      background-position: var(--orange-sprite-x) var(--orange-sprite-y);
      transition: transform var(--orange-animation-length) linear;
    }
    
    /* Pac-Man mouth animation */
    .yellow-animation-move {
      animation: var(--yellow-animation-length) forwards steps(1, end) yellow;
    }
    @keyframes yellow {
      0%, 70%, 100% { background-position: -3.2rem var(--yellow-sprite-y); }
      30% { background-position: 0rem var(--yellow-sprite-y); }
      80% { background-position: -6.4rem 0rem; }
    }
    /* Additional keyframes for ghosts can be added as needed */
  </style>
</head>
<body>
  <!-- Modal for Game Over (after 3 deaths) -->
  <div id="endModal" class="modal-backdrop">
    <div class="modal">
      <h2 id="endTitle">Game Over!</h2>
      <p id="endMessage">Your final score is: 0</p>
      <button id="endBtn" onclick="redirectToIndex()">OK</button>
    </div>
  </div>
  
  <!-- Modal for Error (not enough tickets) -->
  <div id="errorModal" class="modal-backdrop">
    <div class="modal">
      <h2 id="errorTitle">Error</h2>
      <p id="errorMessage">Not enough tickets!</p>
      <button id="errorBtn" onclick="closeErrorModal()">Back</button>
    </div>
  </div>
  
  <!-- Header with user info -->
  <div id="header">
    <div id="info">
      <span id="username">@User</span>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
        <span id="ticketCount">0</span>
      </div>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
        <span id="pointCount">0</span>
      </div>
    </div>
  </div>
  
  <!-- Back button -->
  <div id="backContainer">
    <button id="backBtn" onclick="goBack()">Back</button>
  </div>
  
  <!-- Wrapper for game (menu + game) -->
  <div id="gameWrapper">
    <!-- Start button in menu -->
    <button id="startBtn" onclick="startPacmanGame()">Start (1 Ticket)</button>
    
    <!-- Pac-Man Game Markup -->
    <div id="game">
      <div id="info">
        <h3 id="score">Score 0</h3>
        <div id="lives">
          <div class="live"></div>
          <div class="live"></div>
          <div class="live"></div>
        </div>
      </div>
      <div id="game-board">
        <p id="start">Ready!</p>
      </div>
    </div>
  </div>
  
  <script>
    // Prevent default touchmove to block swipe-down closing Telegram WebApp
    document.addEventListener("touchmove", function(e) {
      e.preventDefault();
    }, { passive: false });
  
    /* ------------------ Global Variables ------------------ */
    let level = 1;
    let ghostSpeedMultiplier = 1;
  
    /* ------------------ Firebase & Telegram Initialization ------------------ */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
  
    let tg = null;
    if(window.Telegram && window.Telegram.WebApp) {
      tg = window.Telegram.WebApp;
      tg.expand();
    }
  
    let currentUser = null;
    let userRef = null;
    let localUserData = { tickets: 0, points: 0 };
  
    if(tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
      currentUser = tg.initDataUnsafe.user;
      document.getElementById('username').textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if(!snapshot.exists()){
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points  = data.points  || 0;
        updateHeader();
      });
    } else {
      currentUser = { username: 'TestUser' };
      document.getElementById('username').textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if(!snapshot.exists()){
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points  = data.points  || 0;
        updateHeader();
      });
    }
  
    function updateHeader() {
      document.getElementById('ticketCount').textContent = localUserData.tickets;
      document.getElementById('pointCount').textContent = localUserData.points;
    }
  
    function goBack() {
      window.location.href = 'index.html';
    }
  
    /* ------------------ Modal Functions ------------------ */
    function showErrorModal(message) {
      document.getElementById('errorMessage').textContent = message;
      document.getElementById('errorModal').classList.add('active');
    }
    function closeErrorModal() {
      document.getElementById('errorModal').classList.remove('active');
    }
  
    function showEndModal() {
      document.getElementById('endMessage').textContent = "Your final score is: " + score;
      document.getElementById('endModal').classList.add('active');
    }
    function redirectToIndex() {
      window.location.href = "index.html";
    }
  
    /* ------------------ Pac-Man Game Code ------------------ */
    const game = document.getElementById("game");
    const gameBoard = document.getElementById("game-board");
    const start = document.getElementById("start");
    const scoreElement = document.getElementById("score");
    const lives = document.getElementById("lives");
    const root = document.documentElement.style;
  
    let soundtrack = document.createElement("audio");
    soundtrack.loop = true;
    soundtrack.volume = 0.7;
    let sound = document.createElement("audio");
    sound.volume = 0.5;
  
    const startingPositions = [658, 322, 406, 404, 408];
    const positionChange = {
      "ArrowRight": 1,
      "ArrowLeft": -1,
      "ArrowUp": -28,
      "ArrowDown": 28,
    };
    const oppositeDirection = {
      "ArrowUp": "ArrowDown",
      "ArrowDown": "ArrowUp",
      "ArrowRight": "ArrowLeft",
      "ArrowLeft": "ArrowRight",
    };
    const yellowSprite = {
      "ArrowRight": 0,
      "ArrowLeft": 3.2,
      "ArrowUp": 6.4,
      "ArrowDown": 9.6,
    };
    const ghostSprite = {
      "ArrowRight": 0,
      "ArrowLeft": 6.4,
      "ArrowUp": 12.8,
      "ArrowDown": 19.2,
    };
    const eatenSprite = {
      "ArrowRight": 25.6,
      "ArrowLeft": 28.8,
      "ArrowUp": 32,
      "ArrowDown": 35.2,
    };
    // Initial characters: index 0 is Pac-Man; indices 1..N are ghosts
    let characters = [{
      name: "yellow",
      direction: "ArrowLeft",
      directionNew: undefined,
      position: 658,
      nextPosition: undefined,
      mode: "normal",
      status: "normal",
      characterNode: undefined,
      animationLength: undefined,
      animationStart: undefined,
    },
    {
      name: "red",
      direction: "ArrowLeft",
      directionOld: undefined,
      directionList: ["ArrowUp", "ArrowUp", "ArrowUp"],
      position: 38,
      nextPosition: undefined,
      scatterTarget: 27,
      mode: "normal",
      status: "normal",
      characterNode: undefined,
      animationLength: undefined,
      animationStart: undefined,
    },
    {
      name: "pink",
      direction: "ArrowDown",
      directionOld: undefined,
      directionList: ["ArrowDown", "ArrowUp", "ArrowUp", "ArrowUp", "ArrowUp"],
      position: 406,
      nextPosition: undefined,
      scatterTarget: 0,
      mode: "normal",
      status: "normal",
      characterNode: undefined,
      animationLength: undefined,
      animationStart: undefined,
    },
    {
      name: "blue",
      direction: "ArrowUp",
      directionOld: undefined,
      directionList: ["ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowRight", "ArrowRight", "ArrowUp", "ArrowUp", "ArrowUp"],
      position: 404,
      nextPosition: undefined,
      scatterTarget: 867,
      mode: "normal",
      status: "normal",
      characterNode: undefined,
      animationLength: undefined,
      animationStart: undefined,
    },
    {
      name: "orange",
      direction: "ArrowUp",
      directionOld: undefined,
      directionList: ["ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowLeft", "ArrowUp", "ArrowUp", "ArrowUp"],
      position: 408,
      nextPosition: undefined,
      scatterTarget: 840,
      mode: "normal",
      status: "normal",
      characterNode: undefined,
      animationLength: undefined,
      animationStart: undefined,
    }];
    let elements;
    let points = 0;
    let collisionInterval;
    let ghostMode;
    let ghostModeInterval;
    let changingBackInterval;
    let isFrightenedWhite = false;
    let ghostsEaten = 0;
    let newLevel = true;
    let score = 0;
    let livesLost = 0;
    let gameStartLength = 4200;
    let whichMunch = 1;
  
    /* ------------------ Game Level Win ------------------ */
    function gameWin() {
      stopAnimations();
      newLevel = true;
      sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/extend.wav";
      sound.play();
  
      setTimeout(() => {
        // Add blinking effect
        for (let element of elements) {
          if (element.classList.contains("wall")) {
            element.classList.add("blinking-animation");
            element.style.backgroundColor = "black";
          } else if (element.classList.contains("wall-empty")) {
            element.classList.add("blinking-animation-corner");
          }
        }
        setTimeout(() => {
          game.style.visibility = "hidden";
          deleteGameBoard();
          // Reset game variables for new level:
          score = 0;
          points = 0;
          livesLost = 0;
          // Increase level and ghost speed
          level++;
          ghostSpeedMultiplier *= 0.9;
          // Add one extra ghost
          const newGhost = {
            name: "ghost" + level,
            direction: "ArrowUp",
            directionOld: undefined,
            directionList: ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"],
            position: 322,
            nextPosition: undefined,
            scatterTarget: 840,
            mode: "normal",
            status: "normal",
            characterNode: undefined,
            animationLength: undefined,
            animationStart: undefined,
          };
          characters.push(newGhost);
          startingPositions.push(322);
          setTimeout(startLevel, 500);
        }, 1500);
      }, 2000);
    }
  
    /* ------------------ Game Over ------------------ */
    function gameOver() {
      stopAnimations();
      setTimeout(() => {
        for (let i = 1; i < characters.length; i++) {
          characters[i].characterNode.classList.remove(`${characters[i].name}-visible`);
        }
  
        characters[0].characterNode.classList.add("yellow-death-animation");
        sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/death_1.wav";
        sound.play();
        setTimeout(() => {
          sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/death_2.wav";
          sound.play();
        }, 1400);
  
        if (livesLost == 3) {
          newLevel = true;
          setTimeout(() => {
            showEndModal();
          }, 1500);
        } else {
          newLevel = false;
          gameStartLength = 2000;
          setTimeout(() => {
            game.style.visibility = "hidden";
            deleteClasses();
            setTimeout(startLevel, 500);
          }, 2000);
        }
      }, 1000);
    }
  
    /* ------------------ Animation Helpers ------------------ */
    function stopAnimations(stop) {
      freezeCharacters(stop);
      for (let i = 0; i < characters.length; i++) {
        const characterTransform = new WebKitCSSMatrix(getComputedStyle(characters[i].characterNode).transform);
        if (stop == "stop" && characters[i].mode == "eaten") {
          continue;
        }
        characters[i].characterNode.style.transition = "none";
        characters[i].characterNode.style.transform = `translate(${parseInt(characterTransform.e)}px, ${parseInt(characterTransform.f)}px)`;
        if (stop != "stop") {
          soundtrack.pause();
          sound.pause();
          if (i != 0) {
            characters[i].characterNode.style.animationPlayState = "paused";
          }
          characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`);
        } else {
          characters[i].characterNode.style.animationPlayState = "paused";
        }
      }
    }
  
    function deleteGameBoard() {
      for (let element of elements) {
        element.remove();
      }
    }
  
    function deleteClasses() {
      for (let i = 0; i < characters.length; i++) {
        if (characters[i].characterNode != undefined) {
          characters[i].characterNode.className = characters[i].name;
          characters[i].characterNode.removeAttribute("style");
        }
        transformStartingElements();
      }
    }
  
    function hardReset() {
      livesLost = 0;
      score = 0;
      setTimeout(() => {
        for (let i = 0; i < lives.children.length; i++) {
          lives.children[i].removeAttribute("style");
        }
      }, 500);
    }
  
    function freezeCharacters(stop) {
      for (let i = 0; i < characters.length; i++) {
        if (stop == "stop" && characters[i].mode == "eaten") {
          continue;
        }
        characters[i].status = "freeze";
      }
    }
  
    function getDirection(e) {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowRight":
        case "ArrowLeft":
          characters[0].directionNew = e.key;
      }
    }
  
    let xDown = null;
    let yDown = null;
  
    function handleTouchStart(e) {
      const firstTouch = e.touches[0];
      xDown = firstTouch.clientX;
      yDown = firstTouch.clientY;
    }
  
    function handleTouchMove(e) {
      if (!xDown || !yDown) {
        return;
      }
      let xMove = e.touches[0].clientX;
      let yMove = e.touches[0].clientY;
      let xDiff = xDown - xMove;
      let yDiff = yDown - yMove;
      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        if (xDiff > 0) {
          characters[0].directionNew = "ArrowLeft";
        } else {
          characters[0].directionNew = "ArrowRight";
        }
      } else {
        if (yDiff > 0) {
          characters[0].directionNew = "ArrowUp";
        } else {
          characters[0].directionNew = "ArrowDown";
        }
      }
      xDown = null;
      yDown = null;
    }
  
    /* ------------------ Pac-Man Game Functions ------------------ */
    function characterMove(i) {
      if (characters[i].status == "freeze") return;
      characters[i].nextPosition = getNewPosition(i);
      if (elements[characters[i].nextPosition].classList.contains("wall")) {
        if(sound.src.includes("https://dominikgorczyca.github.io/Pac-Man/munch")) {
          sound.pause();
        }
        setTimeout(() => { characterMove(i); }, 50);
        return;
      }
      getAnimationLength(i);
      getSprite(i);
      getTransition(i);
      changePosition(i);
    }
  
    function getNewPosition(i) {
      if (i == 0) {
        getYellowDirection(i);
      } else if (characters[i].direction != oppositeDirection[characters[i].directionOld]) {
        if (characters[i].mode == "frightened") {
          getRandomDirection(i);
        } else {
          getGhostDirection(i);
        }
      } else {
        characters[i].directionOld = characters[i].direction;
      }
      let nextPosition = characters[i].position + positionChange[characters[i].direction];
      if (characters[i].position == 392 && nextPosition == 391) {
        nextPosition = 419;
      } else if (characters[i].position == 419 && nextPosition == 420) {
        nextPosition = 392;
      }
      return nextPosition;
    }
  
    function getYellowDirection(i) {
      if (characters[i].directionNew != undefined) {
        const newPosition = characters[i].position + positionChange[characters[i].directionNew];
        if (!elements[newPosition].classList.contains("wall")) {
          characters[i].direction = characters[i].directionNew;
          characters[i].directionNew = undefined;
        }
      }
    }
  
    function getGhostDirection(i) {
      let newDirection = characters[i].directionOld = characters[i].direction;
      let biggestDistance = 100000;
      let target;
      if (characters[i].mode == "eaten") {
        target = 322;
      } else if (ghostMode == "scatter") {
        target = characters[i].scatterTarget;
      } else {
        target = getChaseTarget(i);
      }
      for (let [direction, value] of Object.entries(positionChange)) {
        const newPosition = characters[i].position + value;
        const newDistance = calculateDistance(target, newPosition);
        if (newDistance < biggestDistance) {
          if (!elements[newPosition].classList.contains("wall") &&
              oppositeDirection[direction] != characters[i].direction) {
            biggestDistance = newDistance;
            newDirection = direction;
          }
        }
      }
      characters[i].direction = newDirection;
    }
  
    function getRandomDirection(i) {
      let nextPosition = characters[i].position + positionChange[characters[i].direction];
      if ((characters[i].position == 392 && nextPosition == 391) ||
          (characters[i].position == 419 && nextPosition == 420)) {
        return;
      }
      let newDirection;
      do {
        const random = Math.floor(Math.random() * 4);
        newDirection = Object.keys(positionChange)[random];
        nextPosition = characters[i].position + positionChange[newDirection];
      } while (elements[nextPosition].classList.contains("wall") ||
               oppositeDirection[newDirection] == characters[i].direction);
      characters[i].direction = newDirection;
    }
  
    function getChaseTarget(i) {
      switch (i) {
        case 1:
          if(characters[0].position == characters[i].position &&
             !elements[characters[0].nextPosition].classList.contains("wall"))
          {
            return characters[0].position + positionChange[characters[0].direction];
          }
          return characters[0].position;
        case 2:
          return characters[0].position + positionChange[characters[0].direction] * 2;
        case 3:
          return getBlueTarget();
        case 4:
          const yellowOrangeDistance = calculateDistance(characters[0].position, characters[4].position);
          if (yellowOrangeDistance < 64) {
            return 840;
          } else {
            return characters[0].position;
          }
      }
    }
  
    function getBlueTarget() {
      const yellowPosition = characters[0].position + positionChange[characters[0].direction];
      const yellowRedDistanceX = yellowPosition % 28 - characters[1].position % 28;
      const yellowRedDistanceY = Math.floor(yellowPosition / 28) - Math.floor(characters[1].position / 28);
      let bluePositionX = yellowPosition % 28 + yellowRedDistanceX;
      if (bluePositionX < 0) { bluePositionX = 0; }
      else if (bluePositionX > 27) { bluePositionX = 27; }
      const bluePositionY = Math.floor(yellowPosition / 28) + yellowRedDistanceY;
      return bluePositionX + bluePositionY * 28;
    }
  
    function calculateDistance(target, newGhostPosition) {
      const distanceX = Math.floor(target / 28) - Math.floor(newGhostPosition / 28);
      const distanceY = target % 28 - newGhostPosition % 28;
      return distanceX ** 2 + distanceY ** 2;
    }
  
    function getAnimationLength(i) {
      let animationLength;
      if (i == 0) {
        animationLength = characters[i].mode == "hasEaten" ? 210 : 190;
      } else {
        const tunnel = [392,393,394,395,396,419,418,417,416,415];
        if (characters[i].mode == "eaten") {
          if (characters[i].nextPosition === 322) {
            animationLength = characters[i].direction == "ArrowLeft" ? 25 : 75;
          } else {
            animationLength = 50;
          }
        } else if (tunnel.includes(characters[i].position) || tunnel.includes(characters[i].nextPosition)) {
          animationLength = 350;
        } else if (characters[i].mode == "frightened") {
          animationLength = 300;
        } else if (characters[i].direction == characters[i].directionOld ||
                   characters[i].direction == oppositeDirection[characters[i].directionOld]) {
          animationLength = 200;
        } else {
          animationLength = 220;
        }
      }
      // For ghosts, apply speed multiplier to increase speed on higher levels
      if(i !== 0) { animationLength *= ghostSpeedMultiplier; }
      if (characters[i].characterNode && characters[i].characterNode.style.transform == 'translateX(-1rem)') {
        animationLength /= 1.5;
      }
      root.setProperty(`--${characters[i].name}-animation-length`, animationLength + "ms");
      characters[i].animationLength = animationLength;
    }
  
    function getSprite(i) {
      let spriteX;
      let spriteY;
      if (i == 0) {
        spriteX = 3.2;
        spriteY = yellowSprite[characters[i].direction];
      } else {
        if (characters[i].mode == "normal") {
          spriteX = ghostSprite[characters[i].direction];
          spriteY = 9.6 + 3.2 * i;
        } else if (characters[i].mode == "frightened") {
          spriteX = isFrightenedWhite ? 32 : 25.6;
          spriteY = 12.8;
        } else {
          spriteX = eatenSprite[characters[i].direction];
          spriteY = 16;
        }
      }
      root.setProperty(`--${characters[i].name}-sprite-x`, `-${spriteX}rem`);
      root.setProperty(`--${characters[i].name}-sprite-y`, `-${spriteY}rem`);
    }
  
    function getTransition(i) {
      const isGoingToRespawn = characters[i].mode == "eaten" && characters[i].nextPosition == 322;
      const transitionMove = {
        "ArrowUp": "Y(-2rem)",
        "ArrowDown": "Y(2rem)",
        "ArrowRight": isGoingToRespawn ? "X(1rem)" : "X(2rem)",
        "ArrowLeft": isGoingToRespawn ? "X(-3rem)" : "X(-2rem)",
      };
      characters[i].characterNode.style.transform = `translate${transitionMove[characters[i].direction]}`;
    }
  
    async function changePosition(i) {
      await new Promise(resolve => {
        if (characters[i].mode != "eaten") {
          characters[i].characterNode.classList.add(`${characters[i].name}-animation-move`);
        }
        characters[i].animationStart = performance.now();
        setTimeout(() => {
          if (characters[i].status == "freeze") return;
          characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`, `${characters[i].name}-visible`);
          characters[i].characterNode.style.transform = "";
          characters[i].position = characters[i].nextPosition;
          characters[i].characterNode = elements[characters[i].position].children[i];
          characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
          if (i == 0) {
            eatPoint(i);
          } else if (characters[i].mode == "eaten" && characters[i].position === 322) {
            ghostRetreat(i);
          }
          resolve();
        }, characters[i].animationLength);
      });
      characterMove(i);
    }
  
    function eatPoint(i) {
      const point = elements[characters[i].position].children[5];
      if (point != undefined) {
        points++;
        characters[i].mode = "hasEaten";
        if (point.classList.contains("big-point")) {
          makeGhostsScared();
          // Big point gives 10 points
          score += 10;
        } else {
          // Normal point gives 1 point
          score += 1;
          if(!sound.src.includes("munch") || sound.paused) {
            sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/munch.wav";
            sound.play();
          }
        }
        scoreElement.innerHTML = "Score " + score;
        point.remove();
        if (points >= 244) {
          gameWin();
          freezeCharacters();
        }
      } else {
        characters[i].mode = "normal";
        if(sound.src.includes("munch")) { sound.pause(); }
      }
    }
  
    function makeGhostsScared() {
      soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/power_pellet.wav";
      soundtrack.play();
      clearInterval(changingBackInterval);
      isFrightenedWhite = false;
      ghostsEaten = 0;
      changeGhostDirections();
      for (let i = 0; i < characters.length; i++) {
        if (i !== 0 && characters[i].mode != "eaten") {
          characters[i].mode = "frightened";
          getSprite(i);
        }
      }
      setTimeout(() => {
        let intervalCount = 1;
        changingBackInterval = setInterval(() => {
          if (characters[0].status == "freeze") return;
          if (intervalCount == 10) {
            clearInterval(changingBackInterval);
            if(!soundtrack.src.includes("retreating")){
              soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
              soundtrack.play();
            }
            for (let i = 0; i < characters.length; i++) {
              if (i !== 0 && characters[i].mode != "eaten") {
                characters[i].mode = "normal";
              }
            }
          }
          isFrightenedWhite = (intervalCount % 2 === 1);
          for (let i = 0; i < characters.length; i++) {
            if(i !== 0) { getSprite(i); }
          }
          intervalCount++;
        }, 300);
      }, 800);
    }
  
    function changeGhostDirections() {
      for (let i = 1; i < characters.length; i++) {
        if (characters[i].mode == "normal" &&
            !characters[i].characterNode.className.includes("revive")) {
          characters[i].directionOld = characters[i].direction;
          characters[i].direction = oppositeDirection[characters[i].direction];
        }
      }
    }
  
    function gameFreeze(i) {
      sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/eat_ghost.wav";
      sound.play();
      const animationStop = performance.now();
      stopAnimations("stop");
      clearTimeout(ghostModeInterval);
      characters[i].mode = "eaten";
      characters[0].characterNode.classList.remove("yellow-visible");
      characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`);
      root.setProperty(`--${characters[i].name}-sprite-x`, `-${(ghostsEaten * 32) / 10}rem`);
      root.setProperty(`--${characters[i].name}-sprite-y`, "-25.6rem");
      for (let j = 0; j < characters.length; j++) {
        characters[j].animationLength = characters[j].animationLength - (animationStop - characters[j].animationStart);
        if (j == i) { characters[j].animationLength /= 6; }
        root.setProperty(`--${characters[j].name}-animation-length`, `${characters[j].animationLength}ms`);
      }
      setTimeout(() => {
        soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/retreating.wav";
        soundtrack.play();
        characters[0].characterNode.classList.add("yellow-visible");
        getSprite(i);
        for (let j = 0; j < characters.length; j++) {
          characters[j].characterNode.style.removeProperty("transition");
          if (characters[j].status == "freeze") {
            characters[j].status = "normal";
            if (!characters[j].characterNode.className.includes("revive")) {
              if (j == 0 && elements[characters[j].nextPosition].classList.contains("wall")) {
                characterMove(j);
              } else {
                getTransition(j);
                changePosition(j);
              }
            }
            characters[j].characterNode.style.animationPlayState = "running";
          }
        }
        collisionInterval = setInterval(checkCollisions, 10);
        ghostModeInterval = setTimeout(changeModes, 5000);
      }, 1000);
      ghostsEaten++;
      score += 10;
      scoreElement.innerHTML = "Score " + score;
    }
  
    function ghostRetreat(i) {
      characters[i].status = "freeze";
      characters[i].characterNode.classList.add(`${characters[i].name}-retreat`);
      setTimeout(() => {
        if(characters.some(char => char.mode == "frightened")) {
          soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/power_pellet.wav";
        } else {
          soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
        }
        soundtrack.play();
        characters[i].position = i === 1 ? 406 : startingPositions[i];
        characters[i].characterNode.classList.remove(`${characters[i].name}-visible`, `${characters[i].name}-animation-move`, `${characters[i].name}-retreat`);
        characters[i].characterNode.style.transform = "translateX(-1rem)";
        characters[i].characterNode = elements[characters[i].position].children[i];
        characters[i].animationLength = 200;
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`, `${characters[i].name}-revive`);
        characters[i].mode = "normal";
        characters[i].animationLength = 200;
        ghostRevive(i, 0);
      }, i > 2 ? 250 : 150);
    }
  
    function ghostRevive(i, progress) {
      if (characters[i].direction != characters[i].directionList[progress] &&
          characters[i].directionList[progress] != undefined &&
          characters[i].mode != "frightened") {
        characters[i].direction = characters[i].directionList[progress];
        getSprite(i);
      }
      if (progress != characters[i].directionList.length && newLevel == undefined) {
        if (characters[0].status == "freeze") {
          characters[i].characterNode.style.animationPlayState = "paused";
        } else {
          characters[i].characterNode.style.animationPlayState = "running";
        }
        setTimeout(() => {
          characters[i].animationStart = performance.now();
          if (characters[0].status != "freeze") {
            progress++;
            characters[i].animationLength = 200;
          }
          ghostRevive(i, progress);
        }, characters[i].animationLength);
      } else if (newLevel == undefined) {
        characters[i].characterNode.classList.remove(`${characters[i].name}-visible`, `${characters[i].name}-revive`);
        characters[i].position = 322;
        characters[i].characterNode = elements[characters[i].position].children[i];
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
        characters[i].status = "normal";
        characters[i].direction = "ArrowLeft";
        getSprite(i);
        characterMove(i);
      }
    }
  
    function gameOver() {
      stopAnimations();
      setTimeout(() => {
        for (let i = 1; i < characters.length; i++) {
          characters[i].characterNode.classList.remove(`${characters[i].name}-visible`);
        }
        characters[0].characterNode.classList.add("yellow-death-animation");
        sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/death_1.wav";
        sound.play();
        setTimeout(() => {
          sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/death_2.wav";
          sound.play();
        }, 1400);
        if (livesLost == 3) {
          newLevel = true;
          setTimeout(() => { showEndModal(); }, 1500);
        } else {
          newLevel = false;
          gameStartLength = 2000;
          setTimeout(() => {
            game.style.visibility = "hidden";
            deleteClasses();
            setTimeout(startLevel, 500);
          }, 2000);
        }
      }, 1000);
    }
  
    function stopAnimations(stop) {
      freezeCharacters(stop);
      for (let i = 0; i < characters.length; i++) {
        const characterTransform = new WebKitCSSMatrix(getComputedStyle(characters[i].characterNode).transform);
        if (stop == "stop" && characters[i].mode == "eaten") continue;
        characters[i].characterNode.style.transition = "none";
        characters[i].characterNode.style.transform = `translate(${parseInt(characterTransform.e)}px, ${parseInt(characterTransform.f)}px)`;
        if (stop != "stop") {
          soundtrack.pause();
          sound.pause();
          if (i != 0) {
            characters[i].characterNode.style.animationPlayState = "paused";
          }
          characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`);
        } else {
          characters[i].characterNode.style.animationPlayState = "paused";
        }
      }
    }
  
    function deleteGameBoard() {
      for (let element of elements) {
        element.remove();
      }
    }
  
    function deleteClasses() {
      for (let i = 0; i < characters.length; i++) {
        if (characters[i].characterNode != undefined) {
          characters[i].characterNode.className = characters[i].name;
          characters[i].characterNode.removeAttribute("style");
        }
        transformStartingElements();
      }
    }
  
    function hardReset() {
      livesLost = 0;
      score = 0;
      setTimeout(() => {
        for (let i = 0; i < lives.children.length; i++) {
          lives.children[i].removeAttribute("style");
        }
      }, 500);
    }
  
    function freezeCharacters(stop) {
      for (let i = 0; i < characters.length; i++) {
        if (stop == "stop" && characters[i].mode == "eaten") continue;
        characters[i].status = "freeze";
      }
    }
  
    function getDirection(e) {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowRight":
        case "ArrowLeft":
          characters[0].directionNew = e.key;
      }
    }
  
    let xDown = null;
    let yDown = null;
    function handleTouchStart(e) {
      const firstTouch = e.touches[0];
      xDown = firstTouch.clientX;
      yDown = firstTouch.clientY;
    }
    function handleTouchMove(e) {
      if (!xDown || !yDown) return;
      let xMove = e.touches[0].clientX;
      let yMove = e.touches[0].clientY;
      let xDiff = xDown - xMove;
      let yDiff = yDown - yMove;
      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        characters[0].directionNew = (xDiff > 0) ? "ArrowLeft" : "ArrowRight";
      } else {
        characters[0].directionNew = (yDiff > 0) ? "ArrowUp" : "ArrowDown";
      }
      xDown = null;
      yDown = null;
    }
  
    function transformStartingElements() {
      for (let i = 0; i < startingPositions.length; i++) {
        const cell = elements[startingPositions[i]];
        if (cell) {
          // For simplicity, set default transform for each ghost/Pac-Man
          if(cell.children[i]) {
            cell.children[i].style.transform = "translateX(-1rem)";
          }
        }
      }
    }
  
    /* ------------------ Start Level & Set Properties ------------------ */
    function startLevel() {
      if (newLevel === true) {
        gameStartLength = 4200;
        sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/game_start.wav";
        makeLevel();
        sound.play();
      }
      setStartingProperties();
      setTimeout(() => {
        soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
        soundtrack.play();
        lives.children[livesLost].style.visibility = "hidden";
        livesLost++;
        characterMove(0);
        characterMove(1);
        ghostRevive(2, 0);
        ghostRevive(3, 0);
        ghostRevive(4, 0);
        // For additional ghosts, start their movement too:
        for (let i = 5; i < characters.length; i++) {
          ghostRevive(i, 0);
        }
        collisionInterval = setInterval(checkCollisions, 10);
        ghostModeInterval = setTimeout(changeModes, 5000);
      }, gameStartLength);
    }
  
    function makeLevel() {
      const gameClass = {
        0: "blank",
        1: "left-right wall",
        2: "top-bottom wall",
        3: "top-right wall",
        4: "top-left wall",
        5: "bottom-right wall",
        6: "bottom-left wall",
        7: "top wall",
        8: "bottom wall",
        9: "right wall",
        10: "left wall",
        11: "gate wall",
        12: "wall-empty" 
      };
      const gameArray = [/* ... the same long array as before ... */ 2,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3];
      // (For brevity, the full array is omitted here – use your original array.)
      for (let i = 0; i < gameArray.length; i++) {
        const element = document.createElement("DIV");
        if (gameArray[i] > 25) {
          element.className = "blank";
          for (let j = 0; j < characters.length; j++) {
            let character = document.createElement("DIV");
            character.className = characters[j].name;
            element.append(character);
          }
          if(gameArray[i] / 100 > 1) {
            let character = document.createElement("DIV");
            character.className = Math.floor(gameArray[i] / 100) == 1 ? "point" : "big-point";
            element.append(character);
          }
        } else {
          element.className = "wall";
          element.style.backgroundPosition = `-${gameArray[i] * 2}rem 0`;
        }
        gameBoard.append(element);
      }
      points = 0;
      elements = Array.from(gameBoard.children).splice(1);
      transformStartingElements();
    }
  
    function setStartingProperties() {
      newLevel = undefined;
      window.removeEventListener("keydown", getDirection);
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchmove", handleTouchMove);
      clearTimeout(ghostModeInterval);
      game.style.visibility = "visible";
      start.style.display = "block";
      ghostMode = "scatter";
      ghostsEaten = 0;
      scoreElement.innerHTML = "Score " + score;
      for (let i = 0; i < characters.length; i++) {
        characters[i].position = startingPositions[i];
        characters[i].direction = i === 0 ? "ArrowLeft" : characters[i].directionList[0];
        characters[i].characterNode = elements[characters[i].position].children[i];
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
        characters[i].mode = "normal";
        characters[i].status = "normal";
        if (i === 0) {
          root.setProperty(`--${characters[i].name}-sprite-x`, "-6.4rem");
          root.setProperty(`--${characters[i].name}-sprite-y`, "0rem");
          characters[i].directionNew = undefined;
        } else {
          getSprite(i);
        }
      }
      setTimeout(() => {
        window.addEventListener("keydown", getDirection);
        document.addEventListener('touchstart', handleTouchStart);
        document.addEventListener('touchmove', handleTouchMove);
        for (let i = 2; i < characters.length; i++) {
          characters[i].animationLength = 200;
          characters[i].characterNode.classList.add(`${characters[i].name}-revive`);
        }
        start.style.display = "none";
        getSprite(0);
      }, gameStartLength);
    }
  </script>
</body>
</html>
