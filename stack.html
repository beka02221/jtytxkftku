<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <title>The Stack Game</title>
  <!-- Используем шрифт Comfortaa, как в оригинале -->
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram Web App API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- THREE.js и GSAP для игры The Stack -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js"></script>
  
  <style>
    /* Общие стили */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #00103c;
      font-family: 'Comfortaa', cursive;
    }
    /* Контейнер всей страницы */
    #container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    /* Header с информацией (Telegram user info, билеты, очки) */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      font-size: 10px;
      color: #fff;
      align-items: center;
    }
    #info span { white-space: nowrap; }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img {
      width: 16px;
      height: 16px;
    }
    /* Кнопка Back */
    #backContainer {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 1000;
    }
    #backBtn {
      font-size: 10px;
      padding: 5px 10px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Меню – стартовая панель (до начала игры) */
    #menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1100;
    }
    #menu button {
      font-size: 30px;
      padding: 10px 20px;
      background: transparent;
      border: 3px solid #333344;
      color: #333344;
      cursor: pointer;
      transition: opacity 0.5s ease, transform 0.5s ease;
    }
    /* Элементы игры (The Stack) – изначально скрыты */
    #game, #score, #instructions, .game-over {
      display: none;
    }
    #game {
      position: absolute;
      top: 0; right: 0; bottom: 0; left: 0;
    }
    #score {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 10vh;
      transition: transform 0.5s ease;
      color: #333344;
      transform: translateY(-200px) scale(1);
      z-index: 900;
    }
    #instructions {
      position: absolute;
      top: 16vh;
      left: 0;
      width: 100%;
      text-align: center;
      transition: opacity 0.5s ease, transform 0.5s ease;
      opacity: 0;
      z-index: 900;
    }
    .game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 85%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 900;
    }
    .game-over * {
      transition: opacity 0.5s ease, transform 0.5s ease;
      opacity: 0;
      transform: translateY(-50px);
      color: #333344;
    }
    .game-over h2 { margin: 0; padding: 0; font-size: 40px; }
    
    /* Модальное окно после игры (Game Over) */
    #end {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;
      z-index: 2000;
      background: rgba(0, 0, 0, 0.7);
    }
    #end .modal {
      background: #222;
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 400px;
      text-align: center;
      color: #FF00FF;
      font-size: 14px;
    }
    #end .modal button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    /* Canvas (рендер Three.js для игры The Stack) */
    #game canvas {
      position: absolute;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Header -->
    <div id="header">
      <div id="info">
        <span id="username">@User</span>
        <div class="balance">
          <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
          <span id="ticketCount">0</span>
        </div>
        <div class="balance">
          <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
          <span id="pointCount">0</span>
        </div>
      </div>
    </div>
    <!-- Back Button -->
    <div id="backContainer">
      <button id="backBtn">Back</button>
    </div>
    <!-- Меню (до старта игры) -->
    <div id="menu">
      <button id="menuStartBtn">Start (1 Ticket)</button>
    </div>
    <!-- Элементы игры The Stack (скрыты до старта) -->
    <div id="game"></div>
    <div id="score">0</div>
    <div id="instructions">Click (or press space) to place the block</div>
    <div class="game-over">
      <h2>Game Over</h2>
      <p>You did great, you're the best.</p>
      <p>Click or spacebar to start again</p>
    </div>
  </div>
  <!-- Модальное окно после игры / при отсутствии билетов -->
  <div id="end">
    <div class="modal">
      <h2 id="endTitle"></h2>
      <p id="endMessage"></p>
      <button id="endBtn">OK</button>
    </div>
  </div>
  
  <!-- Звуки -->
  <audio id="bgSound" src="background.mp3" loop></audio>
  <audio id="moveSound" src="move.mp3"></audio>
  <audio id="deathSound" src="death.mp3"></audio>
  
  <script>
    "use strict";
    /* ---------- Firebase + Telegram + Tickets ---------- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    let tgApp = null;
    if(window.Telegram && window.Telegram.WebApp) {
      tgApp = window.Telegram.WebApp;
      tgApp.expand();
    }
    
    let currentUser = null;
    let userRef = null;
    let localUserData = { tickets: 0, points: 0 };
    let dataLoaded = false;
    // Если данные не загрузятся в течение 3 секунд, dataLoaded станет true
    setTimeout(() => { dataLoaded = true; }, 3000);
    
    const usernameElem = document.getElementById('username');
    const ticketCountElem = document.getElementById('ticketCount');
    const pointCountElem = document.getElementById('pointCount');
    
    if(tgApp && tgApp.initDataUnsafe && tgApp.initDataUnsafe.user) {
      currentUser = tgApp.initDataUnsafe.user;
      usernameElem.textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if(!snapshot.exists()){
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    } else {
      currentUser = { username: 'TestUser' };
      usernameElem.textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if(!snapshot.exists()){
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    }
    
    function updateHeader() {
      ticketCountElem.textContent = localUserData.tickets;
      pointCountElem.textContent = localUserData.points;
    }
    
    document.getElementById('backBtn').addEventListener('click', () => {
      window.location.href = 'index.html';
    });
    
    // Модальное окно: если билетов нет или данные не загружены, модал просто скрывается по OK.
    let modalType = "gameOver"; // "gameOver" или "noTickets"
    document.getElementById('endBtn').addEventListener('click', () => {
      if(modalType === "gameOver") {
        window.location.href = 'index.html';
      } else if(modalType === "noTickets") {
        document.getElementById('end').style.visibility = 'hidden';
      }
    });
    
    /* ---------- Код игры The Stack ---------- */
    // Класс Stage
    class Stage {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("game").appendChild(this.renderer.domElement);
        this.scene = new THREE.Scene();
        let aspect = window.innerWidth / window.innerHeight;
        let d = 20;
        this.camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, -100, 1000);
        this.camera.position.set(2,2,2);
        this.camera.lookAt(new THREE.Vector3(0,0,0));
        this.light = new THREE.DirectionalLight(0xffffff, 0.5);
        this.light.position.set(0, 499, 0);
        this.scene.add(this.light);
        this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(this.softLight);
        window.addEventListener("resize", () => this.onResize());
        this.onResize();
      }
      render() {
        this.renderer.render(this.scene, this.camera);
      }
      add(elem) {
        this.scene.add(elem);
      }
      remove(elem) {
        this.scene.remove(elem);
      }
      onResize() {
        let viewSize = 30;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.left = window.innerWidth / -viewSize;
        this.camera.right = window.innerWidth / viewSize;
        this.camera.top = window.innerHeight / viewSize;
        this.camera.bottom = window.innerHeight / -viewSize;
        this.camera.updateProjectionMatrix();
      }
    }
    
    // Класс Block
    class Block {
      constructor(block) {
        this.STATES = { ACTIVE: "active", STOPPED: "stopped", MISSED: "missed" };
        this.MOVE_AMOUNT = 12;
        this.dimension = { width: 0, height: 0, depth: 0 };
        this.position = { x: 0, y: 0, z: 0 };
        this.targetBlock = block;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 ? "x" : "z";
        this.workingDimension = this.index % 2 ? "width" : "depth";
        this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
        this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
        this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
        this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
        this.position.y = this.dimension.height * this.index;
        this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;
        this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random()*100);
        if(!this.targetBlock) {
          this.color = 0x333344;
        } else {
          let offset = this.index + this.colorOffset;
          let r = Math.sin(0.3*offset)*55+200;
          let g = Math.sin(0.3*offset+2)*55+200;
          let b = Math.sin(0.3*offset+4)*55+200;
          this.color = new THREE.Color(r/255, g/255, b/255);
        }
        this.state = (this.index > 1) ? this.STATES.ACTIVE : this.STATES.STOPPED;
        this.speed = -0.1 - this.index * 0.005;
        if(this.speed < -4) this.speed = -4;
        this.direction = this.speed;
        let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
        geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2));
        this.material = new THREE.MeshToonMaterial({ color: this.color });
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.set(this.position.x, this.position.y, this.position.z);
        if(this.state == this.STATES.ACTIVE) {
          this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
        }
      }
      reverseDirection() {
        this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed);
      }
      place() {
        this.state = this.STATES.STOPPED;
        let overlap = this.targetBlock.dimension[this.workingDimension] -
                      Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
        let blocksToReturn = { plane: this.workingPlane, direction: this.direction };
        if(this.dimension[this.workingDimension] - overlap < 0.3) {
          overlap = this.dimension[this.workingDimension];
          blocksToReturn.bonus = true;
          this.position.x = this.targetBlock.position.x;
          this.position.z = this.targetBlock.position.z;
          this.dimension.width = this.targetBlock.dimension.width;
          this.dimension.depth = this.targetBlock.dimension.depth;
        }
        if(overlap > 0) {
          let choppedDimensions = {
            width: this.dimension.width,
            height: this.dimension.height,
            depth: this.dimension.depth
          };
          choppedDimensions[this.workingDimension] -= overlap;
          this.dimension[this.workingDimension] = overlap;
          let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
          placedGeometry.applyMatrix4(new THREE.Matrix4().makeTranslation(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2));
          let placedMesh = new THREE.Mesh(placedGeometry, this.material);
          let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);
          choppedGeometry.applyMatrix4(new THREE.Matrix4().makeTranslation(choppedDimensions.width/2, choppedDimensions.height/2, choppedDimensions.depth/2));
          let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);
          let choppedPosition = { x: this.position.x, y: this.position.y, z: this.position.z };
          if(this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane]) {
            this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane];
          } else {
            choppedPosition[this.workingPlane] += overlap;
          }
          placedMesh.position.set(this.position.x, this.position.y, this.position.z);
          choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);
          blocksToReturn.placed = placedMesh;
          if(!blocksToReturn.bonus) blocksToReturn.chopped = choppedMesh;
        } else {
          this.state = this.STATES.MISSED;
        }
        this.dimension[this.workingDimension] = overlap;
        return blocksToReturn;
      }
      tick() {
        if(this.state == this.STATES.ACTIVE) {
          let value = this.position[this.workingPlane];
          if(value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT)
            this.reverseDirection();
          this.position[this.workingPlane] += this.direction;
          this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
        }
      }
    }
    
    class StackGame {
      constructor() {
        this.blocks = [];
        this.state = "READY"; // READY, PLAYING, ENDED
        this.scoreElem = document.getElementById("score");
        this.instructionsElem = document.getElementById("instructions");
        this.gameOverElem = document.querySelector(".game-over");
        this.newBlocksGroup = new THREE.Group();
        this.placedBlocksGroup = new THREE.Group();
        this.choppedBlocksGroup = new THREE.Group();
        this.stage = new Stage();
        this.stage.add(this.newBlocksGroup);
        this.stage.add(this.placedBlocksGroup);
        this.stage.add(this.choppedBlocksGroup);
        this.addBlock();
        this.tick();
        this.updateState("READY");
        document.addEventListener("keydown", (e) => {
          if(e.keyCode == 32) this.onAction();
        });
        document.addEventListener("click", (e) => {
          this.onAction();
        });
        document.addEventListener("touchstart", (e) => {
          e.preventDefault();
        });
      }
      updateState(newState) {
        // Для простоты: можно добавить классы на container, если нужно
        this.state = newState;
      }
      onAction() {
        if(this.state == "PLAYING") {
          this.placeBlock();
        } else if(this.state == "ENDED") {
          this.restartGame();
        }
      }
      startPlaying() {
        this.state = "PLAYING";
        this.scoreElem.innerHTML = "0";
      }
      restartGame() {
        this.state = "RESETTING";
        let oldBlocks = this.placedBlocksGroup.children;
        let removeSpeed = 0.2;
        let delayAmt = 0.02;
        for (let i = 0; i < oldBlocks.length; i++) {
          TweenLite.to(oldBlocks[i].scale, removeSpeed, {
            x: 0, y: 0, z: 0,
            delay: (oldBlocks.length - i) * delayAmt,
            ease: Power1.easeIn,
            onComplete: () => this.placedBlocksGroup.remove(oldBlocks[i])
          });
          TweenLite.to(oldBlocks[i].rotation, removeSpeed, {
            y: 0.5,
            delay: (oldBlocks.length - i) * delayAmt,
            ease: Power1.easeIn
          });
        }
        let totalDelay = removeSpeed * 2 + oldBlocks.length * delayAmt;
        this.blocks = this.blocks.slice(0, 1);
        setTimeout(() => {
          this.scoreElem.innerHTML = "0";
          this.state = "PLAYING";
          this.addBlock();
        }, totalDelay * 1000);
      }
      placeBlock() {
        let currentBlock = this.blocks[this.blocks.length - 1];
        let newBlocks = currentBlock.place();
        this.newBlocksGroup.remove(currentBlock.mesh);
        if(newBlocks.placed)
          this.placedBlocksGroup.add(newBlocks.placed);
        if(newBlocks.chopped) {
          this.choppedBlocksGroup.add(newBlocks.chopped);
          let posParams = {
            y: "-=30",
            ease: Power1.easeIn,
            onComplete: () => this.choppedBlocksGroup.remove(newBlocks.chopped)
          };
          let rotateParams = {
            delay: 0.05,
            x: (newBlocks.plane === "z") ? Math.random() * 10 - 5 : 0.1,
            z: (newBlocks.plane === "x") ? Math.random() * 10 - 5 : 0.1,
            y: Math.random() * 0.1
          };
          if(newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane]) {
            posParams[newBlocks.plane] = "+=" + 40 * Math.abs(newBlocks.direction);
          } else {
            posParams[newBlocks.plane] = "-=" + 40 * Math.abs(newBlocks.direction);
          }
          TweenLite.to(newBlocks.chopped.position, 1, posParams);
          TweenLite.to(newBlocks.chopped.rotation, 1, rotateParams);
        }
        if(currentBlock.state == currentBlock.STATES.MISSED) {
          return this.endGame();
        } else {
          this.addBlock();
        }
        this.scoreElem.innerHTML = String(this.blocks.length - 1);
      }
      addBlock() {
        let lastBlock = this.blocks[this.blocks.length - 1];
        if(lastBlock && lastBlock.state == lastBlock.STATES.MISSED) {
          return this.endGame();
        }
        let newBlock = new Block(lastBlock);
        this.newBlocksGroup.add(newBlock.mesh);
        this.blocks.push(newBlock);
      }
      endGame() {
        this.state = "ENDED";
        containerElem.classList.add("ended");
        let finalScore = this.blocks.length - 1;
        localUserData.points += finalScore;
        if(userRef)
          userRef.update({ points: localUserData.points });
        setTimeout(() => {
          document.getElementById("endTitle").textContent = "Game Over!";
          document.getElementById("endMessage").textContent = "Your score: " + finalScore;
          document.getElementById("end").style.visibility = "visible";
        }, 1000);
      }
      tick() {
        if(this.blocks.length > 0) {
          this.blocks[this.blocks.length - 1].tick();
        }
        this.stage.render();
        requestAnimationFrame(() => this.tick());
      }
    }
    
    let stackGame = new StackGame();
    
    /* ---------- Запуск игры через кнопку Start ---------- */
    // Слушатель для стартовой кнопки в меню
    document.getElementById("menuStartBtn").addEventListener("click", () => {
      // Если данные не загружены или билетов нет – показываем модальное окно
      if(!dataLoaded || localUserData.tickets < 1) {
        modalType = "noTickets";
        document.getElementById("endTitle").textContent = "Not enough tickets!";
        document.getElementById("endMessage").textContent = "Please come back later.";
        document.getElementById("end").style.visibility = "visible";
        return;
      }
      // Уменьшаем билеты на 1
      localUserData.tickets--;
      if(userRef) userRef.update({ tickets: localUserData.tickets });
      updateHeader();
      // Скрываем меню (header, back, меню старт)
      document.getElementById("header").style.display = "none";
      document.getElementById("backContainer").style.display = "none";
      document.getElementById("menu").style.display = "none";
      // Показываем элементы игры
      document.getElementById("game").style.display = "block";
      document.getElementById("score").style.display = "block";
      document.getElementById("instructions").style.display = "block";
      // Запускаем игру
      stackGame.restartGame();
      stackGame.startPlaying();
    });
    
    // Фоновая музыка запускается при первом клике (из-за ограничений браузера)
    document.body.addEventListener("click", () => {
      const bgSound = document.getElementById("bgSound");
      if(bgSound.paused) {
        bgSound.play().catch(err => console.log(err));
      }
    }, { once: true });
    
  </script>
</body>
</html>

