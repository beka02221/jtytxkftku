<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <!-- Для мобильных устройств -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pac‑Man Game with Tickets</title>
  
  <!-- Font: Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  
  <!-- Telegram WebApp API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <style>
    /* ЗАДАНИЕ ПЕРЕМЕННЫХ ДЛЯ СПРАЙТОВ (можно задать конкретные значения) */
    :root {
      --yellow-sprite-x: -3.2rem;
      --yellow-sprite-y: 0rem;
      --red-sprite-x: 0rem;
      --red-sprite-y: 0rem;
      --pink-sprite-x: 0rem;
      --pink-sprite-y: 0rem;
      --blue-sprite-x: 0rem;
      --blue-sprite-y: 0rem;
      --orange-sprite-x: 0rem;
      --orange-sprite-y: 0rem;
      --yellow-animation-length: 190ms;
      --red-animation-length: 200ms;
      --pink-animation-length: 200ms;
      --blue-animation-length: 200ms;
      --orange-animation-length: 200ms;
    }
    
    html {
      font-size: 0.625em;
    }
    @media (max-width: 600px), (max-height: 700px) {
      html {
        font-size: 0.3125em;
      }
    }
    
    /* Общая стилизация */
    body, #game, #info, #lives {
      display: flex;
    }
    body {
      box-sizing: border-box;
      margin: 0;
      background-color: #000;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
      padding: 1em 0;
      font-family: "joystick", Arial, sans-serif;
    }
    
    /* Header с информацией о пользователе (Firebase/Telegram) */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 50px;
      background: #6d4fba;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #info {
      display: flex;
      gap: 20px;
      font-size: 10px;
      color: #fff;
      align-items: center;
    }
    #info span {
      white-space: nowrap;
    }
    .balance {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .balance img {
      width: 16px;
      height: 16px;
    }
    
    /* Текст приглашения к началу игры */
    #game-start {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: yellow;
      font-size: 2.4rem;
      z-index: 2;
      user-select: none;
    }
    
    /* Контейнер игры (игровая область Pac‑Man) */
    #game {
      display: none;
      flex-direction: column;
      width: 56rem;
      height: 62rem;
    }
    
    /* Инфо игры */
    #info {
      width: 100%;
      justify-content: space-between;
      padding: 1em 2em;
      box-sizing: border-box;
    }
    #score {
      color: white;
      margin: 0;
      font-size: 2rem;
    }
    #lives {
      display: flex;
    }
    .live {
      width: 3.2rem;
      height: 2.6rem;
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      background-position: -26rem -3.2rem;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .live {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites_small.png");
      }
    }
    
    /* Игровое поле */
    #game-board {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      width: 56rem;
      height: 62rem;
      display: grid;
      grid-template-columns: repeat(28, 2rem);
    }
    #game-board > * {
      position: relative;
      box-sizing: border-box;
      width: 2rem;
      height: 2rem;
    }
    #start {
      position: absolute;
      margin: auto;
      width: 100%;
      top: 54%;
      text-align: center;
      color: yellow;
      font-size: 2.4rem;
      z-index: 1;
      user-select: none;
    }
    
    /* Стиль стен и объектов игрового поля */
    .wall {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/map.png");
      z-index: 1;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .wall {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/small_map.png");
      }
    }
    .blank {
      background-color: black;
    }
    .wall > * {
      box-sizing: border-box;
      background-color: black;
      display: block;
      position: relative;
      width: 1.5rem;
      height: 1.5rem;
      border: 0.2rem solid #161693;
      border-radius: 80%;
      z-index: 1;
    }
    .point,
    .big-point {
      box-sizing: border-box;
      width: 2rem;
      height: 2rem;
      background-color: #ffb897;
      border-radius: 0;
      z-index: 10;
    }
    .point {
      border: 0.8rem solid black;
    }
    .big-point {
      border: 0.4rem solid black;
      border-radius: 45%;
      background-color: #ffb897;
    }
    .gate {
      background-color: #ffb897;
      border-top: 0.7rem solid black;
      border-bottom: 0.7rem solid black;
    }
    
    /* Стили для персонажей */
    .yellow,
    .red,
    .pink,
    .blue,
    .orange,
    .points::after {
      image-rendering: pixelated;
      position: absolute;
      top: -0.4rem;
      left: -0.55rem;
      width: 3rem;
      height: 2.8rem;
    }
    .points::after {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      background-position: var(--yellow-sprite-x) var(--yellow-sprite-y);
    }
    .yellow-visible,
    .red-visible,
    .pink-visible,
    .blue-visible,
    .orange-visible {
      background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites.png");
      z-index: 101;
      will-change: transform, background-position;
    }
    @media (max-width: 600px), (max-height: 700px) {
      .yellow-visible,
      .red-visible,
      .pink-visible,
      .blue-visible,
      .orange-visible,
      .points::after {
        background-image: url("https://dominikgorczyca.github.io/Pac-Man/sprites_small.png");
      }
    }
    .yellow-visible {
      background-position: var(--yellow-sprite-x) var(--yellow-sprite-y);
      transition: transform var(--yellow-animation-length) linear;
      z-index: 100;
    }
    .red-visible {
      background-position: var(--red-sprite-x) var(--red-sprite-y);
      transition: transform var(--red-animation-length) linear;
      z-index: 104;
    }
    .pink-visible {
      background-position: var(--pink-sprite-x) var(--pink-sprite-y);
      transition: transform var(--pink-animation-length) linear;
      z-index: 103;
    }
    .blue-visible {
      background-position: var(--blue-sprite-x) var(--blue-sprite-y);
      transition: transform var(--blue-animation-length) linear;
      z-index: 102;
    }
    .orange-visible {
      background-position: var(--orange-sprite-x) var(--orange-sprite-y);
      transition: transform var(--orange-animation-length) linear;
    }
    
    /* Для модального окна */
    #end {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;
      z-index: 1200;
      background: rgba(0, 0, 0, 0.7);
    }
    #end .modal {
      background: #222;
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 400px;
      text-align: center;
      color: #FF00FF;
      font-size: 14px;
    }
    #end .modal button {
      margin-top: 10px;
      font-size: 12px;
      padding: 6px 12px;
      background: #06B6D1;
      color: #262626;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 3px #6b6b6b;
    }
    
    /* Canvas (если понадобится, например, для спецэффектов) */
    canvas {
      position: absolute;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Header с информацией о пользователе (Firebase/Telegram) -->
  <div id="header">
    <div id="info">
      <span id="username">@User</span>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/ticket.png" alt="Ticket">
        <span id="ticketCount">0</span>
      </div>
      <div class="balance">
        <img src="https://raw.githubusercontent.com/qnexst/404token/main/star.png" alt="Points">
        <span id="pointCount">0</span>
      </div>
    </div>
  </div>
  
  <!-- Временной индикатор (можно убрать, если не нужен в игре Pac‑Man) -->
  <!-- Здесь он не используется в оригинальном коде, но если нужно – его можно добавить -->
  <!-- <div id="timeBarContainer">
    <div id="timeBar"></div>
  </div> -->

  <!-- Кнопка Back -->
  <div id="backContainer">
    <button id="backBtn" onclick="goBack()">Back</button>
  </div>
  
  <!-- Игра (элементы из кода Pac‑Man) -->
  <h3 id="game-start">Click Anywhere to play</h3>
  <div id="game">
      <div id="info">
          <h3 id="score">Score 0</h3>
          <div id="lives">
              <div class="live"></div>
              <div class="live"></div>
              <div class="live"></div>
          </div>
      </div>
      <div id="game-board">
          <p id="start">Ready!</p>
      </div>
  </div>
  
  <!-- Модальное окно для окончания игры и уведомлений -->
  <div id="end">
    <div class="modal">
      <h2 id="endTitle"></h2>
      <p id="endMessage"></p>
      <button id="endBtn">OK</button>
    </div>
  </div>
  
  <!-- Звуки -->
  <audio id="bgSound" src="background.mp3" loop></audio>
  <audio id="moveSound" src="move.mp3"></audio>
  <audio id="deathSound" src="death.mp3"></audio>
  
  <script>
    /* ----------------------------------------
       1. Firebase и Telegram инициализация
    ---------------------------------------- */
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev-ex",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    let tg = null;
    if (window.Telegram && window.Telegram.WebApp) {
      tg = window.Telegram.WebApp;
      tg.expand();
    }
    
    let currentUser = null;
    let userRef = null;
    let localUserData = { tickets: 0, points: 0 };
    // Флаг загрузки данных – даём 3 секунды
    let dataLoaded = false;
    setTimeout(() => { dataLoaded = true; }, 3000);
    
    if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
      currentUser = tg.initDataUnsafe.user;
      document.getElementById('username').textContent = '@' + currentUser.username;
      userRef = db.ref('users/' + currentUser.username);
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    } else {
      currentUser = { username: 'TestUser' };
      document.getElementById('username').textContent = '@TestUser';
      userRef = db.ref('users/TestUser');
      userRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          userRef.set({ tickets: 5, points: 0 });
        }
      });
      userRef.on('value', snapshot => {
        const data = snapshot.val() || {};
        localUserData.tickets = data.tickets || 0;
        localUserData.points = data.points || 0;
        updateHeader();
        dataLoaded = true;
      });
    }
    
    function updateHeader() {
      document.getElementById('ticketCount').textContent = localUserData.tickets;
      document.getElementById('pointCount').textContent = localUserData.points;
    }
    
    function goBack() {
      window.location.href = 'index.html';
    }
    // Для случая Game Over, кнопка OK – если modalType "gameOver" перенаправляет, если "noTickets" просто скрывает модал
    let modalType = "gameOver";
    document.getElementById('endBtn').addEventListener('click', function() {
      if (modalType === "gameOver") {
        goToIndex();
      } else if (modalType === "noTickets") {
        document.getElementById('end').style.display = 'none';
      }
    });
    function goToIndex() {
      window.location.href = 'index.html';
    }
    
    /* ----------------------------------------
       2. Pac‑Man Game Code (адаптирован из вашего примера)
       Здесь приведён основной каркас – полный код игры (движения, столкновения, уровни) должен быть дополнительно доработан
    ---------------------------------------- */
    const gameStartText = document.getElementById("game-start");
    const gameBoard = document.getElementById("game-board");
    const startText = document.getElementById("start");
    const scoreElement = document.getElementById("score");
    const lives = document.getElementById("lives");
    const root = document.documentElement.style;
    
    let soundtrack = document.createElement("audio");
    soundtrack.loop = true;
    soundtrack.volume = 0.7;
    let sound = document.createElement("audio");
    sound.volume = 0.5;
    
    // Позиции и изменения для движения
    const startingPositions = [658, 322, 406, 404, 408];
    const positionChange = {
      "ArrowRight": 1,
      "ArrowLeft": -1,
      "ArrowUp": -28,
      "ArrowDown": 28,
    };
    const oppositeDirection = {
      "ArrowUp": "ArrowDown",
      "ArrowDown": "ArrowUp",
      "ArrowRight": "ArrowLeft",
      "ArrowLeft": "ArrowRight",
    };
    const yellowSprite = {
      "ArrowRight": 0,
      "ArrowLeft": 3.2,
      "ArrowUp": 6.4,
      "ArrowDown": 9.6,
    };
    const ghostSprite = {
      "ArrowRight": 0,
      "ArrowLeft": 6.4,
      "ArrowUp": 12.8,
      "ArrowDown": 19.2,
    };
    const eatenSprite = {
      "ArrowRight": 25.6,
      "ArrowLeft": 28.8,
      "ArrowUp": 32,
      "ArrowDown": 35.2,
    };
    const characters = [{
        name: "yellow",
        direction: "ArrowLeft",
        directionNew: undefined,
        position: 658,
        nextPosition: undefined,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
    },
    {
        name: "red",
        direction: "ArrowLeft",
        directionOld: undefined,
        directionList: ["ArrowUp", "ArrowUp", "ArrowUp"],
        position: 38,
        nextPosition: undefined,
        scatterTarget: 27,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
    },
    {
        name: "pink",
        direction: "ArrowDown",
        directionOld: undefined,
        directionList: ["ArrowDown", "ArrowUp", "ArrowUp", "ArrowUp", "ArrowUp"],
        position: 406,
        nextPosition: undefined,
        scatterTarget: 0,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
    },
    {
        name: "blue",
        direction: "ArrowUp",
        directionOld: undefined,
        directionList: ["ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowRight", "ArrowRight", "ArrowUp", "ArrowUp", "ArrowUp"],
        position: 404,
        nextPosition: undefined,
        scatterTarget: 867,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
    },
    {
        name: "orange",
        direction: "ArrowUp",
        directionOld: undefined,
        directionList: ["ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowDown", "ArrowUp", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowLeft", "ArrowUp", "ArrowUp", "ArrowUp"],
        position: 408,
        nextPosition: undefined,
        scatterTarget: 840,
        mode: "normal",
        status: "normal",
        characterNode: undefined,
        animationLength: undefined,
        animationStart: undefined,
    },
    ];
    let elements;
    let points = 0;
    let collisionInterval;
    let ghostMode;
    let ghostModeInterval;
    let changingBackInterval;
    let isFrightenedWhite = false;
    let ghostsEaten = 0;
    let newLevel = true;
    let score = 0;
    let livesLost = 0;
    let gameStartLength = 4200;
    let whichMunch = 1;
    
    // Запуск игры при клике
    document.addEventListener("click", startGame);
    
    soundtrack.addEventListener('timeupdate', () => {
      var buffer = 0.3;
      if (soundtrack.currentTime > soundtrack.duration - buffer) {
        soundtrack.currentTime = 0; 
        soundtrack.play();
      }
    });
    
    function startGame() {
      gameStartText.style.display = "none";
      game.style.display = "block";
      startLevel();
      document.removeEventListener("click", startGame);
    }
    
    function startLevel() {
      if (newLevel == true) {
        gameStartLength = 4200;
        sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/game_start.wav";
        makeLevel();
        sound.play();
      }
      setStartingProperties();
      setTimeout(() => {
        soundtrack.src = "https://dominikgorczyca.github.io/Pac-Man/audio/siren1.wav";
        soundtrack.play();
        sound.pause();
        lives.children[livesLost].style.visibility = "hidden";
        livesLost++;
        characterMove(0);
        characterMove(1);
        ghostRevive(2, 0);
        ghostRevive(3, 0);
        ghostRevive(4, 0);
        collisionInterval = setInterval(checkCollisions, 10);
        ghostModeInterval = setTimeout(changeModes, 5000);
      }, gameStartLength);
    }
    
    function makeLevel() {
      const gameClass = {
        0: "blank",
        1: "left-right wall",
        2: "top-bottom wall",
        3: "top-right wall",
        4: "top-left wall",
        5: "bottom-right wall",
        6: "bottom-left wall",
        7: "top wall",
        8: "bottom wall",
        9: "right wall",
        10: "left wall",
        11: "gate wall",
        12: "wall-empty" 
      }
      const gameArray = [ /* массив для уровня – вставьте нужные числа */ ];
      
      for (let i = 0; i < gameArray.length; i++) {
        const element = document.createElement("DIV");
        if (gameArray[i] > 25) {
          element.className = "blank";
          for (let j = 0; j < characters.length; j++) {
            let character = document.createElement("DIV");
            character.className = characters[j].name;
            element.append(character);
          }
          if (gameArray[i] / 100 > 1) {
            let character = document.createElement("DIV");
            character.className = Math.floor(gameArray[i] / 100) == 1 ? "point" : "big-point";
            element.append(character);
          }
        } else {
          element.className = "wall";
          element.style.backgroundPosition = `-${gameArray[i] * 2}rem 0`;
        }
        gameBoard.append(element);
      }
      points = 0;
      elements = Array.from(gameBoard.children).splice(1);
      transformStartingElements();
    }
    
    function setStartingProperties() {
      newLevel = undefined;
      window.removeEventListener("keydown", getDirection);
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchmove", handleTouchMove);
      clearTimeout(ghostModeInterval);
      game.style.visibility = "visible";
      document.getElementById("start").style.display = "block";
      ghostMode = "scatter";
      ghostsEaten = 0;
      scoreElement.innerHTML = "Score " + score;
      for (let i = 0; i < characters.length; i++) {
        characters[i].position = startingPositions[i];
        characters[i].direction = i < 2 ? "ArrowLeft" : characters[i].directionList[0];
        characters[i].characterNode = elements[characters[i].position].children[i];
        characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
        characters[i].mode = "normal";
        characters[i].status = "normal";
        if (i == 0) {
          root.setProperty(`--${characters[i].name}-sprite-x`, "-6.4rem");
          root.setProperty(`--${characters[i].name}-sprite-y`, "0rem");
          characters[i].directionNew = undefined;
        } else {
          getSprite(i);
        }
      }
      setTimeout(() => {
        window.addEventListener("keydown", getDirection);
        document.addEventListener('touchstart', handleTouchStart);        
        document.addEventListener('touchmove', handleTouchMove);
        for (let i = 2; i < 5; i++) {
          characters[i].animationLength = 200;
          characters[i].characterNode.classList.add(`${characters[i].name}-revive`);
        }
        document.getElementById("start").style.display = "none";
        getSprite(0);
      }, gameStartLength);
    }
    
    function transformStartingElements() {
      for (let i = 0; i < 5; i++) {
        if (i == 1) {
          for (let j = 1; j < 5; j++) {
            elements[startingPositions[i]].children[j].style.transform = "translateX(-1rem)";
          }
        } else {
          elements[startingPositions[i]].children[i].style.transform = "translateX(-1rem)";
        }
      }
    }
    
    function changeModes() {
      if (ghostMode === "scatter") {
        ghostMode = "chase";
        ghostModeInterval = setTimeout(changeModes, 25000);
      } else if (ghostMode === "chase") {
        ghostMode = "scatter";
        ghostModeInterval = setTimeout(changeModes, 5000);
      }
      changeGhostDirections();
    }
    
    function checkCollisions() {
      // Реализуйте логику столкновений (например, на основе CSS‑трансформаций)
    }
    
    function characterMove(i) {
      if (characters[i].status == "freeze") return;
      characters[i].nextPosition = getNewPosition(i);
      if (elements[characters[i].nextPosition].classList.contains("wall")) {
        setTimeout(() => { characterMove(i); }, 50);
        return;
      }
      getAnimationLength(i);
      getSprite(i);
      getTransition(i);
      changePosition(i);
    }
    
    function getNewPosition(i) {
      if (i == 0) {
        getYellowDirection(i);
      } else if (characters[i].direction != oppositeDirection[characters[i].directionOld]) {
        if (characters[i].mode == "frightened") {
          getRandomDirection(i);
        } else {
          getGhostDirection(i);
        }
      } else {
        characters[i].directionOld = characters[i].direction;
      }
      return characters[i].position + positionChange[characters[i].direction];
    }
    
    function getYellowDirection(i) {
      if (characters[i].directionNew != undefined) {
        const newPosition = characters[i].position + positionChange[characters[i].directionNew];
        if (!elements[newPosition].classList.contains("wall")) {
          characters[i].direction = characters[i].directionNew;
          characters[i].directionNew = undefined;
        }
      }
    }
    
    function getGhostDirection(i) {
      let newDirection = characters[i].directionOld = characters[i].direction;
      let biggestDistance = 100000;
      let target = (i === 1) ? characters[0].position : characters[0].position;
      for (let [direction, value] of Object.entries(positionChange)) {
        const newPosition = characters[i].position + value;
        const newDistance = Math.pow(Math.floor(target / 28) - Math.floor(newPosition / 28), 2) + 
                            Math.pow(target % 28 - newPosition % 28, 2);
        if (newDistance < biggestDistance) {
          if (!elements[newPosition].classList.contains("wall") &&
              oppositeDirection[direction] != characters[i].direction) {
            biggestDistance = newDistance;
            newDirection = direction;
          }
        }
      }
      characters[i].direction = newDirection;
    }
    
    function getRandomDirection(i) {
      let newDirection;
      do {
        newDirection = Object.keys(positionChange)[Math.floor(Math.random() * 4)];
      } while (elements[characters[i].position + positionChange[newDirection]].classList.contains("wall") ||
               oppositeDirection[newDirection] == characters[i].direction);
      characters[i].direction = newDirection;
    }
    
    function getAnimationLength(i) {
      let animationLength;
      if (i == 0) {
        animationLength = characters[i].mode == "hasEaten" ? 210 : 190;
      } else {
        animationLength = 200;
      }
      root.setProperty(`--${characters[i].name}-animation-length`, animationLength + "ms");
      characters[i].animationLength = animationLength;
    }
    
    function getSprite(i) {
      let spriteX, spriteY;
      if (i == 0) {
        spriteX = 3.2;
        spriteY = yellowSprite[characters[i].direction];
      } else {
        if (characters[i].mode == "normal") {
          spriteX = ghostSprite[characters[i].direction];
          spriteY = 9.6 + 3.2 * i;
        } else if (characters[i].mode == "frightened") {
          spriteX = 25.6;
          spriteY = 12.8;
        } else {
          spriteX = eatenSprite[characters[i].direction];
          spriteY = 16;
        }
      }
      root.setProperty(`--${characters[i].name}-sprite-x`, `-${spriteX}rem`);
      root.setProperty(`--${characters[i].name}-sprite-y`, `-${spriteY}rem`);
    }
    
    function getTransition(i) {
      const isGoingToRespawn = characters[i].mode == "eaten" && characters[i].nextPosition == 322;
      const transitionMove = {
        "ArrowUp": "Y(-2rem)",
        "ArrowDown": "Y(2rem)",
        "ArrowRight": isGoingToRespawn ? "X(1rem)" : "X(2rem)",
        "ArrowLeft": isGoingToRespawn ? "X(-3rem)" : "X(-2rem)",
      };
      characters[i].characterNode.style.transform = `translate${transitionMove[characters[i].direction]}`;
    }
    
    async function changePosition(i) {
      await new Promise(resolve => {
        if (characters[i].mode != "eaten") {
          characters[i].characterNode.classList.add(`${characters[i].name}-animation-move`);
        }
        characters[i].animationStart = performance.now();
        setTimeout(() => {
          characters[i].characterNode.classList.remove(`${characters[i].name}-animation-move`, `${characters[i].name}-visible`);
          characters[i].characterNode.style.transform = "";
          characters[i].position = characters[i].nextPosition;
          characters[i].characterNode = elements[characters[i].position].children[i];
          characters[i].characterNode.classList.add(`${characters[i].name}-visible`);
          if (i == 0) {
            eatPoint(i);
          } else if (characters[i].mode == "eaten" && characters[i].position === 322) {
            ghostRetreat(i);
          }
          resolve("");
        }, characters[i].animationLength);
      });
      characterMove(i);
    }
    
    function eatPoint(i) {
      const point = elements[characters[i].position].children[5];
      if (point != undefined) {
        points++;
        characters[i].mode = "hasEaten";
        if (point.classList.contains("big-point")) {
          score += 50;
        } else {
          score += 10;
          if (!sound.src.includes("munch") || sound.paused) {
            sound.src = "https://dominikgorczyca.github.io/Pac-Man/audio/munch.wav";
            sound.play();
          }
        }
        scoreElement.innerHTML = "Score " + score;
        point.remove();
        if (points == 244) {
          gameWin();
          freezeCharacters();
        }
      } else {
        characters[i].mode = "normal";
        if (sound.src.includes("munch")) {
          sound.pause();
        }
      }
    }
    
    // Остальные функции (ghostRevive, changeModes, freezeCharacters, etc.)
    // Опущены для краткости – вставьте полный код игры, если необходимо.
    
    /* ----------------------------------------
       3. Главный игровой цикл
    ---------------------------------------- */
    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (!previousTimestamp) previousTimestamp = timestamp;
      const delta = timestamp - previousTimestamp;
      previousTimestamp = timestamp;
      
      // Обновление таймера (если нужно, здесь можно добавить логику таймера игры)
      if (gameStartTime) {
        let elapsed = timestamp - gameStartTime;
        let remaining = gameDuration - elapsed;
        // Если время истекло, завершаем игру
        if (remaining <= 0) {
          if (!gameEnded) { endGame(); }
        }
      }
      
      // Обновление позиций персонажей, столкновения и т.д.
      // (Остальной игровой цикл – вставьте полный код, если необходимо)
      
      camera.lookAt(chicken.position);
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);
    
    /* ----------------------------------------
       4. Обработчики ввода
    ---------------------------------------- */
    document.body.addEventListener('click', () => {
      const bgSound = document.getElementById('bgSound');
      if (bgSound.paused) {
        bgSound.play().catch(err => console.log(err));
      }
    }, { once: true });
    
    function getDirection(e) {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case "ArrowRight":
        case "ArrowLeft":
          characters[0].directionNew = e.key;
      }
    }
    let xDown = null, yDown = null;
    function handleTouchStart(e) {
      const firstTouch = e.touches[0];
      xDown = firstTouch.clientX;
      yDown = firstTouch.clientY;
    }
    function handleTouchMove(e) {
      if (!xDown || !yDown) return;
      let xMove = e.touches[0].clientX;
      let yMove = e.touches[0].clientY;
      let xDiff = xDown - xMove;
      let yDiff = yDown - yMove;
      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        characters[0].directionNew = (xDiff > 0) ? "ArrowLeft" : "ArrowRight";
      } else {
        characters[0].directionNew = (yDiff > 0) ? "ArrowUp" : "ArrowDown";
      }
      xDown = null;
      yDown = null;
    }
  </script>
</body>
</html>

